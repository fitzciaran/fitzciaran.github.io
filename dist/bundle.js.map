{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,yCAAyC,0BAA0B;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gCAAgC;AAChC,mCAAmC;AACnC,kCAAkC;AAClC,oCAAoC;AACpC,iCAAiC;AACjC;AACA;AACA,gCAAgC;AAChC,mCAAmC;AACnC,kCAAkC;AAClC,oCAAoC;AACpC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtIiB;AACoD;AACnB;AACC;AACnD;AAWwB;AACxB;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACP;AACO;AACA;AACA;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACA,EAAE,oDAAY;AACd;AACA,4CAA4C;AAC5C,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4DAAiB,IAAI,4DAAqB;AAChD,kBAAkB,4DAAiB;AACnC;AACA;AACA,gBAAgB,4DAAiB;AACjC;AACA,WAAW,oDAAK;AAChB,cAAc,uDAAQ;AACtB,mCAAmC,+DAAgB;AACnD,+BAA+B,6DAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8DAAmB;AAChE;AACA;AACA;AACA,4BAA4B,gDAAY;AACxC;AACA,6BAA6B,iDAAa;AAC1C;AACA;AACA,EAAE,+DAAe;AACjB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAU,IAAI,wDAAU,IAAI,wDAAU,QAAQ,wDAAU;AACjF;AACA;AACA,iBAAiB,wDAAU,IAAI,wDAAU,IAAI,wDAAU,QAAQ,wDAAU;AACzE;AACA,kBAAkB,IAAI,iDAAM,SAAS;AACrC,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,iDAAM;AACZ;AACA;AACA;AACA;AACA,UAAU,wDAAU;AACpB,UAAU,wDAAU;AACpB;AACA,kBAAkB,IAAI,iDAAM,SAAS;AACrC,gBAAgB,iDAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,MAAM;AACN;AACA;AACA,mCAAmC;AACnC,MAAM;AACN;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,+DAAe;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAU,0BAA0B,wDAAU;AAChF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE,sEAAoB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC59B8D;AACD;AAC0B;AACN;AACjF;AACA;AACO;AACA;AACP;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA,oCAAoC,2CAAK;AACzC,8CAA8C,4CAAM;AACpD;AACA;AACA;AACA;AACO;AACP,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAkB,CAAC,4CAAM;AACrC,UAAU,gEAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACO;AACP,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAQ;AACrC;AACA,UAAU;AACV,8CAA8C,kDAAY,EAAE,0CAAI,EAAE,4CAAM;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kDAAQ;AACvC;AACA,YAAY,0BAA0B,kDAAQ;AAC9C;AACA,YAAY;AACZ,gDAAgD,kDAAY,EAAE,0CAAI,EAAE,4CAAM;AAC1E;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAM,gDAAgD,oDAAU;AACzF,QAAQ,iDAAO;AACf,YAAY,0EAAkB,CAAC,4CAAM;AACrC,UAAU,+DAAiB;AAC3B;AACA;AACA;AACA;AACA;AACA,UAAU,0EAAkB,CAAC,4CAAM;AACnC,QAAQ,6DAAe;AACvB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,IAAI,0BAA0B,kDAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAM,eAAe,4CAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,sBAAsB,mDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uBAAuB,mDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,6BAA6B,oBAAoB;AACjD,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtV8C;AACD;AACK;AAClD;AACqC;AAC9B;AACA;AACA;AACP;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAAY;AACL;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACA,+BAA+B;AACxB;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8CAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+DAAiB;AACvB;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0DAAU;AAChB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oCAAoC;AACpC,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8CAAM;AACrC;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7biE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,aAAa;AACN;AACP;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW,IAAI,UAAU;AAClD,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc,aAAa,SAAS;AACjE;AACA;AACA,aAAa;AACb;AACA,8CAA8C,aAAa,IAAI,MAAM;AACrE;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,sDAAsD,MAAM;AAC5D;AACA,OAAO;AACP,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc,iBAAiB,aAAa,KAAK,SAAS;AACvF;AACA;AACA,aAAa;AACb;AACA,8CAA8C,aAAa,IAAI,MAAM;AACrE;AACA,aAAa;AACb,UAAU;AACV,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,cAAc,SAAS,YAAY;AAC3F;AACA;AACA,aAAa;AACb;AACA,6DAA6D,MAAM;AACnE;AACA,aAAa;AACb;AACA,OAAO;AACP;AACA,sDAAsD,MAAM;AAC5D;AACA,OAAO;AACP,IAAI;AACJ;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,cAAc,SAAS,YAAY;AAC3F;AACA;AACA,aAAa;AACb;AACA,6DAA6D,MAAM;AACnE;AACA,aAAa;AACb;AACA,OAAO;AACP;AACA,sDAAsD,MAAM;AAC5D;AACA,OAAO;AACP,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,MAAM;AAC9D,MAAM;AACN,iDAAiD,SAAS;AAC1D;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM;AAC7D,MAAM;AACN,iDAAiD,SAAS;AAC1D;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA,0CAA0C,UAAU,SAAS,MAAM;AACnE,MAAM;AACN,qBAAqB,UAAU,uBAAuB,SAAS;AAC/D;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU,SAAS,MAAM;AAClE,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,yCAAyC,UAAU,SAAS,MAAM;AAClE,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,yCAAyC,UAAU,SAAS,MAAM;AAClE,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC/U+E;AACuC;AACvE;AACL;AAC1C;AACO;AACP;AACA;AACA,kBAAkB;AAClB,yBAAyB;AACzB;AACA,6BAA6B,UAAU;AACvC;AACA;AACA;AACA,iDAAiD,sBAAsB;AACvE;AACA;AACA,uCAAuC,0EAAkB,SAAS;AAClE;AACA,mCAAmC,uBAAuB;AAC1D;AACA,gDAAgD,mDAAa,CAAC;AAC9D;AACA;AACA,4EAA4E,+EAA2B,CAAC;AACxG;AACA;AACA,0EAA0E,8EAA0B,CAAC;AACrG;AACA;AACA,4CAA4C,wBAAwB,IAAI,wBAAwB;AAChG;AACA;AACA;AACA;AACA,wBAAwB,gDAAQ;AAChC,mBAAmB,UAAU,SAAS,cAAc,aAAa,uBAAuB;AACxF,MAAM;AACN,mBAAmB,UAAU,SAAS,cAAc,UAAU,aAAa,GAAG,cAAc;AAC5F;AACA;AACA;AACA,GAAG;AACH;AACA,uDAAuD,8BAA8B;AACrF;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP,gCAAgC,+DAAoB;AACpD,oBAAoB,iDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4CAA4C,0DAAe;AAC3D;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,0DAA0D;AAC1D,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,yBAAyB;AACzB,kBAAkB;AAClB,yBAAyB;AACzB,sBAAsB;AACtB,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,YAAY,IAAI,MAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,kDAAkD;AAClD,kDAAkD;AAClD;AACA;AACA;AACA,4BAA4B;AAC5B,iCAAiC;AACjC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;;;;;;;AC/M+G;AASpF;AACsD;AAC5B;AACM;AAC3D;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,oEAAkB;AACtB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,0DAA0D;AAC1D,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAmB,kCAAkC,yDAAS;AACnF;AACA;AACA,kBAAkB,mBAAmB;AACrC,mBAAmB,qEAAmB,kCAAkC,yDAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAkB;AAC1B,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,cAAc;AACpB,MAAM,cAAc;AACpB,MAAM,cAAc;AACpB,MAAM,aAAa;AACnB,MAAM,aAAa;AACnB,MAAM,eAAe;AACrB;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C,yBAAyB,qEAAmB,8CAA8C,yDAAS;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C,+CAA+C;AAC/C;AACA,6CAA6C;AAC7C,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAqB;AACvC,oBAAoB,uEAAqB;AACzC;AACA;AACA;AACA;AACA;AACA,IAAI,sEAAsB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAqB;AACvC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5TO;AACiC;AACxC,YAAY,MAAM;AACX;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,+BAA+B;AAC/B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB,IAAI,iDAAM,SAAS;AACrC,kBAAkB,iDAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iDAAM;AACnD;AACA;AACA;AACA,kBAAkB,IAAI,iDAAM,SAAS;AACrC,kBAAkB,iDAAM;AACxB;AACA;AACA;AACA;AACA;AACA,MAAM,aAAa,iDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB;AACxB,0BAA0B;AAC1B,yBAAyB;AACzB;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA,0BAA0B,oDAAoD;AAC9E;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,iDAAiD;AACjD,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe,GAAG,eAAe,GAAG,eAAe;AACnE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,QAAQ;AAC3D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChXqC;AACF;AAC0B;AACN;AACvD;AACO;AACA;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,UAAU,0EAAkB,CAAC,4CAAM;AACnC,QAAQ,oEAAsB;AAC9B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iBAAiB,8CAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrUA;AACA;AACA;AACA;AAC0D;AAC1D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,+DAA+D,kDAAQ,6BAA6B,kDAAQ;AAC5G,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gCAAgC,kDAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1V8C;AACJ;AACW;AACrD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAmB;AACnD,iCAAiC,8DAAmB;AACpD,MAAM;AACN,4BAA4B,8DAAmB;AAC/C,6BAA6B,8DAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,oCAAoC;AACpC,kIAAkI;AAClI,+FAA+F;AAC/F,oCAAoC;AACpC;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,SAAS;AACT,mHAAmH;AACnH;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,SAAS;AACT,oHAAoH;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAmB;AACjD;AACA,gCAAgC;AAChC,iCAAiC;AACjC;AACA;AACA;AACA,uDAAuD;AACvD,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,gCAAgC;AAC9E,yDAAyD,sCAAsC;AAC/F,+CAA+C,+BAA+B;AAC9E,mCAAmC;AACnC,mCAAmC;AACnC;AACA;AACA;AACA;AACA,QAAQ,2DAAS,QAAQ,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAS,QAAQ,sBAAsB;AAC3C,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI,2DAAS,QAAQ,sBAAsB;AAC3C;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACxQuF;AACd;AACb;AACa;AACF;AAC9B;AACK;AACF;AACS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,cAAc;AAClB,IAAI,eAAe;AACnB,IAAI,aAAa;AACjB,IAAI,cAAc;AAClB;AACA;AACO;AACP;AACA,EAAE,qEAAc;AAChB,EAAE,sEAAe;AACjB;AACA;AACA,0BAA0B,yDAAQ,wBAAwB,8DAAgB;AAC1E,EAAE,gDAAM,oBAAoB,2DAAS;AACrC,EAAE,iDAAO;AACT,wBAAwB,sDAAQ;AAChC,mCAAmC,sDAAQ;AAC3C;AACA,EAAE,+DAAW;AACb,EAAE,uEAAmB;AACrB;AACA,IAAI,sDAAQ;AACZ,IAAI,+DAAe;AACnB;AACA,IAAI,gEAAgB;AACpB;AACA,EAAE,iEAAiB;AACnB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,oEAAkB;AACxB,MAAM;AACN;AACA;AACA,gCAAgC;AAChC;AACA;AACA,yCAAyC;AACzC,MAAM,oEAAkB;AACxB,MAAM;AACN;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,oEAAkB;AACtB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI,yBAAyB,oDAAU;AACvC;AACA,0BAA0B;AAC1B;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9JwH;AACjE;AAYtC;AACiD;AACf;AAC8D;AAC8B;AACrG;AAC6F;AACvE;AAChE;AACO;AACA;AACA;AACP;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACO,wBAAwB,4DAAqB;AACpD;AACO;AACP;AACA;AACA;AACO,oBAAoB,gDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU,mBAAmB,0BAA0B,oRAAoR;AACzV;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU,mBAAmB,wBAAwB,ySAAyS;AAChX;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU,UAAU,oBAAoB,sBAAsB,0WAA0W;AACxa;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS,UAAU,oBAAoB,uBAAuB,2TAA2T;AACzX;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE,8DAAgB,SAAS,0EAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,2CAAK,aAAa,QAAQ;AACzC,eAAe,2CAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAkB,CAAC,4CAAM;AACrC,UAAU,oEAAsB;AAChC;AACA,QAAQ,2CAAK;AACb;AACA;AACA;AACA,yBAAyB,kDAAQ,2BAA2B,kDAAQ;AACpE;AACA;AACA;AACA;AACA,YAAY,0EAAkB,CAAC,4CAAM;AACrC;AACA;AACA;AACA,QAAQ,2CAAK;AACb;AACA;AACA;AACA;AACA,sBAAsB,oDAAc;AACpC;AACA;AACA;AACA,oBAAoB,gDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACO;AACP,EAAE,kDAAY;AACd;AACA,sDAAsD,8CAAM;AAC5D;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,4BAA4B,8CAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP,EAAE,0CAAI;AACN;AACA,wCAAwC,2CAAG;AAC3C;AACA;AACA;AACA,4BAA4B,2CAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0CAAI;AACV;AACA,sCAAsC,2CAAG;AACzC;AACA;AACA,sCAAsC,2CAAG;AACzC;AACA,UAAU,0EAAkB,CAAC,4CAAM;AACnC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA,EAAE,sDAAY,CAAC,+CAAS;AACxB,OAAO,0EAAkB;AACzB,IAAI,qFAA6B,CAAC,8EAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,oEAAgB,6CAA6C,gDAAM;AACrE;AACA;AACA;AACA,IAAI,oEAAgB,kDAAkD,gDAAM;AAC5E,GAAG;AACH;AACA;AACA,IAAI,oEAAgB,0CAA0C,gDAAM;AACpE,GAAG;AACH;AACA,MAAM,+CAAS;AACf,IAAI,6EAA4B,8BAA8B,iDAAO;AACrE;AACA;AACA,uBAAuB,iDAAO;AAC9B;AACA;AACA,MAAM,0EAAkB;AACxB,QAAQ,+CAAS;AACjB,MAAM,+DAAiB;AACvB,MAAM,SAAS,+CAAS;AACxB,MAAM,gEAAkB;AACxB,MAAM,SAAS,+CAAS;AACxB,MAAM,mEAAqB;AAC3B;AACA;AACA,wBAAwB,+CAAS;AACjC,IAAI,8DAAgB,SAAS,0EAAkB;AAC/C;AACA;AACA,MAAM,+CAAS,eAAe,0EAAkB;AAChD,IAAI,kEAAY,CAAC,qDAAe,QAAQ,qDAAe,SAAS,4CAAM;AACtE,IAAI,sEAAgB,iBAAiB,qDAAe,QAAQ,qDAAe,SAAS,mDAAa;AACjG,IAAI,mEAAa,CAAC,qDAAe,QAAQ,qDAAe,SAAS,4CAAM;AACvE,IAAI,+EAAyB,CAAC,qDAAe,QAAQ,qDAAe,SAAS,4CAAM;AACnF;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAkB;AAC9B,UAAU,oEAAsB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA,YAAY,0EAAkB;AAC9B,UAAU,oEAAsB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,aAAa,iDAAa;AAC1B,aAAa,gDAAY;AACzB,aAAa,iDAAa;AAC1B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,WAAW;AACX;AACA;AACO;AACP,UAAU,QAAQ;AAClB;AACA;AACA;AACO;AACP,UAAU,cAAc;AACxB;AACA;AACA;AACO;AACP,UAAU,cAAc;AACxB;AACA;AACA;AACO;AACP,UAAU,gBAAgB;AAC1B;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACta0D;AACF;AACxD;AACO;AACP,SAAS,0CAAI;AACb;AACA;AACO;AACP,SAAS,gDAAM;AACf;AACA;AACO;AACP,SAAS,2CAAK;AACd;AACA;AACO;AACP,SAAS,iDAAO;AAChB;AACA;AACO;AACP,SAAS,oDAAc;AACvB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+BAA+B;AAC5D,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA,oBAAoB,gBAAgB;AACpC,6CAA6C;AAC7C;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4FAA4F,kDAAQ;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA,qBAAqB,oCAAoC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB,wBAAwB;AACjE,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,iCAAiC,OAAO;AACxC;AACA,iDAAiD;AACjD;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AC3Q6D;AACa;AACoD;AACxC;AACpD;AACoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP,OAAO,0EAAkB,CAAC,4CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,sBAAsB,iDAAO;AAC7B;AACA;AACA;AACA,MAAM,mEAAoB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gEAAkB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAAkB,CAAC,4CAAM;AACjC,MAAM,oEAAsB;AAC5B;AACA;AACA;AACA;AACA;AACO;AACP,OAAO,0EAAkB,CAAC,4CAAM;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS,0CAAI;AACb;AACA,kBAAkB,2CAAG;AACrB;AACA;AACA;AACA;AACA,MAAM,mEAAoB,SAAS,oDAAc;AACjD;AACA;AACA;AACA;AACA,IAAI,0CAAI;AACR;AACA;AACA;AACA;AACA,IAAI,4DAAc;AAClB;AACA;AACA;AACA,SAAS,0CAAI;AACb,uBAAuB,0CAAI;AAC3B,QAAQ,0EAAkB,CAAC,4CAAM;AACjC,MAAM,oEAAsB;AAC5B;AACA;AACA;AACA;AACA;AACO;AACP,OAAO,0EAAkB,CAAC,4CAAM;AAChC;AACA;AACA;AACA,uBAAuB,2CAAK,oCAAoC,kDAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,mBAAmB,8CAAI;AACvB;AACA;AACA;AACA;AACA;AACA,MAAM,mEAAoB;AAC1B;AACA;AACA,IAAI,2CAAK;AACT;AACA;AACA;AACA;AACA,IAAI,6DAAe;AACnB;AACA;AACA;AACA;AACA,IAAI,kDAAQ,CAAC,2CAAK;AAClB,QAAQ,0EAAkB,CAAC,4CAAM;AACjC,MAAM,oEAAsB;AAC5B;AACA;AACA;AACA;AACA;AACO;AACP,OAAO,0EAAkB,CAAC,4CAAM;AAChC;AACA;AACA;AACA,4BAA4B,gDAAM,kCAAkC,mDAAS;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mDAAS;AACf;AACA;AACA;AACA;AACA,IAAI,gDAAM;AACV;AACA;AACA;AACA;AACA,IAAI,8DAAgB;AACpB;AACA;AACA;AACA;AACA,kBAAkB,gDAAM;AACxB;AACA,UAAU,0EAAkB,CAAC,4CAAM;AACnC,QAAQ,oEAAsB,kBAAkB,gDAAM;AACtD;AACA,MAAM,gDAAM;AACZ;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAS,uDAAuD,mDAAS;AAC3F,EAAE,gDAAM;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACrW8E;AAU7C;AACyD;AACvC;AAW5B;AACmC;AAC8D;AACpD;AACpE;AACA;AACA;AACA;AACA;AACO;AACP,EAAE,sFAA8B;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0EAAkB;AACxB,IAAI,+EAAuB;AAC3B;AACA;AACA;AACA;AACA,IAAI,8DAAgB,SAAS,0EAAkB;AAC/C;AACA;AACA,gCAAgC,0EAAkB;AAClD;AACA,IAAI,+DAAiB,SAAS,0EAAkB;AAChD;AACA;AACA;AACA;AACA,kBAAkB,0DAAW;AAC7B;AACA;AACA;AACA,IAAI;AACJ;AACA,wBAAwB,8CAAM;AAC9B;AACA,SAAS,kEAAc;AACvB,MAAM,kEAAc;AACpB;AACA,IAAI,kEAAc;AAClB;AACA,IAAI,uEAAe,CAAC,2EAAmB;AACvC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0CAAI;AACvB,mBAAmB,0CAAI;AACvB;AACA,oBAAoB,2CAAK;AACzB,oBAAoB,2CAAK;AACzB;AACA,sBAAsB,iDAAO;AAC7B,sBAAsB,iDAAO;AAC7B;AACA,6BAA6B,gDAAM;AACnC,qBAAqB,gDAAM;AAC3B;AACA;AACA,IAAI,qFAA6B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAiB;AACzB,QAAQ;AACR,QAAQ,gEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAW,CAAC,kEAAc;AAClC;AACA;AACA;AACA;AACA,QAAQ,0DAAW,sBAAsB,kEAAc;AACvD;AACA;AACA;AACA;AACA;AACA,MAAM,yEAAiB,yCAAyC,kEAAc;AAC9E;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA,4CAA4C,iBAAiB,YAAY,uBAAuB,WAAW,UAAU;AACrH;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM,0EAAkB,YAAY,0EAAkB;AACtD,IAAI,+EAAuB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAW;AAChC;AACA;AACA;AACA;AACA,YAAY,2EAAmC,WAAW,iDAAa;AACvE;AACA;AACA,YAAY,2EAAmC,WAAW,iDAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gEAAiB;AACrB,IAAI;AACJ,IAAI,gEAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,4BAA4B,qEAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,IAAI,qFAA6B;AACjC;AACA;AACA;AACA,wBAAwB,2DAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kDAAQ,oCAAoC,kDAAQ;AACtF;AACA;AACA;AACA,oCAAoC,kDAAQ;AAC5C;AACA;AACA;AACA,QAAQ;AACR;AACA,mBAAmB,kEAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kDAAQ;AACZ;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kDAAQ;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI,qFAA6B;AACjC;AACA;AACA;AACA,0BAA0B,6DAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qBAAqB,oEAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wDAAU;AACd;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wDAAU;AACd;AACA;AACA;AACA;AACA;AACA,IAAI,qFAA6B;AACjC;AACA;AACA;AACA,uBAAuB,0DAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,kBAAkB,+DAAmB;AACrC;AACA;AACA;AACA;AACA;AACA,IAAI,iDAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iDAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,iDAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qFAA6B;AACjC;AACA;AACA;AACA,yBAAyB,4DAAa;AACtC;AACA;AACA,QAAQ;AACR;AACA,oBAAoB,mEAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uDAAS;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAS;AACb;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjqBiG;AAY5D;AACC;AACgB;AACG;AACT;AACc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iBAAiB;AACK;AAC7B;AACO;AACP;AACA;AACA;AACA;AACO;AACP,mBAAmB,0CAAI;AACvB,mBAAmB,0CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0CAAI;AAC9C,0CAA0C,0CAAI;AAC9C;AACA;AACA,sBAAsB,6DAAc;AACpC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAAI;AACpC,gCAAgC,0CAAI;AACpC;AACA;AACA,wBAAwB,6DAAc;AACtC;AACA,KAAK;AACL,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,sDAAY,OAAO,+CAAS,iBAAiB,sDAAY,OAAO,+CAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAI,iDAAM,SAAS;AACvC,kBAAkB,iDAAM;AACxB;AACA;AACA;AACA,wBAAwB,IAAI,iDAAM,SAAS;AAC3C,2BAA2B,iDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,sDAAY,OAAO,+CAAS,iBAAiB,sDAAY,OAAO,+CAAS;AAC/E;AACA,8BAA8B;AAC9B;AACA,oBAAoB,IAAI,iDAAM,SAAS;AACvC,kBAAkB,iDAAM;AACxB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,MAAM,4CAAM;AACZ;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,4CAAM,0BAA0B,0DAAe;AACxF;AACA,IAAI,4CAAM,eAAe,4CAAM;AAC/B,IAAI;AACJ;AACA,IAAI,4CAAM,eAAe,4CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4CAAM,2BAA2B,0DAAe;AACtD;AACA;AACA;AACA;AACA,EAAE,yEAAa,CAAC,mDAAS,IAAI,mDAAS,qBAAqB,4CAAM,kBAAkB,mDAAS;AAC5F;AACA;AACA;AACA,MAAM,4CAAM;AACZ,IAAI,4CAAM,eAAe,mEAAa;AACtC;AACA;AACA,EAAE,sDAAY,CAAC,+CAAS;AACxB;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA,IAAI,sDAAY,CAAC,+CAAS;AAC1B;AACA;AACA,IAAI,sDAAY,CAAC,+CAAS;AAC1B;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAW;AAC3B,gBAAgB,mEAAW;AAC3B,oBAAoB,uEAAe;AACnC,qBAAqB,wEAAgB;AACrC;AACA;AACA;AACA;AACA,IAAI,sDAAY,CAAC,+CAAS;AAC1B;AACA,YAAY,mEAAW;AACvB,YAAY,mEAAW;AACvB,gBAAgB,uEAAe;AAC/B,iBAAiB,wEAAgB;AACjC;AACA;AACA;AACA,IAAI,sDAAY,CAAC,+CAAS;AAC1B;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB,mDAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kDAAW,SAAS,kDAAW;AACzE,uBAAuB,kDAAW;AAClC;AACA,yDAAyD,kDAAW,6DAA6D,kDAAW;AAC5I;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM,8DAAmB;AACzB;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC9XmC;AACwG;AACtF;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW;AAC7C,4BAA4B,WAAW;AACvC,MAAM,4CAAM;AACZ,MAAM,mEAAoB;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA,qDAAqD,UAAU,aAAa,aAAa;AACzF;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D,4BAA4B,WAAW;AACvC,MAAM,4CAAM;AACZ;AACA;AACA;AACA,MAAM,2EAAmC,WAAW,iDAAa;AACjE,MAAM,mEAAoB;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA,8DAA8D,UAAU,aAAa,aAAa;AAClG;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wDAAwD;AACxD,0CAA0C,UAAU,+BAA+B;AACnF;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI,2EAAmC,WAAW,iDAAa;AAC/D,IAAI,mEAAoB;AACxB,6BAA6B,kCAAkC;AAC/D,IAAI,4CAAM;AACV,IAAI,iEAAyB,WAAW,iDAAa;AACrD;AACA;AACA;AACA;AACA,UAAU;AACV,oDAAoD,cAAc;AAClE;AACA;AACA,QAAQ;AACR;AACA,qCAAqC,YAAY;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iDAAa;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA,qDAAqD,eAAe;AACpE;AACA,aAAa;AACb;AACA,4DAA4D,MAAM;AAClE,aAAa;AACb,UAAU;AACV,0CAA0C;AAC1C;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,aAAa;AACb;AACA,4DAA4D,MAAM;AAClE,aAAa;AACb;AACA,OAAO;AACP;AACA,sDAAsD,MAAM;AAC5D,OAAO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjPqC;AAeJ;AACmB;AACiC;AACxC;AACyC;AACxC;AAYlB;AACqC;AAChB;AACZ;AACrC;AACO;AACA;AACP;AACA;AACO,QAAQ,cAAc,EAAE,6DAAW;AACnC,0BAA0B;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B;AACpC;AACA;AACA;AACA;AACO,mBAAmB,+CAAM;AAChC;AACA;AACO;AACA;AACA;AACA;AACP;AACO;AACA;AACP;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,IAAkD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAgB;AACpB;AACA;AACA;AACA;AACA;AACA,IAAI,0DAAS;AACb,IAAI;AACJ;AACA,IAAI,0DAAS;AACb;AACA,EAAE,+EAAuB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,gGAAwC,CAAC,yFAAqC;AAChF,EAAE,0FAAkC,CAAC,mFAA+B;AACpE,EAAE,sFAA8B,CAAC,+EAA2B;AAC5D,MAAM,+EAA2B,UAAU,mFAA+B;AAC1E;AACA;AACA;AACA,MAAM,8EAA0B,eAAe,0EAAkB;AACjE,IAAI,qFAA6B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,uEAAe,CAAC,2EAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAY;AAChB;AACA;AACA,IAAI;AACJ;AACA,IAAI,2DAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,wEAAqB;AACvB;AACA;AACA,oBAAoB,iDAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,IAAI,iDAAM;AACV;AACA;AACA;AACA;AACA,oBAAoB,iDAAM;AAC1B;AACA;AACA;AACA;AACA,EAAE,8EAAkB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,yEAAa;AACf;AACA;AACA;AACA;AACA,EAAE,+EAAmB,cAAc,yDAAc;AACjD,EAAE,2EAAe;AACjB,EAAE,4EAAgB;AAClB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6EAA0B;AAC9B;AACA;AACA;AACA;AACA;AACA,IAAI,+EAAmB;AACvB;AACA,IAAI,0EAAuB;AAC3B;AACA,IAAI,kEAAe;AACnB;AACA;AACA;AACA,IAAI,2EAAwB;AAC5B,IAAI,qEAAkB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,oDAAY;AAChB;AACA,IAAI,8EAA2B;AAC/B,IAAI,qEAAkB;AACtB,QAAQ,0EAAkB;AAC1B;AACA,MAAM,8DAAgB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,yDAAU;AACd,IAAI,+EAA4B;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAgB,SAAS,0EAAkB;AAC/C;AACA;AACA,IAAI,6EAA0B;AAC9B,IAAI,qEAAkB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+EAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kFAAsB;AAC5B;AACA,MAAM,wDAAa;AACnB,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kEAAU;AACZ;AACA,EAAE,uEAAqB;AACvB;AACA;AACA,EAAE,+EAAmB;AACrB,EAAE,oEAAiB;AACnB,EAAE,8DAAY;AACd,EAAE,wEAAY;AACd;AACA,EAAE,0EAAuB;AACzB;AACA;AACA,mBAAmB,+DAAoB,CAAC,mDAAW;AACnD,CAAC;AACD;AACA;AACA,EAAE,6DAAW;AACb,CAAC;;;;;;;;;;;;;;;;;;ACldsI;AAC9F;AACO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAmB;AACxC;AACA;AACA,kBAAkB,mBAAmB;AACrC,mBAAmB,qEAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA,IAAI;AACJ,IAAI,+DAAa;AACjB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAQ;AAChC;AACA,MAAM,oEAAkB;AACxB;AACA,8DAA8D,yDAAS;AACvE,IAAI,2BAA2B,kDAAQ;AACvC;AACA;AACA;AACA;AACA,IAAI,oEAAkB;AACtB;AACA,IAAI,2BAA2B,kDAAQ;AACvC;AACA;AACA,sBAAsB,uEAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAmB;AACtC,qCAAqC,WAAW,IAAI,WAAW,IAAI,WAAW,QAAQ;AACtF,qCAAqC,WAAW,IAAI,WAAW,IAAI,WAAW,UAAU;AACxF;AACA;AACA,4BAA4B,WAAW,IAAI,WAAW,IAAI,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChNqD;AACrD;AACA;AACO;AACP;AACA;AACA;AACA,qBAAqB;AACrB,+DAA+D;AAC/D,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,uDAAuD;AACvD,4BAA4B;AAC5B;AACA;AACA;AACA,OAAO,kEAAgB;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS,kEAAgB;AACzB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACO;AACP;AACA;AACA;AACA,yBAAyB;AACzB,mEAAmE;AACnE,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/CmB;AAC0C;AACb;AACyD;AACE;AACpD;AAW/B;AAC2C;AAC0C;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,qDAAe;AACrE,qDAAqD,qDAAe;AACpE;AACA,0CAA0C,mEAAoB,CAAC,4CAAM,EAAE,oDAAc;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY,WAAW,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qDAAe;AACpD,oCAAoC,qDAAe;AACnD;AACA;AACA,mBAAmB,mEAAoB,CAAC,4CAAM,EAAE,oDAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,4CAAM;AAC3D;AACA,mDAAmD,yDAAS;AAC5D;AACA;AACA;AACA;AACA,qBAAqB,gDAAM,8CAA8C,oDAAU;AACnF,IAAI,iDAAO;AACX;AACA,QAAQ,0EAAkB,CAAC,4CAAM;AACjC,MAAM,8DAAgB;AACtB,MAAM,+DAAiB;AACvB;AACA;AACA,MAAM,0DAAW,CAAC,4CAAM;AACxB,qBAAqB,mDAAW;AAChC;AACA;AACA;AACA,UAAU,2EAAmC,WAAW,iDAAa;AACrE,UAAU,2EAAmC,WAAW,iDAAa;AACrE;AACA;AACA;AACA;AACA,sBAAsB,0DAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,gEAAiB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAS;AAChC,YAAY,gEAAiB;AAC7B,YAAY;AACZ,YAAY,gEAAiB;AAC7B,YAAY;AACZ,YAAY,gEAAiB;AAC7B;AACA;AACA,QAAQ;AACR;AACA,UAAU,gEAAiB;AAC3B;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ,gEAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAAkB,CAAC,4CAAM;AACjC,MAAM,8DAAgB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAqB;AACjD,wBAAwB,iDAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,oDAAc;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAqB;AACjC;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA,YAAY,oEAAqB;AACjC;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0DAAW,CAAC,4CAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8DAAmB;AACvD;AACA;AACA;AACA,0BAA0B,+DAAoB;AAC9C,sBAAsB,iDAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0DAAe;AACzD;AACA;AACA;AACA;AACA,sBAAsB,oDAAS;AAC/B;AACA;AACA,sBAAsB,oDAAS;AAC/B;AACA;AACA,sBAAsB,oDAAS;AAC/B;AACA;AACA,sBAAsB,oDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,8DAAgB;AACtB;AACA;AACA;AACA,MAAM,kEAAoB;AAC1B;AACA,6BAA6B,4CAAM;AACnC;AACA,uBAAuB,+DAAiB;AACxC,uBAAuB,+DAAiB;AACxC,uBAAuB,+DAAiB;AACxC;AACA;AACA;AACA;AACA,+BAA+B,qDAAe;AAC9C;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA;AACA,+BAA+B,qDAAe;AAC9C;AACA,qCAAqC,qDAAe;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAS;AAC/B;AACA,MAAM,uBAAuB,oDAAS;AACtC;AACA,MAAM,uBAAuB,oDAAS;AACtC;AACA,MAAM,uBAAuB,oDAAS;AACtC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,0BAA0B,mDAAS;AACnC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAS;AACrC;AACA;AACA,4BAA4B,oDAAS;AACrC;AACA;AACA,4BAA4B,oDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,QAAQ;AACR;AACA,8DAA8D;AAC9D;AACA,oBAAoB,kDAAY;AAChC,oBAAoB,kDAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mDAAS;AACpB;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAM;AAChC;AACA;AACA;AACA;AACA,4BAA4B,mDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gDAAM;AACZ,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAgB;AACpB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kDAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0EAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qDAAe;AACzD,0CAA0C,qDAAe;AACzD,IAAI,gDAAM;AACV;AACA;AACA;AACA,mBAAmB,4CAAM,OAAO,4CAAM;AACtC,MAAM,sDAAY,CAAC,+CAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,0DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8DAAmB;AAC7B;AACA;AACA;AACA,IAAI,kDAAY;AAChB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAY,KAAK,0CAAI,EAAE,4CAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN,+BAA+B,oDAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qDAAe,sCAAsC,qDAAe;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4CAAM,KAAK,kDAAY,KAAK,0CAAI;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4CAAM,KAAK,kDAAY,KAAK,0CAAI;AAC5D;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACv4CgE;AACuB;AACvC;AACsE;AAC1E;AAC5C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,iBAAiB;AACjB;AACA,gBAAgB;AAChB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA;AACA,oBAAoB,gFAAuB,CAAC,oDAAc;AAC1D,aAAa,yEAAgB,CAAC,iDAAO;AACrC,UAAU,yDAAa,CAAC,0CAAI;AAC5B,WAAW,uEAAc,CAAC,2CAAK;AAC/B,aAAa,yEAAgB,CAAC,iDAAO;AACrC;AACA,YAAY,wEAAe,CAAC,gDAAM;AAClC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA,oBAAoB,gFAAuB,CAAC,oDAAc;AAC1D,aAAa,yEAAgB,CAAC,iDAAO;AACrC,UAAU,yDAAa,CAAC,0CAAI;AAC5B,WAAW,uEAAc,CAAC,2CAAK;AAC/B,YAAY,wEAAe,CAAC,gDAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA,UAAU,yDAAa,CAAC,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA,oBAAoB,gFAAuB,CAAC,oDAAc;AAC1D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA,WAAW,uEAAc,CAAC,2CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA,aAAa,yEAAgB,CAAC,iDAAO;AACrC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA,YAAY,wEAAe,CAAC,gDAAM;AAClC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA,UAAU,yDAAa,CAAC,0CAAI;AAC5B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,EAAE,+DAAW;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,GAAG;AACH;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,0EAAkB,CAAC,4CAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,+DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM,+DAAW,IAAI,+DAAW;AAChC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrWkF;AACrB;AACN;AACa;AACqB;AACI;AAC7F;AACO;AACP,uBAAuB,0CAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAiB,qBAAqB,2CAAK;AAC3D;AACA;AACA;AACA,4CAA4C,2CAAK;AACjD;AACA,QAAQ,0EAAkB,CAAC,4CAAM;AACjC,MAAM,6DAAe;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kDAAQ;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAM,uFAAuF,oDAAU;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kDAAQ;AACV;AACA;AACA;AACA;AACA,qBAAqB,gDAAM,uFAAuF,oDAAU;AAC5H,IAAI,iDAAO;AACX;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iEAAkB,oBAAoB,sBAAsB;AAChE,IAAI,oEAAgB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,oBAAoB,iDAAO;AAC3B;AACA;AACA;AACA,IAAI,mEAAoB,CAAC,4CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,oDAAc;AAChB,MAAM,0EAAkB,CAAC,4CAAM;AAC/B,IAAI,gEAAkB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iEAAkB,oBAAoB,4CAA4C;AACtF,IAAI,oEAAgB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UC/KA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack:///./backgroundDrawing.js","webpack:///./canvasDrawingFunctions.js","webpack:///./collisionLogic.js","webpack:///./connectionHandlers.js","webpack:///./db.js","webpack:///./drawGameUI.js","webpack:///./drawShip.js","webpack:///./drawingUtils.js","webpack:///./entities.js","webpack:///./entitySerialisation.js","webpack:///./forceDrawing.js","webpack:///./gameDrawing.js","webpack:///./gameLogic.js","webpack:///./gameUtils.js","webpack:///./generateEntities.js","webpack:///./handleData.js","webpack:///./inputHandlers.js","webpack:///./login.js","webpack:///./main.js","webpack:///./mineDrawing.js","webpack:///./miniMapDrawing.js","webpack:///./player.js","webpack:///./sendData.js","webpack:///./trailShapes.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/before-startup","webpack:///webpack/startup","webpack:///webpack/after-startup"],"sourcesContent":["// Export a Basic function that takes the canvas context as an argument as well as camera position\r\nfunction drawBasicBackground(ctx, camX, camY, canvas) {\r\n  ctx.fillStyle = \"#999\";\r\n  ctx.fillRect(camX, camY, canvas.width, canvas.height);\r\n\r\n  const gridSize = 100; // change as needed\r\n  ctx.strokeStyle = \"#555\";\r\n  ctx.lineWidth = 0.5;\r\n\r\n  // horizontal lines\r\n  for (let i = camY - (camY % gridSize); i < camY + canvas.height; i += gridSize) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(0, i - camY);\r\n    ctx.lineTo(canvas.width, i - camY);\r\n    ctx.stroke();\r\n  }\r\n\r\n  // vertical lines\r\n  for (let i = camX - (camX % gridSize); i < camX + canvas.width; i += gridSize) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(i - camX, 0);\r\n    ctx.lineTo(i - camX, canvas.height);\r\n    ctx.stroke();\r\n  }\r\n}\r\n\r\nexport function drawBackground(ctx, camX, camY, canvas, backLayer, midBackLayer, middleLayer, midFrontLayer, frontLayer) {\r\n  // Define scroll speeds for each layer\r\n  let backScrollSpeedX = -0.06; // Back layer scrolls slowest\r\n  let midBackScrollSpeedX = -0.12; // Mid-back layer scrolls slower\r\n  let middleScrollSpeedX = -0.18; // Middle layer scrolls at medium speed\r\n  let midFrontScrollSpeedX = -0.34; // Mid-front layer scrolls faster\r\n  let frontScrollSpeedX = -0.51; // Front layer scrolls fastest\r\n\r\n  // Define vertical scroll speeds for each layer\r\n  let backScrollSpeedY = -0.06; // Back layer scrolls slowest\r\n  let midBackScrollSpeedY = -0.12; // Mid-back layer scrolls slower\r\n  let middleScrollSpeedY = -0.18; // Middle layer scrolls at medium speed\r\n  let midFrontScrollSpeedY = -0.34; // Mid-front layer scrolls faster\r\n  let frontScrollSpeedY = -0.51; // Front layer scrolls fastest\r\n\r\n  let scaleX = canvas.width / backLayer.width;\r\n  let scaleY = canvas.height / backLayer.height;\r\n\r\n  // Use the larger scale factor\r\n  let scale = Math.max(scaleX, scaleY);\r\n\r\n  // Calculate the new width and height\r\n  let newWidth = backLayer.width * scale;\r\n  let newHeight = backLayer.height * scale;\r\n\r\n  // Calculate new positions for each layer\r\n  let backX = (camX * backScrollSpeedX) % canvas.width;\r\n  let midBackX = (camX * midBackScrollSpeedX) % canvas.width;\r\n  let middleX = (camX * middleScrollSpeedX) % canvas.width;\r\n  // let midFrontX = camX * midFrontScrollSpeedX % canvas.width;\r\n  // let frontX = camX * frontScrollSpeedX % canvas.width;\r\n  let midFrontX = camX * midFrontScrollSpeedX;\r\n  let frontX = camX * frontScrollSpeedX;\r\n\r\n  // Calculate new vertical positions for each layer\r\n  let backY = (camY * backScrollSpeedY) % canvas.height;\r\n  let midBackY = (camY * midBackScrollSpeedY) % canvas.height;\r\n  let middleY = (camY * middleScrollSpeedY) % canvas.height;\r\n  // let midFrontY = camY * midFrontScrollSpeedY % canvas.height;\r\n  let midFrontY = camY * midFrontScrollSpeedY;\r\n  // let frontY = camY * frontScrollSpeedY % canvas.height;\r\n  let frontY = camY * frontScrollSpeedY;\r\n\r\n  // Draw each layer at its new position\r\n  ctx.drawImage(backLayer, backX, backY, newWidth, newHeight);\r\n\r\n  //ctx.drawImage(backLayer, backX - newWidth, backY, newWidth, newHeight);\r\n\r\n  //this is an image to the right of the main background to cover the righthand edge ( if aspect ratio of background doesn't match aspect ratio of the canvas causing this to be needed)\r\n  ctx.drawImage(backLayer, newWidth + backX - 1, backY, newWidth, newHeight);\r\n\r\n  //these are an images below the main background to cover the bottom edge offset because they don't match up top to bottom ( if aspect ratio of background doesn't match aspect ratio of the canvas causing this to be needed)\r\n  // ctx.drawImage(backLayer, newWidth + backX - 1, backY + newHeight - 1, newWidth, newHeight);\r\n  // Calculate the aspect ratio difference\r\n  let backAspectRatio = 272 / 160;\r\n  let canvasAspectRatio = canvas.width / canvas.height;\r\n  const aspectRatioDiff = backAspectRatio - canvasAspectRatio;\r\n\r\n  // Calculate offsets based on the aspect ratio difference and window dimensions\r\n  //sometimes 890 seems to be good sometime 620 (regardless of window resize and refreshes)\r\n  // let xOffset = 890;\r\n  let xOffset = 620;\r\n  let yOffset = 12.5;\r\n  //xOffset += (Math.abs(aspectRatioDiff) * window.innerHeight) / 2;\r\n  if (aspectRatioDiff > 0) {\r\n    // If background is taller, adjust yOffset\r\n    // yOffset += (aspectRatioDiff * window.innerWidth) / 2;\r\n  } else if (aspectRatioDiff < 0) {\r\n    // If background is wider, adjust xOffset\r\n    //xOffset += (Math.abs(aspectRatioDiff) * window.innerHeight) / 2;\r\n  }\r\n  ctx.drawImage(backLayer, backX + xOffset - newWidth + 1, backY + newHeight - yOffset, newWidth, newHeight);\r\n  ctx.drawImage(backLayer, backX + xOffset, backY + newHeight - yOffset, newWidth, newHeight);\r\n\r\n  //this is an image below and to the right of the main background to cover the bottom edge  ( if aspect ratio of background doesn't match aspect ratio of the canvas causing this to be needed)\r\n\r\n  //we don't need these because the aspect ratio of current background means it will be the width that will wrap\r\n  // ctx.drawImage(backLayer, backX, backY - newHeight, newWidth, newHeight);\r\n  // ctx.drawImage(backLayer, backX - newWidth, backY - newHeight, newWidth, newHeight);\r\n\r\n  ctx.drawImage(midBackLayer, midBackX, midBackY, newWidth, newHeight);\r\n  // ctx.drawImage(midBackLayer, midBackX - newWidth, midBackY, newWidth, newHeight);\r\n  // ctx.drawImage(midBackLayer, midBackX, midBackY - newHeight, newWidth, newHeight);\r\n  // ctx.drawImage(midBackLayer, midBackX - newWidth, midBackY - newHeight, newWidth, newHeight);\r\n\r\n  ctx.drawImage(middleLayer, middleX, middleY, newWidth, newHeight);\r\n  // ctx.drawImage(middleLayer, middleX - newWidth, middleY, newWidth, newHeight);\r\n  // ctx.drawImage(middleLayer, middleX, middleY - newHeight, newWidth, newHeight);\r\n  // ctx.drawImage(middleLayer, middleX - newWidth, middleY - newHeight, newWidth, newHeight);\r\n\r\n  let frontMidOffsetX = 800; // Adjust as needed\r\n  let frontMidOffsetY = 650; // Adjust as needed\r\n  ctx.drawImage(midFrontLayer, midFrontX + frontMidOffsetX, midFrontY + frontMidOffsetY, midFrontLayer.width * scale, midFrontLayer.height * scale);\r\n  // ctx.drawImage(midFrontLayer, midFrontX - newWidth + frontMidOffsetX, midFrontY + frontMidOffsetY, midFrontLayer.width * scale, midFrontLayer.height * scale);\r\n  // ctx.drawImage(midFrontLayer, midFrontX + frontMidOffsetX, midFrontY - newHeight + frontMidOffsetY, midFrontLayer.width * scale, midFrontLayer.height * scale);\r\n  // ctx.drawImage(midFrontLayer, midFrontX - newWidth + frontMidOffsetX, midFrontY - newHeight + frontMidOffsetY, midFrontLayer.width * scale, midFrontLayer.height * scale);\r\n\r\n  let frontOffsetX = 700; // Adjust as needed\r\n  let frontOffsetY = 250; // Adjust as needed\r\n  ctx.drawImage(frontLayer, frontX + frontOffsetX, frontY + frontOffsetY, frontLayer.width * scale, frontLayer.height * scale);\r\n\r\n  //draw a second smaller planet\r\n  frontOffsetX = 1500; // Adjust as needed\r\n  frontOffsetY = 1050; // Adjust as needed\r\n  ctx.drawImage(frontLayer, frontX + frontOffsetX, frontY + frontOffsetY, frontLayer.width * scale * 0.6, frontLayer.height * scale * 0.6);\r\n}\r\n\r\nexport function drawWorldBounds(ctx, camX, camY, worldWidth, worldHeight) {\r\n  // Create gradient\r\n  let gradient = ctx.createLinearGradient(0, 0, worldWidth, worldHeight);\r\n  gradient.addColorStop(\"0\", \"magenta\");\r\n  gradient.addColorStop(\"0.5\", \"blue\");\r\n  gradient.addColorStop(\"1.0\", \"red\");\r\n\r\n  // Draw border\r\n  ctx.lineWidth = 20;\r\n  ctx.strokeStyle = gradient;\r\n  ctx.strokeRect(-camX, -camY, worldWidth, worldHeight);\r\n}\r\n","import {\r\n  getTopScores,\r\n  incrementFirebaseGivenPropertyValue,\r\n  readUserDataFromFirestore,\r\n  getFirebaseProperty,\r\n  DbPropertyKey,\r\n  DbDocumentKey,\r\n  getFirebase,\r\n  allTimeKills,\r\n  allTimePoints,\r\n} from \"./db.js\";\r\nimport { drawRoundedRectangle, loreTablet } from \"./drawingUtils.js\";\r\nimport { drawFilledGauge } from \"./drawGameUI.js\";\r\nimport { achievementsTitleText } from \"./login.js\";\r\n\r\nimport {\r\n  pilots,\r\n  getLevel,\r\n  getLevelXP,\r\n  getXp,\r\n  getNextLevelXP,\r\n  getXpToNextLevel,\r\n  levelAnimationFrame,\r\n  achievementsTitle,\r\n  PilotName,\r\n} from \"./gameLogic.js\";\r\n\r\nlet cursorBlink = true;\r\nlet cursorBlinkInterval = setInterval(() => (cursorBlink = !cursorBlink), 450);\r\nvar topDailyScoresString = \"\";\r\nexport let playButtonX = 0;\r\nexport let playButtonY = 0;\r\nexport let playButtonWidth = 0;\r\nexport let playButtonHeight = 0;\r\n\r\nexport let menuButtonX = 0;\r\nexport let menuButtonY = 0;\r\nexport let menuButtonWidth = 0;\r\nexport let menuButtonHeight = 0;\r\n\r\n//should probably refactor this so logic lives elsewhere\r\nexport function updateTopScoresInfo() {\r\n  var date = new Date();\r\n  var dateString = date.getFullYear() + \"-\" + (date.getMonth() + 1) + \"-\" + date.getDate();\r\n\r\n  getTopScores(\"daily-\" + dateString, 10)\r\n    .then((scores) => {\r\n      topDailyScoresString = scores.join(\"; \");\r\n    })\r\n    .catch((error) => {\r\n      console.error(\"Error getting scores: \", error);\r\n    });\r\n}\r\n\r\nexport function drawGameOverMessage(ctx, canvas, message) {\r\n  ctx.font = \"70px Arial\";\r\n  ctx.fillStyle = \"white\";\r\n  ctx.textAlign = \"center\";\r\n  // Check if the message contains a newline character\r\n  if (message.includes(\"\\n\")) {\r\n    const messageParts = message.split(\"\\n\");\r\n    const lineHeight = 90; // Adjust this value as needed for spacing\r\n\r\n    // Calculate the position for the first part of the message\r\n    const firstPartY = canvas.height / 2 - (lineHeight * messageParts.length) / 2;\r\n\r\n    // Draw each part of the message\r\n    messageParts.forEach((part, index) => {\r\n      const y = firstPartY + lineHeight * index;\r\n      ctx.fillText(part, canvas.width / 2, y);\r\n    });\r\n  } else {\r\n    // If there is no newline character, draw the message as-is\r\n    ctx.fillText(message, canvas.width / 2, canvas.height / 2);\r\n  }\r\n\r\n  ctx.font = \"20px Arial\";\r\n  ctx.fillStyle = \"white\";\r\n  ctx.textAlign = \"center\";\r\n  //ctx.fillText(\"press enter to play again\", canvas.width / 2, canvas.height / 2 + 40);\r\n\r\n  ctx.font = \"20px Arial\";\r\n  ctx.fillStyle = \"white\";\r\n  ctx.textAlign = \"center\";\r\n  // ctx.fillText(\"press r to return to main menu\", canvas.width / 2, canvas.height / 2 + 40);\r\n\r\n  let buttonWidth = 200;\r\n  let buttonHeight = 40;\r\n  let buttonX = canvas.width / 2 - buttonWidth / 2;\r\n  let buttonY = canvas.height / 2 + 80;\r\n  let gap = 30;\r\n  let radius = 10; // Radius for rounded corners\r\n  drawButton(ctx, buttonX, buttonY, buttonWidth, buttonHeight, radius, \"Play\");\r\n  playButtonX = buttonX;\r\n  playButtonY = buttonY;\r\n  playButtonWidth = buttonWidth;\r\n  playButtonHeight = buttonHeight;\r\n\r\n  buttonY = buttonY + buttonHeight + gap;\r\n  drawButton(ctx, buttonX, buttonY, buttonWidth, buttonHeight, radius, \"Menu\", \"blue\", \"darkblue\");\r\n  menuButtonX = buttonX;\r\n  menuButtonY = buttonY;\r\n  menuButtonWidth = buttonWidth;\r\n  menuButtonHeight = buttonHeight;\r\n}\r\n\r\nlet loreIndex = 0;\r\nlet lineCount = 0;\r\nlet maxCharsPerLine = 20; // Adjust this value based on the width of your tablet\r\n\r\nfunction drawBorder(ctx, x, y, width, height) {\r\n  // Create gradient\r\n  let gradient = ctx.createLinearGradient(0, 0, ctx.canvas.width, 0);\r\n  gradient.addColorStop(\"0\", \"magenta\");\r\n  gradient.addColorStop(\"0.5\", \"blue\");\r\n  gradient.addColorStop(\"1.0\", \"red\");\r\n\r\n  // Draw border\r\n  ctx.lineWidth = 10;\r\n  ctx.strokeStyle = gradient;\r\n  ctx.strokeRect(x, y, width, height);\r\n}\r\n\r\nfunction drawBoxBackground(ctx, x, y, width, height) {\r\n  // Create a gradient for the box background\r\n  const backGradient = ctx.createLinearGradient(x, y, x + width, y + height);\r\n  backGradient.addColorStop(0, \"rgba(0, 0, 0, 0.2)\"); // Transparent black\r\n  backGradient.addColorStop(1, \"rgba(0, 0, 0, 0.3)\"); // Semi-transparent black\r\n\r\n  // Draw the box background with gradient\r\n  ctx.fillStyle = backGradient;\r\n  ctx.fillRect(x, y, width, height);\r\n}\r\n\r\nfunction drawText(ctx, text, x, y, font, color, textAlign) {\r\n  ctx.font = font;\r\n  ctx.fillStyle = color;\r\n  if (textAlign) {\r\n    ctx.textAlign = textAlign;\r\n  }\r\n  ctx.fillText(text, x, y);\r\n}\r\n\r\nexport function drawDailyScores(ctx) {\r\n  const bestScoresXPos = 70;\r\n  const bestScoresYPos = 359;\r\n  const boxWidth = 360;\r\n  const boxHeight = 320;\r\n  const bestScoreCenterX = bestScoresXPos + boxWidth / 2;\r\n  let currentYpos = bestScoresYPos + 30;\r\n\r\n  drawBorder(ctx, bestScoresXPos, bestScoresYPos, boxWidth, boxHeight);\r\n  drawBoxBackground(ctx, bestScoresXPos, bestScoresYPos, boxWidth, boxHeight);\r\n  ctx.textAlign = \"center\";\r\n  // Draw title\r\n  drawText(ctx, \"Best Scores Today!\", bestScoreCenterX, currentYpos, \"20px Arial\", \"white\");\r\n\r\n  currentYpos += 30;\r\n  // Draw table headers\r\n  drawText(ctx, \"Rank\", bestScoreCenterX - 120, currentYpos, \"16px Arial\", \"white\");\r\n  drawText(ctx, \"Score\", bestScoreCenterX - 70, currentYpos, \"16px Arial\", \"white\");\r\n  drawText(ctx, \"Player\", bestScoreCenterX + 50, currentYpos, \"16px Arial\", \"white\");\r\n\r\n  let gap = 5;\r\n  const textHeight = 18;\r\n  if (topDailyScoresString != \"\") {\r\n    var scores = topDailyScoresString.split(\"; \");\r\n    for (var i = 0; i < scores.length; i++) {\r\n      let scoreData = scores[i].split(\", \");\r\n      currentYpos += gap + textHeight;\r\n      drawText(ctx, (i + 1).toString(), bestScoreCenterX - 120, currentYpos, \"14px Arial\", \"white\");\r\n      drawText(ctx, scoreData[0], bestScoreCenterX - 70, currentYpos, \"14px Arial\", \"white\");\r\n      drawText(ctx, scoreData[1], bestScoreCenterX + 50, currentYpos, \"14px Arial\", \"white\");\r\n    }\r\n  }\r\n}\r\n\r\nexport function drawAchievements(ctx) {\r\n  const boxWidth = 360;\r\n  const boxHeight = 320;\r\n  const achievementsAreaXPos = ctx.canvas.width - boxWidth - 70;\r\n  const achievementsAreaYPos = 359;\r\n  const achievementsAreaCenter = achievementsAreaXPos + boxWidth / 2;\r\n  let currentYPos = achievementsAreaYPos + 30;\r\n\r\n  drawBorder(ctx, achievementsAreaXPos, achievementsAreaYPos, boxWidth, boxHeight);\r\n  drawBoxBackground(ctx, achievementsAreaXPos, achievementsAreaYPos, boxWidth, boxHeight);\r\n  ctx.textAlign = \"center\";\r\n  if (achievementsTitle != achievementsTitleText.YOUR_ACHIEVEMENTS) {\r\n    drawText(ctx, achievementsTitle, achievementsAreaCenter, currentYPos + 100, \"20px Arial\", \"white\", ctx.textAlign);\r\n    return;\r\n  }\r\n  drawText(ctx, achievementsTitle, achievementsAreaCenter, currentYPos, \"20px Arial\", \"white\", ctx.textAlign);\r\n  currentYPos += 30;\r\n  let xp = getXp();\r\n  let level = getLevel(xp);\r\n  let remainingNeededNextLevelXP = getXpToNextLevel(xp);\r\n  let totalNeededNextLevelXP = getNextLevelXP(xp);\r\n\r\n  ctx.textAlign = \"left\";\r\n  drawText(ctx, \"Level: \" + level, achievementsAreaXPos + 20, currentYPos, \"26px Arial\", \"white\", ctx.textAlign);\r\n\r\n  const gaugeWidth = 150;\r\n  const gaugeHeight = 30;\r\n  const max = totalNeededNextLevelXP;\r\n  const percentOfFilledAnimatedTo = Math.min(levelAnimationFrame / 60, 1);\r\n  const filled = (totalNeededNextLevelXP - remainingNeededNextLevelXP) * percentOfFilledAnimatedTo;\r\n\r\n  currentYPos += 30;\r\n  drawText(ctx, \"Kills: \" + allTimeKills, achievementsAreaXPos + 20, currentYPos, \"26px Arial\", \"white\", ctx.textAlign);\r\n  currentYPos += 30;\r\n  drawText(ctx, \"Points: \" + allTimePoints, achievementsAreaXPos + 20, currentYPos, \"26px Arial\", \"white\", ctx.textAlign);\r\n  currentYPos += 40;\r\n\r\n  drawFilledGauge(ctx, achievementsAreaCenter, currentYPos + gaugeHeight / 2, gaugeWidth, gaugeHeight, 3, filled, max, \"blue\");\r\n\r\n  currentYPos += 35;\r\n  drawText(ctx, remainingNeededNextLevelXP + \" XP to next level\", achievementsAreaXPos + 20, currentYPos, \"26px Arial\", \"white\", ctx.textAlign);\r\n}\r\n\r\nexport function drawPreGameOverlay(canvas, ctx) {\r\n  drawDailyScores(ctx);\r\n  drawAchievements(ctx);\r\n\r\n  // Draw title for pilot selection\r\n  drawText(ctx, \"Select Your Pilot\", canvas.width / 2, 50, \"30px Arial\", \"white\", \"center\");\r\n\r\n  drawBoxBackground(ctx, loreTablet.x, loreTablet.y, loreTablet.width, loreTablet.height);\r\n\r\n  ctx.strokeStyle = \"white\";\r\n  ctx.strokeRect(loreTablet.x, loreTablet.y, loreTablet.width, loreTablet.height);\r\n\r\n  for (let i = 0; i < pilots.length; i++) {\r\n    let pilot = pilots[i];\r\n    const carrotCanvas = document.getElementById(pilot.src);\r\n    drawCarrot(ctx, carrotCanvas, pilot.x, pilot.y);\r\n\r\n    if (pilot.selected) {\r\n      ctx.lineWidth = 7;\r\n      ctx.strokeStyle = \"yellow\";\r\n      ctx.strokeRect(pilot.x, pilot.y, pilot.width, pilot.height);\r\n    }\r\n  }\r\n\r\n  if (pilots.every((pilot) => !pilot.selected)) {\r\n    loreIndex = 0;\r\n    lineCount = 0;\r\n  }\r\n\r\n  let x = loreTablet.x + 60;\r\n  let y = loreTablet.y + 55;\r\n\r\n  for (let i = 0; i < pilots.length; i++) {\r\n    let pilot = pilots[i];\r\n    if (pilot.selected) {\r\n      renderInfoText(ctx, pilot.lore, x, y, 350, pilot.pilotAnimationFrame);\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nexport function setupCarrots() {\r\n  const carrot1Canvas = document.getElementById(\"carrot1Canvas\");\r\n  carrot1Canvas.style.display = \"none\";\r\n  const carrot1Ctx = carrot1Canvas.getContext(\"2d\");\r\n  setupCarrot1(carrot1Ctx);\r\n  const carrot2Canvas = document.getElementById(\"carrot2Canvas\");\r\n  carrot2Canvas.style.display = \"none\";\r\n  const carrot2Ctx = carrot2Canvas.getContext(\"2d\");\r\n  setupCarrot2(carrot2Ctx);\r\n  const carrot3Canvas = document.getElementById(\"carrot3Canvas\");\r\n  carrot3Canvas.style.display = \"none\";\r\n  const carrot3Ctx = carrot3Canvas.getContext(\"2d\");\r\n  setupCarrot3(carrot3Ctx);\r\n  const carrot4Canvas = document.getElementById(\"carrot4Canvas\");\r\n  carrot4Canvas.style.display = \"none\";\r\n  const carrot4Ctx = carrot4Canvas.getContext(\"2d\");\r\n  setupCarrot4(carrot4Ctx);\r\n}\r\nfunction drawCarrots(ctx, mainX, mainY) {\r\n  const carrot1Canvas = document.getElementById(\"carrot1Canvas\");\r\n  drawCarrot(ctx, carrot1Canvas, mainX, mainY);\r\n  const carrot2Canvas = document.getElementById(\"carrot2Canvas\");\r\n  drawCarrot(ctx, carrot2Canvas, mainX + 120, mainY);\r\n  const carrot3Canvas = document.getElementById(\"carrot3Canvas\");\r\n  drawCarrot(ctx, carrot3Canvas, mainX + 240, mainY);\r\n  const carrot4Canvas = document.getElementById(\"carrot4Canvas\");\r\n  drawCarrot(ctx, carrot4Canvas, mainX + 360, mainY);\r\n}\r\nfunction drawCarrot(mainCtx, carrotCanvas, mainX, mainY) {\r\n  mainCtx.drawImage(carrotCanvas, mainX, mainY);\r\n}\r\n\r\nfunction drawBackground(ctx, left, top, width, height, color) {\r\n  ctx.fillStyle = color;\r\n  ctx.fillRect(left, top, width, height);\r\n}\r\n\r\nfunction drawCarrotBody(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 50, top + 120);\r\n  ctx.bezierCurveTo(left + 80, top + 10, left + 80, top + 10, left + 50, top + 10);\r\n  ctx.bezierCurveTo(left + 20, top + 10, left + 20, top + 10, left + 50, top + 120);\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n\r\n  // Add 3D rounded effect curved lines\r\n  ctx.strokeStyle = \"white\"; // Color of the curved lines\r\n  ctx.lineWidth = 2; // Adjust the width as needed\r\n  ctx.beginPath();\r\n\r\n  let x = left + 27;\r\n  let y = top + 20;\r\n  ctx.moveTo(x, y);\r\n  ctx.quadraticCurveTo(x + 5, y - 5, x + 10, y - 2);\r\n\r\n  x += 0;\r\n  y += 13;\r\n  ctx.moveTo(x, y);\r\n  ctx.quadraticCurveTo(x + 5, y - 5, x + 10, y - 2);\r\n\r\n  x += 35;\r\n  y += -5;\r\n  ctx.moveTo(x, y);\r\n  ctx.quadraticCurveTo(x + 5, y - 4, x + 10, y + 3);\r\n\r\n  ctx.stroke();\r\n}\r\nfunction drawCarrotTop(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 50, top + 10);\r\n  ctx.lineTo(left + 80, top + 30);\r\n  ctx.lineTo(left + 50, top + 60);\r\n  ctx.closePath();\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawCarrotFace(ctx, left, top, bodyColor) {\r\n  // Draw face\r\n  ctx.beginPath();\r\n  ctx.arc(left + 50, top + 75, 20, 0, Math.PI * 2);\r\n  ctx.fillStyle = bodyColor;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawCarrotEyes(ctx, left, top, eyeColor, pupilColor) {\r\n  ctx.beginPath();\r\n  ctx.ellipse(left + 45, top + 70, 8, 14, 0, 0, Math.PI * 2);\r\n  ctx.ellipse(left + 55, top + 70, 8, 14, 0, 0, Math.PI * 2);\r\n  ctx.fillStyle = eyeColor;\r\n  ctx.fill();\r\n\r\n  // Draw pupils\r\n  ctx.beginPath();\r\n  ctx.arc(left + 45, top + 70, 3, 0, Math.PI * 2);\r\n  ctx.arc(left + 55, top + 70, 3, 0, Math.PI * 2);\r\n  ctx.fillStyle = pupilColor;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawCarrotMouth(ctx, left, top, mouthColor) {\r\n  // Draw mouth\r\n  ctx.beginPath();\r\n  ctx.arc(left + 50, top + 85, 8, 0, Math.PI);\r\n  ctx.lineWidth = 2;\r\n  ctx.strokeStyle = mouthColor;\r\n  ctx.stroke();\r\n}\r\n\r\nfunction drawCarrotLimbs(ctx, left, top, color) {\r\n  drawCarrotArms(ctx, left, top, color);\r\n  // drawCarrotLegs(ctx, left, top, color);\r\n}\r\n\r\nfunction drawOtherCarrotLimbs(ctx, left, top, color) {\r\n  drawCarrotHand(ctx, left, top, color);\r\n}\r\n\r\nfunction drawCarrotLegs(ctx, left, top, color) {\r\n  // Draw legs\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 50, top + 100);\r\n  ctx.lineTo(left + 30, top + 130);\r\n  ctx.moveTo(left + 50, top + 100);\r\n  ctx.lineTo(left + 70, top + 130);\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = 5;\r\n  ctx.stroke();\r\n}\r\n\r\nfunction drawCarrotFoot(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  ctx.arc(left + 50, top + 120, 10, 0, Math.PI * 2);\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n\r\n  // Draw shoe\r\n  ctx.beginPath();\r\n  ctx.rect(left + 40, top + 120, 20, 10);\r\n  ctx.fillStyle = \"black\";\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawShortCarrotArms(ctx, left, top, color) {\r\n  // Draw arms\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 15, top + 70);\r\n  ctx.lineTo(left + 30, top + 80);\r\n  ctx.moveTo(left + 86, top + 70);\r\n  ctx.lineTo(left + 70, top + 80);\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = 5;\r\n  ctx.stroke();\r\n}\r\n\r\nfunction drawCarrotArms(ctx, left, top, color) {\r\n  // Draw arms\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 20, top + 60);\r\n  ctx.lineTo(left + 45, top + 85);\r\n  ctx.moveTo(left + 80, top + 60);\r\n  ctx.lineTo(left + 60, top + 77);\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = 5;\r\n  ctx.stroke();\r\n}\r\n\r\nfunction drawCarrotHand(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 20, top + 70);\r\n  ctx.lineTo(left + 30, top + 80);\r\n  ctx.lineTo(left + 40, top + 70);\r\n  ctx.lineTo(left + 30, top + 60);\r\n  ctx.closePath();\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n\r\n  // Draw carrot\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 40, top + 70);\r\n  ctx.lineTo(left + 60, top + 70);\r\n  ctx.lineTo(left + 50, top + 80);\r\n  ctx.closePath();\r\n  ctx.fillStyle = \"orange\";\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawCarrotArmSign(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 20, top + 70);\r\n  ctx.lineTo(left + 30, top + 80);\r\n  ctx.strokeStyle = color;\r\n  ctx.lineWidth = 5;\r\n  ctx.stroke();\r\n\r\n  // Draw sign\r\n  ctx.beginPath();\r\n  ctx.rect(left + 30, top + 60, 40, 20);\r\n  ctx.fillStyle = \"white\";\r\n  ctx.fill();\r\n\r\n  // Write text on sign\r\n  ctx.font = \"10px Arial\";\r\n  ctx.fillStyle = \"black\";\r\n  ctx.fillText(\"Carrot\", left + 35, top + 75);\r\n}\r\n\r\nfunction drawCarrotGreens(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  ctx.ellipse(left + 50, top + 10, 10, 20, 0, 0, Math.PI * 2);\r\n  ctx.ellipse(left + 50, top + 30, 15, 25, 0, 0, Math.PI * 2);\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawGoofyCarrotEyes(ctx, left, top, eyeColor, pupilColor) {\r\n  // Draw eyes\r\n  ctx.beginPath();\r\n  ctx.ellipse(left + 45, top + 70, 8, 14, Math.PI / 4, 0, Math.PI * 2);\r\n  ctx.ellipse(left + 55, top + 70, 8, 14, Math.PI / 4, 0, Math.PI * 2);\r\n  ctx.fillStyle = eyeColor;\r\n  ctx.fill();\r\n\r\n  // Draw pupils\r\n  ctx.beginPath();\r\n  ctx.arc(left + 45, top + 70, 3, 0, Math.PI * 2);\r\n  ctx.arc(left + 55, top + 70, 3, 0, Math.PI * 2);\r\n  ctx.fillStyle = pupilColor;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawUghCarrotEyes(ctx, left, top, eyeColor, pupilColor) {\r\n  // Draw eyes\r\n  ctx.beginPath();\r\n  ctx.ellipse(left + 45, top + 70, 8, 14, 0, 0, Math.PI);\r\n  ctx.ellipse(left + 55, top + 70, 8, 14, 0, 0, Math.PI);\r\n  ctx.fillStyle = eyeColor;\r\n  ctx.fill();\r\n\r\n  // Draw pupils\r\n  ctx.beginPath();\r\n  ctx.arc(left + 45, top + 70, 3, 0, Math.PI * 2);\r\n  ctx.arc(left + 55, top + 70, 3, 0, Math.PI * 2);\r\n  ctx.fillStyle = pupilColor;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawLookingUpCarrotEyes(ctx, left, top, eyeColor, pupilColor) {\r\n  // Draw eyes\r\n  ctx.beginPath();\r\n  ctx.ellipse(left + 45, top + 70, 8, 14, 0, 0, Math.PI * 2);\r\n  ctx.ellipse(left + 55, top + 70, 8, 14, 0, 0, Math.PI * 2);\r\n  ctx.fillStyle = eyeColor;\r\n  ctx.fill();\r\n\r\n  // Draw pupils\r\n  ctx.beginPath();\r\n  ctx.arc(left + 45, top + 65, 3, 0, Math.PI * 2);\r\n  ctx.arc(left + 55, top + 65, 3, 0, Math.PI * 2);\r\n  ctx.fillStyle = pupilColor;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawLookingDownCarrotEyes(ctx, left, top, eyeColor, pupilColor) {\r\n  // Draw eyes\r\n  ctx.beginPath();\r\n  ctx.ellipse(left + 45, top + 70, 8, 14, 0, 0, Math.PI * 2);\r\n  ctx.ellipse(left + 55, top + 70, 8, 14, 0, 0, Math.PI * 2);\r\n  ctx.fillStyle = eyeColor;\r\n  ctx.fill();\r\n\r\n  // Draw pupils\r\n  ctx.beginPath();\r\n  ctx.arc(left + 45, top + 75, 3, 0, Math.PI * 2);\r\n  ctx.arc(left + 55, top + 75, 3, 0, Math.PI * 2);\r\n  ctx.fillStyle = pupilColor;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawNarrowCarrotEyes(ctx, left, top, eyeColor, pupilColor) {\r\n  // Draw eyes\r\n  ctx.beginPath();\r\n  ctx.ellipse(left + 45, top + 70, 8, 14, 0, 0, Math.PI * 2);\r\n  ctx.ellipse(left + 55, top + 70, 8, 14, 0, 0, Math.PI * 2);\r\n  ctx.fillStyle = eyeColor;\r\n  ctx.fill();\r\n\r\n  // Draw pupils\r\n  ctx.beginPath();\r\n  ctx.arc(left + 45, top + 70, 3, 0, Math.PI * 2);\r\n  ctx.arc(left + 55, top + 70, 3, 0, Math.PI * 2);\r\n  ctx.fillStyle = pupilColor;\r\n  ctx.fill();\r\n\r\n  // Draw eyelids\r\n  ctx.beginPath();\r\n  ctx.ellipse(left + 45, top + 70, 8, 6, 0, 0, Math.PI);\r\n  ctx.ellipse(left + 55, top + 70, 8, 6, 0, 0, Math.PI);\r\n  ctx.fillStyle = eyeColor;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawBleedingCarrotEyes(ctx, left, top, eyeColor, pupilColor) {\r\n  // Draw eyes\r\n  ctx.beginPath();\r\n  ctx.ellipse(left + 45, top + 70, 8, 14, 0, 0, Math.PI * 2);\r\n  ctx.ellipse(left + 55, top + 70, 8, 14, 0, 0, Math.PI * 2);\r\n  ctx.fillStyle = eyeColor;\r\n  ctx.fill();\r\n\r\n  // Draw pupils\r\n  ctx.beginPath();\r\n  ctx.arc(left + 45, top + 70, 3, 0, Math.PI * 2);\r\n  ctx.arc(left + 55, top + 70, 3, 0, Math.PI * 2);\r\n  ctx.fillStyle = pupilColor;\r\n  ctx.fill();\r\n\r\n  // Draw heart symbols\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 45, top + 80);\r\n  ctx.bezierCurveTo(left + 45, top + 80, left + 40, top + 75, left + 45, top + 70);\r\n  ctx.bezierCurveTo(left + 50, top + 75, left + 45, top + 80, left + 45, top + 80);\r\n  ctx.moveTo(left + 55, top + 80);\r\n  ctx.bezierCurveTo(left + 55, top + 80, left + 50, top + 75, left + 55, top + 70);\r\n  ctx.bezierCurveTo(left + 60, top + 75, left + 55, top + 80, left + 55, top + 80);\r\n  ctx.fillStyle = \"red\";\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawScaredCarrotMouth(ctx, left, top, mouthColor) {\r\n  // Draw mouth (scared)\r\n  ctx.beginPath();\r\n  ctx.arc(left + 50, top + 95, 8, 0, Math.PI, true); // Inverted arc for a scared mouth\r\n  ctx.lineWidth = 2;\r\n  ctx.strokeStyle = mouthColor;\r\n  ctx.stroke();\r\n}\r\n\r\nfunction drawGrumpyCarrotMouth(ctx, left, top, mouthColor) {\r\n  // Draw mouth (grumpy)\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 40, top + 90);\r\n  ctx.lineTo(left + 60, top + 90); // Straight line for a grumpy mouth\r\n  ctx.lineWidth = 2;\r\n  ctx.strokeStyle = mouthColor;\r\n  ctx.stroke();\r\n}\r\n\r\nfunction drawSurprisedCarrotMouth(ctx, left, top, mouthColor) {\r\n  // Draw mouth (surprised)\r\n  ctx.beginPath();\r\n  ctx.arc(left + 50, top + 90, 3, 0, Math.PI * 2); // Circle for a surprised mouth\r\n  ctx.lineWidth = 2;\r\n  ctx.strokeStyle = mouthColor;\r\n  ctx.stroke();\r\n}\r\n\r\nfunction drawHappyCarrotMouth(ctx, left, top, mouthColor) {\r\n  // Draw mouth (happy)\r\n  ctx.beginPath();\r\n  ctx.arc(left + 50, top + 85, 8, 0, Math.PI, false); // Smiling arc for a happy mouth\r\n  ctx.lineWidth = 2;\r\n  ctx.strokeStyle = mouthColor;\r\n  ctx.stroke();\r\n}\r\n\r\nfunction drawCurlyCarrotGreens(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  for (let i = 0; i < 10; i++) {\r\n    let x = left + 50 + 10 * Math.cos(i);\r\n    let y = top + 10 * Math.sin(i);\r\n    ctx.arc(x, y, 5, 0, Math.PI * 2, false);\r\n  }\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawPigtailsCarrotGreens(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 30, top + 10);\r\n  ctx.bezierCurveTo(left + 30, top + 30, left + 20, top + 50, left + 30, top + 70);\r\n  ctx.moveTo(left + 70, top + 10);\r\n  ctx.bezierCurveTo(left + 70, top + 30, left + 80, top + 50, left + 70, top + 70);\r\n  ctx.strokeStyle = color;\r\n  ctx.stroke();\r\n}\r\n\r\nfunction drawLongFlowingCarrotGreens(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  top -= 20;\r\n  left += 5;\r\n  for (let i = -20; i <= 20; i += 4) {\r\n    let rand = Math.random() * 10;\r\n    ctx.moveTo(left + 50 + i, top);\r\n    ctx.bezierCurveTo(left + 50 + i, top + 20, left + 30 + i + rand, top + 40 + rand, left + 50 + i, top + 60);\r\n  }\r\n  ctx.strokeStyle = color;\r\n  ctx.stroke();\r\n}\r\n\r\nfunction drawAfroCarrotGreens(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  for (let i = 0; i < 360; i += 10) {\r\n    let x = left + 50 + 30 * Math.cos((i * Math.PI) / 180);\r\n    let y = top + 20 + 30 * Math.sin((i * Math.PI) / 180);\r\n    ctx.lineTo(x, y);\r\n  }\r\n  ctx.closePath();\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawSpikeCarrotGreens(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  for (let i = 0; i < 5; i++) {\r\n    let x = left + 50 + 20 * Math.cos((i * Math.PI) / 2.5);\r\n    let y = top + 20 * Math.sin((i * Math.PI) / 2.5);\r\n    ctx.lineTo(x, y);\r\n  }\r\n  ctx.closePath();\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n}\r\n\r\nfunction setupCarrot1(carrotCtx) {\r\n  let left = 0;\r\n  let top = 0;\r\n\r\n  drawBackground(carrotCtx, left, top, 100, 130, \"lightblue\");\r\n  drawCarrotBody(carrotCtx, left, top, \"orange\");\r\n  drawCarrotEyes(carrotCtx, left, top - 15, \"white\", \"black\");\r\n  drawCarrotMouth(carrotCtx, left, top - 15, \"black\");\r\n\r\n  drawCarrotGreens(carrotCtx, left, top - 20, \"darkgreen\");\r\n  drawCarrotLimbs(carrotCtx, left, top, \"orange\");\r\n}\r\n\r\nfunction setupCarrot2(carrotCtx) {\r\n  let left = 0;\r\n  let top = 0;\r\n\r\n  drawBackground(carrotCtx, left, top, 100, 130, \"lightblue\");\r\n  drawFatCarrotBody(carrotCtx, left, top, \"orange\");\r\n  drawUghCarrotEyes(carrotCtx, left, top, \"white\", \"black\");\r\n  drawScaredCarrotMouth(carrotCtx, left, top, \"black\");\r\n  drawLongFlowingCarrotGreens(carrotCtx, left, top, \"green\");\r\n  drawShortCarrotArms(carrotCtx, left, top, \"orange\");\r\n  drawCarrotLegs(carrotCtx, left, top, \"orange\");\r\n}\r\n\r\nfunction setupCarrot3(carrotCtx) {\r\n  let left = 0;\r\n  let top = 0;\r\n\r\n  drawBackground(carrotCtx, left, top, 100, 130, \"lightblue\");\r\n  drawCarrotLimbs(carrotCtx, left, top, \"orange\");\r\n  drawThinCarrotBody(carrotCtx, left, top, \"orange\");\r\n\r\n  drawNarrowCarrotEyes(carrotCtx, left, top, \"white\", \"black\");\r\n  drawGrumpyCarrotMouth(carrotCtx, left, top, \"black\");\r\n  drawCarrotGreens(carrotCtx, left, top, \"green\");\r\n}\r\n\r\nfunction setupCarrot4(carrotCtx) {\r\n  let left = 0;\r\n  let top = 0;\r\n\r\n  drawBackground(carrotCtx, left, top, 100, 130, \"lightblue\");\r\n  drawCarrotLimbs(carrotCtx, left, top, \"orange\");\r\n  drawCarrotBody(carrotCtx, left, top, \"orange\");\r\n\r\n  drawBleedingCarrotEyes(carrotCtx, left, top, \"white\", \"black\");\r\n  drawSurprisedCarrotMouth(carrotCtx, left, top, \"black\");\r\n}\r\n\r\nfunction drawUprightCarrotGreens(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  ctx.fillRect(left + 45, top - 20, 10, 20);\r\n  ctx.fillRect(left + 55, top - 30, 10, 30);\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawFatCarrotBody(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 50, top + 10);\r\n  ctx.bezierCurveTo(left + 90, top + 10, left + 90, top + 70, left + 50, top + 120); // Wider bezier curves for a fatter body\r\n  ctx.bezierCurveTo(left + 10, top + 70, left + 10, top + 10, left + 50, top + 10);\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawThinCarrotBody(ctx, left, top, color) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(left + 50, top + 10);\r\n  ctx.bezierCurveTo(left + 70, top + 10, left + 70, top + 70, left + 50, top + 120); // Narrower bezier curves for a thinner body\r\n  ctx.bezierCurveTo(left + 30, top + 70, left + 30, top + 10, left + 50, top + 10);\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n}\r\n\r\nfunction renderInfoText(ctx, text, x, y, maxWidth, animationFrame) {\r\n  // Set font and color\r\n  ctx.textAlign = \"start\";\r\n  let sections = text.split(\";\");\r\n  let currentY = y;\r\n\r\n  for (let i = 0; i < sections.length; i++) {\r\n    let section = sections[i].trim();\r\n\r\n    // Determine font size and line height based on section index\r\n    let fontSize;\r\n    let lineHeight;\r\n    if (i === 0) {\r\n      // First section (title) should be the biggest\r\n      fontSize = 50;\r\n      lineHeight = fontSize * 1.1; // Adjust the multiple as needed\r\n    } else if (i === sections.length - 1 || i === sections.length - 2) {\r\n      // Last sections (description) should be the smallest\r\n      fontSize = 20;\r\n      lineHeight = fontSize * 1.1; // Adjust the multiple as needed\r\n    } else {\r\n      // Other sections can have a default size\r\n      fontSize = 33;\r\n      lineHeight = fontSize * 1.2; // Adjust the multiple as needed\r\n    }\r\n\r\n    ctx.font = fontSize + \"px Gothic\";\r\n    ctx.fillStyle = \"coral\";\r\n\r\n    if (i === 1 && section.startsWith(\"Speed:\")) {\r\n      const speedValue = parseInt(section.split(\":\")[1].trim());\r\n      if (!isNaN(speedValue)) {\r\n        currentY = drawSectionGauge(ctx, animationFrame, fontSize, lineHeight, \"Speed:\", speedValue, 5, \"blue\", x, currentY);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if (i === 2 && section.startsWith(\"Invicible Time:\")) {\r\n      const invincibleValue = parseInt(section.split(\":\")[1].trim());\r\n      if (!isNaN(invincibleValue)) {\r\n        currentY = drawSectionGauge(ctx, animationFrame, fontSize, lineHeight, \"Invicible Time:\", invincibleValue, 15, \"green\", x, currentY);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    let words = section.split(\" \");\r\n    let line = \"\";\r\n\r\n    for (let n = 0; n < words.length; n++) {\r\n      let testLine = line + words[n] + \" \";\r\n      let metrics = ctx.measureText(testLine);\r\n      let testWidth = metrics.width;\r\n\r\n      if (testWidth > maxWidth && n > 0) {\r\n        ctx.fillText(line, x, currentY);\r\n        line = words[n] + \" \";\r\n        currentY += lineHeight;\r\n      } else {\r\n        line = testLine;\r\n      }\r\n    }\r\n\r\n    ctx.fillText(line, x, currentY);\r\n    currentY += lineHeight; // Move to the next section\r\n  }\r\n}\r\n\r\nfunction drawSectionGauge(ctx, animationFrame, fontSize, lineHeight, label, value, max, color, x, currentY) {\r\n  const percentOfFilledAnimatedTo = Math.min(animationFrame / 30, 1);\r\n\r\n  ctx.fillText(label, x, currentY);\r\n\r\n  const centerX = x + ctx.measureText(label).width + 50;\r\n  const gaugeWidth = 100;\r\n  const gaugeHeight = fontSize;\r\n  const filled = value * percentOfFilledAnimatedTo;\r\n\r\n  drawFilledGauge(ctx, centerX, currentY + 15, gaugeWidth, gaugeHeight, 3, filled, max, color);\r\n  currentY += lineHeight;\r\n  return currentY;\r\n}\r\n\r\n//wip\r\nfunction animateLoreText(ctx, lore, loreIndex, lineCount) {\r\n  // Set font and color\r\n  ctx.font = \"20px Arial\";\r\n  ctx.fillStyle = \"white\";\r\n  ctx.textAlign = \"start\";\r\n\r\n  // Increment lore index\r\n  while (loreIndex < lore.length - 1) {\r\n    // Calculate line breaks\r\n    if (loreIndex % maxCharsPerLine === 0 && loreIndex !== 0) {\r\n      lineCount++;\r\n    }\r\n\r\n    // Draw text\r\n    ctx.fillText(lore[loreIndex], loreTablet.x + 50 + loreIndex * 10, loreTablet.y + 130 + lineCount * 20);\r\n\r\n    loreIndex++;\r\n  }\r\n}\r\nexport function drawInputField(canvas, ctx, inputText, x, y, width, height, inputTitle) {\r\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n  ctx.textAlign = \"center\";\r\n  ctx.fillStyle = \"black\";\r\n  ctx.strokeStyle = \"black\";\r\n  // ctx.font = \"12px Arial\";\r\n\r\n  if (inputTitle) {\r\n    ctx.fillStyle = \"white\";\r\n    // Draw title\r\n    ctx.fillText(inputTitle, canvas.width / 2, y + 15);\r\n  }\r\n  // Draw input field background\r\n  ctx.fillStyle = \"white\";\r\n  ctx.fillRect(x, y, width, height); // Adjust the width and height as needed\r\n\r\n  ctx.font = \"20px Arial\";\r\n  ctx.fillStyle = \"black\";\r\n  let ogTextAlign = ctx.textAlign;\r\n  ctx.textAlign = \"center\";\r\n  // Calculate the center of the box\r\n  let centerX = x + width / 2;\r\n  let centerY = y + 15;\r\n\r\n  // Calculate the width of the text\r\n  let textWidth = ctx.measureText(inputText).width;\r\n\r\n  //text align center so we can just aim at the middle\r\n  let textStartX = centerX;\r\n  // Draw player's name\r\n  ctx.fillText(inputText, textStartX, centerY);\r\n\r\n  // Draw the cursor just to the right of the text\r\n  if (document.hasFocus()) {\r\n    drawTextCursor(ctx, textStartX + textWidth / 2, centerY - 10);\r\n  }\r\n\r\n  ctx.textAlign = ogTextAlign;\r\n}\r\n\r\nfunction drawCursor(ctx, x, startY, endY) {\r\n  ctx.strokeStyle = \"black\";\r\n  ctx.lineWidth = 2;\r\n  ctx.beginPath();\r\n  ctx.moveTo(x, startY);\r\n  ctx.lineTo(x, endY);\r\n  ctx.stroke();\r\n}\r\n\r\nexport function drawNameEntry(canvas, ctx, name, x, y) {\r\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n  ctx.textAlign = \"center\";\r\n  ctx.fillStyle = \"black\";\r\n  ctx.strokeStyle = \"black\";\r\n  ctx.font = \"12px Arial\";\r\n\r\n  // Draw background\r\n  ctx.fillStyle = \"white\";\r\n  let enterNameText = \"Enter Your Name\";\r\n  ctx.fillText(enterNameText, canvas.width / 2, y + 15);\r\n\r\n  // Draw name entry box\r\n  ctx.strokeStyle = \"white\";\r\n  ctx.strokeRect(x, y, 200, 100);\r\n\r\n  let inputFieldWidth = 180;\r\n\r\n  // Draw player's name using the new drawInputField function\r\n  drawInputField(canvas, ctx, name, x + 10, y + 30, inputFieldWidth, 30);\r\n\r\n  // Draw play button\r\n  let buttonX = x + 50;\r\n  let buttonY = y + 70;\r\n  let buttonWidth = 100;\r\n  let buttonHeight = 20;\r\n  let radius = 10; // Radius for rounded corners\r\n\r\n  drawButton(ctx, buttonX, buttonY, buttonWidth, buttonHeight, radius, \"Play\");\r\n  playButtonX = buttonX;\r\n  playButtonY = buttonY;\r\n  playButtonWidth = buttonWidth;\r\n  playButtonHeight = buttonHeight;\r\n}\r\n\r\nfunction drawButton(ctx, buttonX, buttonY, buttonWidth, buttonHeight, radius, text, color1 = \"green\", color2 = \"darkgreen\") {\r\n  // Create gradient\r\n  let gradient;\r\n  try {\r\n    gradient = ctx.createLinearGradient(buttonX, buttonY, buttonX, buttonY + buttonHeight);\r\n    gradient.addColorStop(0, color1);\r\n    gradient.addColorStop(1, color2);\r\n\r\n    ctx.fillStyle = gradient;\r\n  } catch (Exception) {\r\n    console.log(\"gradient issue\");\r\n  }\r\n\r\n  drawRoundedRectangle(ctx, buttonX, buttonY, buttonWidth, buttonHeight, radius);\r\n\r\n  // Write \"Play\" on the button\r\n  ctx.fillStyle = \"white\";\r\n  ctx.font = \"12px Arial\";\r\n  ctx.textAlign = \"center\";\r\n  ctx.textBaseline = \"middle\";\r\n  ctx.fillText(text, buttonX + buttonWidth / 2, buttonY + buttonHeight / 2);\r\n}\r\n\r\nexport function drawTextCursor(ctx, x, y) {\r\n  if (cursorBlink) {\r\n    ctx.fillStyle = \"black\";\r\n  } else {\r\n    ctx.fillStyle = \"transparent\";\r\n  }\r\n\r\n  if (x && y) {\r\n    ctx.fillRect(x, y, 2, 20);\r\n  }\r\n}\r\n\r\nexport function drawTextCursorFromText(ctx, text) {\r\n  let x = 0;\r\n  let y = 0;\r\n\r\n  drawTextCursor(ctx, x, y);\r\n}\r\n","import { player, bots, otherPlayers, mines } from \"./main.js\";\r\nimport { isPlayerMasterPeer } from \"./connectionHandlers.js\";\r\nimport { sendMinesUpdate, sendPowerUpsUpdate, sendEffectsUpdate } from \"./sendData.js\";\r\nimport { ForceType, effects, Effect, EffectType, MineType } from \"./entities.js\";\r\n\r\n//if mess with these need to change the collision detection - factor these in\r\nexport const shipScale = 2;\r\nexport const mineScale = 0.7;\r\n\r\nexport const HitByType = {\r\n  MINE: \"a mine\",\r\n};\r\n\r\nexport function detectCollisions(playerToCheck, globalPowerUps, bots, otherPlayers, forces) {\r\n  // Detect collisions between the player's ship and the powerups or other ships\r\n  // If a collision is detected, update the game state accordingly\r\n  checkPowerupCollision(playerToCheck, globalPowerUps);\r\n  checkMineCollision(playerToCheck, mines);\r\n  let allPlayers = [...bots, ...otherPlayers, player];\r\n  checkPlayerCollision(playerToCheck, allPlayers);\r\n  checkForcesCollision(playerToCheck, forces);\r\n}\r\n\r\nexport function checkPowerupCollision(playerToCheck, globalPowerUps) {\r\n  for (let i = 0; i < globalPowerUps.length; i++) {\r\n    let dx = playerToCheck.x - globalPowerUps[i].x;\r\n    let dy = playerToCheck.y - globalPowerUps[i].y;\r\n    let distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    if (distance < 10 * shipScale + globalPowerUps[i].radius && globalPowerUps[i].hitFrames == -1) {\r\n      // assuming the radius of ship is 10 - todo update for better hitbox on ship\r\n      if (playerToCheck.ticksSincePowerUpCollection == -1) {\r\n        //may need to make this an array of \"recently collected / iteracted stuff\" to be more robust in the future rather than a simple power up timer\r\n        // playerToCheck.powerUps += globalPowerUps[i].value;\r\n        let scoreToAdd = globalPowerUps[i].value;\r\n\r\n        playerToCheck.gotPowerUp(globalPowerUps[i].isStar, scoreToAdd, i);\r\n        if (isPlayerMasterPeer(player)) {\r\n          sendPowerUpsUpdate(false);\r\n        }\r\n      }\r\n      // sendPowerups(globalPowerUps);\r\n\r\n      //cf test do we need this looks like yes\r\n      //sendGameState(globalPowerUps);\r\n      // break; // exit the loop to avoid possible index errors - does that mean we can only register 1 collection per tick? if so we could simply schedule the removal of collected until after this loop\r\n    }\r\n  }\r\n}\r\n//todo more generic entity based collision function, maybe each entity has its own action upon collision\r\nexport function checkMineCollision(playerToCheck, mines) {\r\n  for (let i = 0; i < mines.length; i++) {\r\n    let mine = mines[i];\r\n\r\n    if (mineCollided(mine, playerToCheck)) {\r\n      // assuming the radius of ship is 10 - todo update for better hitbox on ship\r\n      if (playerToCheck.isVulnerable() && mine.hitFrames == -1 && (mine.playerId == \"\" || mine.playerId != playerToCheck.id)) {\r\n        if (mine.mineType == MineType.REGULAR) {\r\n          playerToCheck.gotHit(HitByType.MINE);\r\n        } else {\r\n          resolveMineHit(playerToCheck, mine, otherPlayers, bots, player);\r\n        }\r\n        mine.hitFrames = 2;\r\n        // mines.splice(i, 1);\r\n      }\r\n      // if (playerToCheck.invincibleTimer > 0 && !playerToCheck.isInSpawnProtectionTime() && mines[i].hitFrames == -1) {\r\n      //if invincible ignore spawn protection\r\n      if (playerToCheck.isInvincible() && mine.hitFrames == -1 && (mine.playerId == \"\" || mine.playerId != playerToCheck.id)) {\r\n        if (playerToCheck.invincibleTimer > 115) {\r\n          if (mine.mineType == MineType.REGULAR) {\r\n            playerToCheck.setInvincibleTimer(playerToCheck.invincibleTimer - 100);\r\n          } else if (mine.mineType == MineType.TRAIL) {\r\n            playerToCheck.setInvincibleTimer(playerToCheck.invincibleTimer - 30);\r\n          } else {\r\n            resolveMineHit(playerToCheck, mine, otherPlayers, bots, player);\r\n          }\r\n        } else {\r\n          //always leave a little bit of time to tick away (but don't increase if time already ticked nearly away)\r\n          playerToCheck.setInvincibleTimer(Math.min(playerToCheck.invincibleTimer, 15));\r\n        }\r\n        mine.hitFrames = 2;\r\n        let effectID = Math.floor(Math.random() * 10000);\r\n\r\n        let effect = new Effect(effectID, mine.x, mine.y, 50, 30, \"OrangeRed\", EffectType.EXPLOSION);\r\n        effects.push(effect);\r\n        if (isPlayerMasterPeer(player)) {\r\n          sendEffectsUpdate(true);\r\n        }\r\n        // mines.splice(i, 1);\r\n      }\r\n      // sendPowerups(globalPowerUps);\r\n      // setMines(mines);\r\n      if (isPlayerMasterPeer(player)) {\r\n        sendMinesUpdate(true, true);\r\n      }\r\n      // break; // exit the loop to avoid possible index errors - does that mean we can only register 1 collection per tick? if so we could simply schedule the removal of collected until after this loop\r\n    }\r\n  }\r\n}\r\n\r\nfunction mineCollided(mine, playerToCheck) {\r\n  let collision = false;\r\n  const relativeX = playerToCheck.x - mine.x;\r\n  const relativeY = playerToCheck.y - mine.y;\r\n\r\n  if (mine.mineType == MineType.REGULAR) {\r\n    // Same as before, no changes needed\r\n    const distance = Math.sqrt(relativeX * relativeX + relativeY * relativeY);\r\n    if (distance < 10 * shipScale + mine.radius) {\r\n      collision = true;\r\n    }\r\n  } else if (mine.mineType == MineType.TRAIL) {\r\n    // Calculate the ship's position in local coordinates of the mine\r\n    const localX = relativeX * Math.cos(-mine.angle) - relativeY * Math.sin(-mine.angle);\r\n    const localY = relativeX * Math.sin(-mine.angle) + relativeY * Math.cos(-mine.angle);\r\n\r\n    // Calculate half of the trailLength and half of the trailWidth\r\n    const halfTrailLength = mine.length / 2;\r\n    const halfTrailWidth = mine.width / 2;\r\n\r\n    // Check if the player is within the bounds of the end circles\r\n    const inCircle1 = localX * localX + (localY - halfTrailLength) * (localY - halfTrailLength) < halfTrailWidth * halfTrailWidth;\r\n    const inCircle2 = localX * localX + (localY + halfTrailLength) * (localY + halfTrailLength) < halfTrailWidth * halfTrailWidth;\r\n\r\n    // Check if the player is within the bounds of the rectangle\r\n    const inRectangle = Math.abs(localX) <= halfTrailWidth && Math.abs(localY) <= halfTrailLength;\r\n\r\n    // If the player is within any of the shapes, there is a collision\r\n    if (inCircle1 || inCircle2 || inRectangle) {\r\n      collision = true;\r\n    }\r\n  }\r\n\r\n  return collision;\r\n}\r\n\r\nexport function checkPlayerCollision(playerToCheck, allPlayers) {\r\n  for (let i = 0; i < allPlayers.length; i++) {\r\n    let hitCandidate = allPlayers[i];\r\n    if (playerToCheck.id == hitCandidate.id) {\r\n      //don't check collision against self\r\n      continue;\r\n    }\r\n    if (playerToCheck.timeSinceSentMessageThatWasRecieved > 120) {\r\n      //don't check collision against idle player\r\n      continue;\r\n    }\r\n    let dx = playerToCheck.x - hitCandidate.x;\r\n    let dy = playerToCheck.y - hitCandidate.y;\r\n    let distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    // treating hitbox/hurtbox of both ships as simple radius for now\r\n    if (\r\n      distance < 20 * shipScale &&\r\n      playerToCheck.isPlaying == true &&\r\n      hitCandidate.isPlaying == true &&\r\n      !playerToCheck.isDead &&\r\n      !hitCandidate.isDead &&\r\n      !hitCandidate.timeSinceSentMessageThatWasRecieved <= 120 &&\r\n      !(player.name == \"\" && player.pilot == \"\")\r\n    ) {\r\n      handlePlayerHit(playerToCheck, hitCandidate);\r\n      handlePlayerHit(hitCandidate, playerToCheck);\r\n    }\r\n  }\r\n}\r\n\r\nfunction handlePlayerHit(playerOne, playerTwo) {\r\n  if (playerTwo.isVulnerable()) {\r\n    if (playerOne.isTangible()) {\r\n      playerTwo.gotHit(playerOne.name, playerOne.isVulnerable());\r\n    }\r\n    // if (playerTwo.isBot) {\r\n    //   playerTwo.delayReset(botRespawnDelay, true, true);\r\n    // }\r\n  }\r\n  if (playerTwo.isInvincible() && playerOne.isVulnerable()) {\r\n    playerTwo.hitOtherPlayer(playerOne);\r\n  }\r\n}\r\n\r\nexport function checkForcesCollision(playerToCheck, forces) {\r\n  for (let force of forces) {\r\n    if (force.type == ForceType.DIRECTIONAL) {\r\n      //for now we make directional forces not expire naturally\r\n      force.duration = 10;\r\n    }\r\n    if (playerToCheck == force.tracks) {\r\n      continue;\r\n    }\r\n    if (playerToCheck != null && force.tracks != null && playerToCheck.id === force.tracks.id && playerToCheck.name === force.tracks.name) {\r\n      continue;\r\n    }\r\n\r\n    // Calculate the vector from the force to the player\r\n    const dx = playerToCheck.x - force.x;\r\n    const dy = playerToCheck.y - force.y;\r\n\r\n    // Calculate the distance between the player and the force\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    // Calculate the angle between the ship's direction and the vector to the player\r\n    const angleToPlayer = Math.atan2(dy, dx);\r\n    const angleDifference = Math.abs(force.direction - angleToPlayer);\r\n\r\n    if (force.type == ForceType.POINT) {\r\n      // Check if the player is within the cone and distance range\r\n      if (distance > force.radius || (angleDifference > force.coneAngle / 2 && force.coneAngle < 2 * Math.PI - 0.01)) {\r\n        continue;\r\n      }\r\n      playerToCheck.inForce += 2;\r\n      // Calculate the proportional force strength\r\n      let strength = 0;\r\n      const maxForce = force.force;\r\n\r\n      if (distance > 0 && distance <= 50) {\r\n        // Calculate strength based on the inverse square of the distance\r\n        // strength = force.force / 2500 / (distance * distance);\r\n        strength = maxForce;\r\n      } else if (distance > 50 && distance <= force.radius) {\r\n        // Gradual decrease in force from max at 50 to 40% at force.radius\r\n        const minForce = 0.6 * maxForce;\r\n        const forceRange = maxForce - minForce;\r\n        const distanceRange = force.radius - 50;\r\n        const forceIncrement = forceRange / distanceRange;\r\n        strength = maxForce - forceIncrement * (distance - 50);\r\n      }\r\n\r\n      // Calculate the force components\r\n      let forceX = (dx / distance) * strength;\r\n      let forceY = (dy / distance) * strength;\r\n\r\n      if (force.isAttractive) {\r\n        forceX *= -1;\r\n        forceY *= -1;\r\n      }\r\n\r\n      // Apply the force to playerToCheck's velocity\r\n      playerToCheck.vel.x += forceX;\r\n      playerToCheck.vel.y += forceY;\r\n      playerToCheck.boundVelocity();\r\n    } else if (force.type == ForceType.DIRECTIONAL) {\r\n      // Calculate the vector from the force to the player\r\n      const dx = playerToCheck.x - force.x;\r\n      const dy = playerToCheck.y - force.y;\r\n\r\n      // Rotate the player's position relative to the force direction\r\n      const rotatedX = dx * Math.cos(-force.direction) - dy * Math.sin(-force.direction);\r\n      const rotatedY = dx * Math.sin(-force.direction) + dy * Math.cos(-force.direction);\r\n\r\n      // Calculate half of the width and length of the rectangle\r\n      const halfWidth = force.width / 2;\r\n      const halfLength = force.length / 2;\r\n\r\n      // Check if the player is within the rotated rectangle and distance range\r\n      if (Math.abs(rotatedX) <= halfWidth && Math.abs(rotatedY) <= halfLength) {\r\n        playerToCheck.inForce += 5;\r\n        // Calculate the proportional force strength\r\n        let strength = 0;\r\n        const maxForce = force.force;\r\n\r\n        const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n        if (distance > 0 && distance <= halfLength) {\r\n          // Gradual decrease in force from max at 0 to 40% at halfLength\r\n          const minForce = 0.6 * maxForce;\r\n          const forceRange = maxForce - minForce;\r\n          strength = maxForce - (distance / halfLength) * forceRange;\r\n        }\r\n\r\n        // Calculate the force components based on the force's direction\r\n        const forceX = Math.cos(force.direction) * strength;\r\n        const forceY = Math.sin(force.direction) * strength;\r\n\r\n        if (force.isAttractive) {\r\n          // If the force is attractive, apply it in the opposite direction\r\n          playerToCheck.vel.x += -forceX;\r\n          playerToCheck.vel.y += -forceY;\r\n        } else {\r\n          // If the force is repulsive, apply it in the specified direction\r\n          playerToCheck.vel.x += forceX;\r\n          playerToCheck.vel.y += forceY;\r\n        }\r\n\r\n        playerToCheck.boundVelocity();\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function isSpokeCollision(entity, playerRadius, centerX, centerY, angle, spokeLength, spokeWidth) {\r\n  let playerX = entity.x;\r\n  let playerY = entity.y;\r\n  // Check for collision with each of the 8 spokes (or 4 diameters)\r\n  for (let angleDegrees = 0; angleDegrees < 360; angleDegrees += 45) {\r\n    const spokeAngleRadians = (angleDegrees + angle) * (Math.PI / 180); // Convert to radians\r\n\r\n    // Calculate the start and end points of the spoke\r\n    const spokeStartX = centerX;\r\n    const spokeStartY = centerY;\r\n    const spokeEndX = centerX + spokeLength * Math.cos(spokeAngleRadians);\r\n    const spokeEndY = centerY + spokeLength * Math.sin(spokeAngleRadians);\r\n\r\n    // Calculate the vector from the player's position to the spoke's start point\r\n    const dx = spokeStartX - playerX;\r\n    const dy = spokeStartY - playerY;\r\n\r\n    // Calculate the dot product of the vector from player to spoke and the spoke's direction vector\r\n    const dotProduct = dx * (spokeEndX - spokeStartX) + dy * (spokeEndY - spokeStartY);\r\n\r\n    // Check if the player is within the length of the spoke\r\n    if (dotProduct >= 0 && dotProduct <= spokeLength * spokeLength) {\r\n      // Calculate the perpendicular distance from the player to the spoke\r\n      const distance = Math.abs(dx * (spokeEndY - spokeStartY) - dy * (spokeEndX - spokeStartX)) / spokeLength;\r\n\r\n      // Check if the distance is less than the player's radius plus half of the spoke width\r\n      if (distance <= playerRadius + spokeWidth / 2) {\r\n        return true; // Collision detected with this spoke\r\n      }\r\n    }\r\n  }\r\n\r\n  // No collision with any spoke\r\n  return false;\r\n}\r\n\r\nfunction resolveMineHit(playerToCheck, mine, otherPlayers, bots, player) {\r\n  let mineOwner = otherPlayers.find((otherPlayer) => otherPlayer.id == mine.playerId);\r\n  if (!mineOwner) {\r\n    mineOwner = bots.find((bot) => bot.id == mine.playerId);\r\n  }\r\n  if (!mineOwner) {\r\n    if (player.id == mine.playerId) {\r\n      mineOwner = player;\r\n    }\r\n  }\r\n  if (mineOwner) {\r\n    playerToCheck.gotHit(mineOwner.name);\r\n    mineOwner.hitOtherPlayer(playerToCheck);\r\n  } else {\r\n    playerToCheck.gotHit(HitByType.MINE);\r\n  }\r\n}\r\n","import { shuffleArray } from \"./gameUtils.js\";\r\nimport { handleData } from \"./handleData.js\";\r\nimport { sendEntitiesState } from \"./sendData.js\";\r\n\r\nimport { Player } from \"./player.js\";\r\nexport let everConnected = false;\r\nexport let connections = [];\r\nexport const compression = false;\r\n\r\nexport let versionNumber = 115;\r\nexport let peerIds = [\r\n  \"a7ef962d-14a9-40e5-8a2d-226c548b3\" + versionNumber,\r\n  \"b7ef962d-14a9-40e5-8a2d-226c548b3\" + versionNumber,\r\n  \"c7ef962d-14a9-40e5-8a2d-226c548b3\" + versionNumber,\r\n  \"d7ef962d-14a9-40e5-8a2d-226c548b3\" + versionNumber,\r\n  \"e7ef962d-14a9-40e5-8a2d-226c548b3\" + versionNumber,\r\n  \"a6ef962d-14a9-40e5-8a2d-226c548b3\" + versionNumber,\r\n  \"b6ef962d-14a9-40e5-8a2d-226c548b3\" + versionNumber,\r\n];\r\nif (!compression) {\r\n  peerIds = [\r\n    \"a7ef962d-14a9-40e5-8a2d-226e638b3\" + versionNumber,\r\n    \"b7ef962d-14a9-40e5-8a2d-226e638b3\" + versionNumber,\r\n    \"c7ef962d-14a9-40e5-8a2d-226e638b3\" + versionNumber,\r\n    \"d7ef962d-14a9-40e5-8a2d-226e638b3\" + versionNumber,\r\n    \"e7ef962d-14a9-40e5-8a2d-226e638b3\" + versionNumber,\r\n    \"a6ef962d-14a9-40e5-8a2d-226e638b3\" + versionNumber,\r\n    \"b6ef962d-14a9-40e5-8a2d-226e638b3\" + versionNumber,\r\n  ];\r\n}\r\nlet reconnectionAttempts = 0;\r\nshuffleArray(peerIds);\r\nexport let ticksSinceLastConnectionAttempt = 0;\r\nexport function setTicksSinceLastConnectionAttempt(newTime) {\r\n  ticksSinceLastConnectionAttempt = newTime;\r\n}\r\nexport let ticksSinceLastFullSendRequestResponse = 0;\r\nexport function setTicksSinceLastFullSendRequestResponse(newTime) {\r\n  ticksSinceLastFullSendRequestResponse = newTime;\r\n}\r\nlet masterPeerId = peerIds[0]; // start off with the first peer as the master\r\nexport function setMasterPeerId(newID) {\r\n  masterPeerId = newID;\r\n}\r\nexport let timeSinceMessageFromMaster = 0;\r\nexport function setTimeSinceMessageFromMaster(newTime) {\r\n  timeSinceMessageFromMaster = newTime;\r\n}\r\nexport let timeSinceAnyMessageRecieved = 0;\r\nexport function setTimeSinceAnyMessageRecieved(newTime) {\r\n  timeSinceAnyMessageRecieved = newTime;\r\n}\r\nexport const wrappedResolveConflicts = createResolveConflictsWrapper();\r\n\r\nlet index = 0;\r\n\r\nlet peer;\r\nexport let connectedPeers = [];\r\nexport function setConnectedPeers(newConnectedPeers) {\r\n  connectedPeers = newConnectedPeers;\r\n}\r\nlet connectionBackOffTime = 0;\r\n\r\n// Wait for a short delay to allow time for the connections to be attempted\r\nexport function attemptConnections(player, otherPlayers, globalPowerUps, addHandlers = true, connectPeers = true) {\r\n  if (player.id === null) {\r\n    console.log(\"in attemptConnections Player id is null\");\r\n    connectionBackOffTime = (connectionBackOffTime + 500) * 2;\r\n    setTimeout(() => createPeer(player, otherPlayers, globalPowerUps), connectionBackOffTime);\r\n    return;\r\n  }\r\n  verifyPeerHealth(player, otherPlayers, globalPowerUps);\r\n  peer.on(\"connection\", function (conn) {\r\n    console.log(\"Connection made with peer:\", conn.peer);\r\n    everConnected = true;\r\n\r\n    if (addHandlers) {\r\n      addConnectionHandlers(player, otherPlayers, conn, globalPowerUps);\r\n    }\r\n    if (!connectedPeers.includes(conn.peer)) {\r\n      connectedPeers.push(conn.peer);\r\n    }\r\n    connectedPeers.sort();\r\n\r\n    masterPeerId = chooseNewMasterPeer(player, otherPlayers);\r\n    conn.on(\"close\", function () {\r\n      console.log(\"Connection closed with peer:\", conn.peer);\r\n      connectedPeers = connectedPeers.filter((id) => id !== conn.peer);\r\n      connectedPeers.sort();\r\n      masterPeerId = chooseNewMasterPeer(player, otherPlayers);\r\n    });\r\n  });\r\n\r\n  peer.on(\"error\", function (err) {\r\n    //console.log(\"PeerJS error:\");\r\n  });\r\n\r\n  peer.on(\"disconnected\", function () {\r\n    console.log(\"Disconnected from server\");\r\n\r\n    // If the master peer has disconnected, choose a new master peer\r\n    // if (isPlayerMasterPeer(player)) {\r\n    masterPeerId = chooseNewMasterPeer(player, otherPlayers);\r\n    createPeer(player, otherPlayers, globalPowerUps);\r\n    //  }\r\n  });\r\n  if (connectPeers) {\r\n    connectToPeers(player, otherPlayers, globalPowerUps);\r\n  }\r\n}\r\n\r\nexport function isPlayerMasterPeer(player) {\r\n  if (player.id == null) {\r\n    return true;\r\n  }\r\n  return player.id === masterPeerId;\r\n}\r\n\r\nexport function connectToPeers(player, otherPlayers, globalPowerUps) {\r\n  // Connect to the other peers\r\n  peerIds.forEach((id) => {\r\n    if (id !== player.id) {\r\n      checkAndReplaceConnectionsFromId(id, player, otherPlayers, globalPowerUps);\r\n    }\r\n  });\r\n}\r\n\r\nexport function checkAndReplaceConnectionsFromId(id, player, otherPlayers, globalPowerUps) {\r\n  // Check if a connection with this id already exists\r\n  let existingConnection = connections.find((conn) => conn.peer === id);\r\n  if (!existingConnection || !existingConnection.open) {\r\n    // If the connection doesn't exist or is closed, retry it\r\n    let conn = null;\r\n    verifyPeerHealth(player, otherPlayers, globalPowerUps);\r\n    if (peer && !peer.disconnected) {\r\n      conn = peer.connect(id);\r\n    } else {\r\n      console.log(\"peer undefined/closed/disconneced in connect to peers\");\r\n      if (peer) {\r\n        // console.log(\"peer open: \" + peer.open);\r\n        // console.log(\"peer disconnected: \" + peer.disconnected);\r\n      }\r\n    }\r\n    checkAndReplaceConnection(conn, existingConnection, player, otherPlayers, globalPowerUps);\r\n  } else {\r\n    // The existing connection is open, so no action needed\r\n  }\r\n}\r\n\r\nexport function checkAndReplaceConnection(conn, existingConnection, player, otherPlayers, globalPowerUps) {\r\n  if (conn != null && conn != undefined) {\r\n    // If the connection was successfully (re)established, update or replace it\r\n    if (existingConnection) {\r\n      // If there was an existing connection, replace it with the new one\r\n      const index = connections.indexOf(existingConnection);\r\n      if (index !== -1) {\r\n        connections.splice(index, 1, conn);\r\n      }\r\n    } else {\r\n      // If there wasn't an existing connection, add the new one to the array\r\n      connections.push(conn);\r\n    }\r\n    everConnected = true;\r\n    //todo carefully assess result of removing this\r\n    addConnectionHandlers(player, otherPlayers, conn, globalPowerUps);\r\n  }\r\n}\r\n\r\nexport function createPeer(player, otherPlayers, globalPowerUps, reconnectionAttempts = -1) {\r\n  if (!reconnectionAttempts == -1) {\r\n    reconnectionAttempts++;\r\n    let rand = Math.random();\r\n    if (reconnectionAttempts > 20) {\r\n      if (rand > 0.1) {\r\n        return;\r\n      }\r\n    }\r\n    if (reconnectionAttempts > 10) {\r\n      if (rand > 0.2) {\r\n        return;\r\n      }\r\n    }\r\n    if (reconnectionAttempts > 3) {\r\n      if (rand > 0.5) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  if (index >= peerIds.length) {\r\n    console.log(\"All IDs are in use - createPeer function\");\r\n    resolveConnectionConflicts(player, otherPlayers, globalPowerUps);\r\n    return;\r\n  }\r\n\r\n  let id = peerIds[index];\r\n  setPeer(new Peer(id)); // Assign the new Peer to the peer variable\r\n  verifyPeerHealth(player, otherPlayers, globalPowerUps);\r\n  peer.on(\"open\", function () {\r\n    // If the ID is already in use, this will not be called\r\n    player.id = id;\r\n    //when we connect initially we set ourselves as master\r\n    masterPeerId = id;\r\n    // Add the local player's ID to the connectedPeers array //why is our id in this list?\r\n    connectedPeers.push(id);\r\n    console.log(\"My peer ID is: \" + id);\r\n    attemptConnections(player, otherPlayers, globalPowerUps, true, true);\r\n  });\r\n\r\n  peer.on(\"error\", function (err) {\r\n    // If the ID is already in use, an error will be thrown\r\n    if (err.type === \"unavailable-id\") {\r\n      console.log(\"ID is in use:\", id);\r\n      index++;\r\n\r\n      createPeer(player, otherPlayers, globalPowerUps, reconnectionAttempts);\r\n    } else if (err.type === \"browser-incompatible\") {\r\n      console.log(\"browser incompatible:\", err);\r\n    } else if (err.type === \"network\") {\r\n      console.log(\"network error :\", err);\r\n      createPeer(player, otherPlayers, globalPowerUps, reconnectionAttempts);\r\n    } else {\r\n      console.log(\"Other error:\", err);\r\n    }\r\n  });\r\n  peer.on(\"close\", () => {\r\n    //peer.destroy();\r\n    // console.log(\"Connection to signaling server closed. Attempting to reconnect...\");\r\n    // createPeer(player, otherPlayers, globalPowerUps);\r\n    console.log(\"Connection to signaling server closed. \");\r\n    if (peer.disconnected) {\r\n      peer.destroy();\r\n      createPeer(player, otherPlayers, globalPowerUps);\r\n    }\r\n  });\r\n}\r\n\r\nfunction verifyPeerHealth(player, otherPlayers, globalPowerUps) {\r\n  // Check if peer.disconnected is true\r\n  if (peer.disconnected) {\r\n    console.log(\"peer was disconnected\");\r\n    try {\r\n      // Attempt to reconnect\r\n      peer.reconnect();\r\n    } catch (error) {\r\n      console.log(\"error reconnecting peer: \" + error);\r\n      index = 0;\r\n      createPeer(player, otherPlayers, globalPowerUps, reconnectionAttempts);\r\n    }\r\n  }\r\n}\r\nfunction addConnectionHandlers(player, otherPlayers, conn, globalPowerUps) {\r\n  // console.log(\"adding connection handlers\");\r\n  conn.on(\"open\", function () {\r\n    console.log(\"Connection opened with peer:\", conn.peer);\r\n    // Check if a connection with the same peer already exists\r\n    const existingConnection = connections.find((existingConn) => existingConn.peer === conn.peer);\r\n\r\n    if (existingConnection) {\r\n      // // Close the existing connection\r\n      // existingConnection.close();\r\n      // // Remove the existing connection from the connections array\r\n      // const index = connections.indexOf(existingConnection);\r\n      // if (index !== -1) {\r\n      //   connections.splice(index, 1);\r\n      // }\r\n    } else {\r\n      // Push the new connection\r\n      // connections.push(conn);\r\n    }\r\n    //not sure why this seems to be needed even if there is existing connection\r\n    // connections.push(conn);\r\n    checkAndReplaceConnection(conn, existingConnection, player, otherPlayers, globalPowerUps);\r\n    let existingOtherPlayer = otherPlayers.some((player) => player.id === conn.peer);\r\n\r\n    //todo check consequennces of removing below - I don't think we should be adding player to list based on connect\r\n    if (!existingOtherPlayer) {\r\n      let otherPlayerData = new Player(conn.peer, -200, -200, 0, \"blue\", 0, \"\", \"\", player.worldDimensions, player.colors);\r\n      otherPlayers.push(otherPlayerData);\r\n      if (!connectedPeers.includes(otherPlayerData.id)) {\r\n        connectedPeers.push(otherPlayerData.id);\r\n      }\r\n      connectedPeers.sort();\r\n    }\r\n\r\n    if (isPlayerMasterPeer(player)) {\r\n      sendEntitiesState(conn.peer);\r\n    }\r\n  });\r\n\r\n  conn.on(\"error\", function (err) {\r\n    console.log(\"Connection error with peer:\", conn.peer, \", error:\", err);\r\n  });\r\n\r\n  conn.on(\"close\", function () {\r\n    console.log(\"Connection closed with peer:\", conn.peer);\r\n    // Remove player from otherPlayers array\r\n    otherPlayers = otherPlayers.filter((player) => player.id !== conn.peer);\r\n    //todo should remove from connnections too?\r\n  });\r\n\r\n  conn.on(\"data\", function (data) {\r\n    if (!data) {\r\n      return;\r\n    }\r\n    if (compression) {\r\n      // Decompress the data using Pako\r\n      const inflatedData = pako.inflate(data);\r\n\r\n      // Convert the decompressed Uint8Array directly to a JavaScript object\r\n      data = JSON.parse(new TextDecoder().decode(inflatedData));\r\n    }\r\n    //console.log(\"Received data:\", data);\r\n    if ((data && data.id) || (data && data.gameState) || (data && data.requestForFullStates) || (data && data.requestFullUpdate)) {\r\n      handleData(player, otherPlayers, globalPowerUps, data);\r\n    } else {\r\n      console.log(\"Received unexpected data:\", data);\r\n    }\r\n    // If there is a conflict between the local game state and the received game state,\r\n    // update the local game state to match the received game state\r\n    //todo not sure why this was a good place to do this but do need to have times to call this to try to resync\r\n    // wrappedResolveConflicts(player, otherPlayers, globalPowerUps);\r\n  });\r\n}\r\n\r\nexport function getPeer() {\r\n  return peer;\r\n}\r\n\r\nfunction setPeer(newPeer) {\r\n  peer = newPeer;\r\n}\r\n\r\nexport function removeClosedConnections(otherPlayers) {\r\n  connections.forEach((conn, index) => {\r\n    if (conn && conn.closed) {\r\n      console.log(\"Connection closed with peer:\", conn.peer);\r\n      otherPlayers = otherPlayers.filter((player) => player.id !== conn.peer);\r\n      connections.splice(index, 1); // Remove the connection from the connections array\r\n    } else if (!conn) {\r\n      console.log(\"Connection null, removing from otherplayers list and from connections\", conn.peer);\r\n      otherPlayers = otherPlayers.filter((player) => player.id !== conn.peer);\r\n      connections = connections.filter((player) => player.id !== conn.peer);\r\n    }\r\n  });\r\n}\r\n\r\nexport function getPlayerId() {\r\n  return id;\r\n}\r\n\r\nexport function chooseNewMasterPeer(player, otherPlayers) {\r\n  //ok so we remove inactive player from connectedPeers list... but how can that player reconnect? do we want / need to remove from otherplayers too? do we just set it to dead?\r\n  otherPlayers.forEach((otherPlayer) => {\r\n    if (otherPlayer.timeSinceSentMessageThatWasRecieved > 60) {\r\n      //connectedPeers = connectedPeers.filter((peer) => peer !== otherPlayer.id);\r\n    } else {\r\n      if (!connectedPeers.includes(otherPlayer.id)) {\r\n        connectedPeers.push(otherPlayer.id);\r\n      }\r\n    }\r\n  });\r\n  let foundActivePlayerWithId = false;\r\n  if (connectedPeers.length > 0) {\r\n    connectedPeers.sort();\r\n    for (let connectedPeer of connectedPeers) {\r\n      if (connectedPeer == player.id) {\r\n        foundActivePlayerWithId = true;\r\n      }\r\n      otherPlayers.forEach((otherPlayer) => {\r\n        if (otherPlayer.timeSinceSentMessageThatWasRecieved <= 60 && otherPlayer.id == connectedPeer) {\r\n          foundActivePlayerWithId = true;\r\n        }\r\n      });\r\n      if (foundActivePlayerWithId) {\r\n        masterPeerId = connectedPeer;\r\n\r\n        if (masterPeerId === player.id) {\r\n          player.setPlayerIsMaster(true);\r\n        } else {\r\n          player.setPlayerIsMaster(false);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  if (!foundActivePlayerWithId) {\r\n    masterPeerId = player.id;\r\n    player.setPlayerIsMaster(true);\r\n  }\r\n\r\n  otherPlayers.forEach((otherPlayer) => {\r\n    if (otherPlayer instanceof Player) {\r\n      if (masterPeerId === otherPlayer.id) {\r\n        otherPlayer.setPlayerIsMaster(true);\r\n      } else {\r\n        otherPlayer.setPlayerIsMaster(false);\r\n      }\r\n    } else {\r\n      // console.error(\"otherPlayer is not an instance of Player:\", otherPlayer);\r\n    }\r\n  });\r\n\r\n  return masterPeerId;\r\n}\r\n\r\nexport function createResolveConflictsWrapper() {\r\n  let isScheduled = false;\r\n\r\n  return function (player, otherPlayers, globalPowerUps) {\r\n    if (!isScheduled) {\r\n      // If not scheduled, call the function and set the flag\r\n      resolveConflicts(player, otherPlayers, globalPowerUps);\r\n      isScheduled = true;\r\n\r\n      // Schedule to reset the flag after 5 seconds\r\n      setTimeout(() => {\r\n        isScheduled = false;\r\n      }, 5000);\r\n    }\r\n  };\r\n}\r\n\r\nfunction resolveConflicts(player, otherPlayers, globalPowerUps) {\r\n  // If there is a conflict between the local game state and the received game state,\r\n  // update the local game state to match the received game state\r\n  if (player.id == null) {\r\n    createPeer(player, otherPlayers, globalPowerUps);\r\n  }\r\n  resolveConnectionConflicts(player, otherPlayers, globalPowerUps, true);\r\n}\r\n\r\nfunction resolveConnectionConflicts(player, otherPlayers, globalPowerUps, tryToRedoConnections = false) {\r\n  // If there is a conflict between the local game state and the received game state,\r\n\r\n  //not sure about the below might need to keep it in mind but I think it was causing major issues.\r\n  // setTicksSinceLastConnectionAttempt(0);\r\n  // otherPlayers = otherPlayers.filter((player) => player.id !== connectedPeers[0]);\r\n  // connections = connections.filter((connection) => connection.peer !== connectedPeers[0]);\r\n  // connectedPeers.splice(0, 1);\r\n  //might not be able to attempt connections again without issues\r\n  if (timeSinceAnyMessageRecieved > 1000 && tryToRedoConnections == true) {\r\n    console.log(\"attempting resolveConnections\");\r\n    setTimeout(() => attemptConnections(player, otherPlayers, globalPowerUps, true, false), 50);\r\n  }\r\n  masterPeerId = chooseNewMasterPeer(player, otherPlayers);\r\n}\r\n","import { updateTopScoresInfo } from \"/canvasDrawingFunctions.js\";\r\n\r\nlet firebaseConfig = {\r\n  apiKey: \"AIzaSyAKNQY57EwlQ6TAf13wSx4eba4NK-MAN88\",\r\n  authDomain: \"p2p-game-test.firebaseapp.com\",\r\n  projectId: \"p2p-game-test\",\r\n  storageBucket: \"p2p-game-test.appspot.com\",\r\n  messagingSenderId: \"849363353418\",\r\n  appId: \"1:849363353418:web:13c04c4ac2ef99c88b4bb3\",\r\n};\r\nfirebase.initializeApp(firebaseConfig);\r\n\r\nexport let allTimeKills = 0;\r\nexport let allTimePoints = 0;\r\nexport let allTimeLogins = 0;\r\n\r\nexport const DbPropertyKey = {\r\n  LOGINS: \"logins\",\r\n  KILLS: \"kills\",\r\n  SCORE: \"score\",\r\n};\r\n\r\nexport const DbDocumentKey = {\r\n  USERS: \"users\",\r\n};\r\n\r\n// import {} from \"firebase/auth\";\r\nexport function getFirebase() {\r\n  return firebase;\r\n}\r\n\r\nexport let firebaseDb = firebase.firestore();\r\n\r\nexport function addScoreToDB(category, name, score) {\r\n  var collection = firebaseDb.collection(category);\r\n\r\n  // Get the current top 10 scores\r\n  collection\r\n    .orderBy(\"score\", \"desc\")\r\n    .limit(10)\r\n    .get()\r\n    .then((querySnapshot) => {\r\n      // Count the number of scores in the category\r\n      const numScores = querySnapshot.size;\r\n\r\n      // If there are fewer than 10 scores, add the new score\r\n      if (numScores < 10) {\r\n        collection\r\n          .add({\r\n            name: name,\r\n            score: score,\r\n            date: firebase.firestore.FieldValue.serverTimestamp(),\r\n          })\r\n          .then(function (docRef) {\r\n            console.log(\"Score written with ID: \", docRef.id);\r\n          })\r\n          .catch(function (error) {\r\n            console.error(\"Error adding score: \", error);\r\n          });\r\n      } else {\r\n        // Otherwise, check if the new score is in the top 10\r\n        var lowestScore = null;\r\n\r\n        querySnapshot.forEach((doc) => {\r\n          if (lowestScore == null || doc.data().score < lowestScore) {\r\n            lowestScore = doc.data().score;\r\n          }\r\n        });\r\n\r\n        if (score > lowestScore) {\r\n          collection\r\n            .add({\r\n              name: name,\r\n              score: score,\r\n              date: firebase.firestore.FieldValue.serverTimestamp(),\r\n            })\r\n            .then(function (docRef) {\r\n              console.log(\"Score written with ID: \", docRef.id);\r\n            })\r\n            .catch(function (error) {\r\n              console.error(\"Error adding score: \", error);\r\n            });\r\n        }\r\n      }\r\n    });\r\n}\r\n\r\nexport function getTopScores(category, X) {\r\n  return new Promise((resolve, reject) => {\r\n    var scores = [];\r\n    firebaseDb\r\n      .collection(category)\r\n      .orderBy(\"score\", \"desc\")\r\n      .limit(X)\r\n      .get()\r\n      .then((querySnapshot) => {\r\n        querySnapshot.forEach((doc) => {\r\n          var data = doc.data();\r\n          scores.push(`${data.score}, ${data.name}`);\r\n        });\r\n        resolve(scores);\r\n      })\r\n      .catch((error) => {\r\n        reject(error);\r\n      });\r\n  });\r\n}\r\n\r\nfunction updateFirebaseProperty(firebase, collectionName, documentId, propertyName, newValue, callback) {\r\n  const user = firebase.auth().currentUser;\r\n\r\n  if (user) {\r\n    const userRef = firebase.firestore().collection(collectionName).doc(documentId);\r\n\r\n    userRef\r\n      .get()\r\n      .then((doc) => {\r\n        if (doc.exists) {\r\n          const dataToUpdate = {};\r\n          dataToUpdate[propertyName] = newValue;\r\n\r\n          // Update the specified property in Firestore.\r\n          userRef\r\n            .update(dataToUpdate)\r\n            .then(() => {\r\n              console.log(`${propertyName} updated to ${newValue}`);\r\n              // You can also update the user interface with the new property value here.\r\n              callback(null);\r\n            })\r\n            .catch((error) => {\r\n              console.error(`Error updating ${propertyName}: ${error}`);\r\n              callback(error);\r\n            });\r\n        } else {\r\n          callback(new Error(\"User document not found\"), null);\r\n        }\r\n      })\r\n      .catch((error) => {\r\n        console.error(`Error getting user document: ${error}`);\r\n        callback(error);\r\n      });\r\n  } else {\r\n    // User is not logged in.\r\n    callback(new Error(\"User not logged in\"));\r\n  }\r\n}\r\n\r\n// Function to read data from Firestore (e.g., logins count) for the currently authenticated user.\r\nexport function readUserDataFromFirestore(firebase, collectionName, callback) {\r\n  const user = firebase.auth().currentUser;\r\n\r\n  if (user) {\r\n    const userRef = firebase.firestore().collection(collectionName).doc(user.uid);\r\n\r\n    userRef\r\n      .get()\r\n      .then((doc) => {\r\n        if (doc.exists) {\r\n          const userData = doc.data();\r\n          callback(null, userData);\r\n        } else {\r\n          callback(new Error(\"User data not found\"), null);\r\n        }\r\n      })\r\n      .catch((error) => {\r\n        callback(error, null);\r\n      });\r\n  } else {\r\n    // User is not logged in.\r\n    callback(new Error(\"User not logged in\"), null);\r\n  }\r\n}\r\n\r\n// Increments a numeric property in Firestore for the currently authenticated user.\r\nfunction incrementFirebaseProperty(firebase, collectionName, documentId, propertyName, incrementBy, callback) {\r\n  const user = firebase.auth().currentUser;\r\n\r\n  if (user) {\r\n    const userRef = firebase.firestore().collection(collectionName).doc(documentId);\r\n\r\n    userRef\r\n      .get()\r\n      .then((doc) => {\r\n        if (doc.exists) {\r\n          const currentValue = doc.data()[propertyName] || 0;\r\n          const newValue = currentValue + incrementBy;\r\n\r\n          // Update the specified property in Firestore.\r\n          const dataToUpdate = {};\r\n          dataToUpdate[propertyName] = newValue;\r\n\r\n          userRef\r\n            .update(dataToUpdate)\r\n            .then(() => {\r\n              console.log(`${propertyName} incremented by ${incrementBy} to ${newValue}`);\r\n              // You can also update the user interface with the new property value here.\r\n              callback(null, newValue);\r\n            })\r\n            .catch((error) => {\r\n              console.error(`Error updating ${propertyName}: ${error}`);\r\n              callback(error, null);\r\n            });\r\n        } else {\r\n          // User document doesn't exist; create it and set the property to the increment value.\r\n          const dataToCreate = {};\r\n          dataToCreate[propertyName] = incrementBy;\r\n\r\n          userRef\r\n            .set(dataToCreate)\r\n            .then(() => {\r\n              console.log(`User document created with ${propertyName} set to ${incrementBy}`);\r\n              // You can also update the user interface with the new property value here.\r\n              callback(null, incrementBy);\r\n            })\r\n            .catch((error) => {\r\n              console.error(`Error creating user document: ${error}`);\r\n              callback(error, null);\r\n            });\r\n        }\r\n      })\r\n      .catch((error) => {\r\n        console.error(`Error getting user document: ${error}`);\r\n        callback(error, null);\r\n      });\r\n  } else {\r\n    // User is not logged in.\r\n    callback(new Error(\"User not logged in\"), null);\r\n  }\r\n}\r\n\r\nexport function getFirebaseProperty(firebase, collectionName, documentId, propertyName, callback) {\r\n  const user = firebase.auth().currentUser;\r\n\r\n  if (user) {\r\n    const userRef = firebase.firestore().collection(collectionName).doc(documentId);\r\n\r\n    userRef\r\n      .get()\r\n      .then((doc) => {\r\n        if (doc.exists) {\r\n          const currentValue = doc.data()[propertyName] || 0;\r\n          callback(null, currentValue);\r\n        } else {\r\n          // User document doesn't exist; create it and set the property to 0.\r\n          const dataToCreate = {};\r\n          dataToCreate[propertyName] = 0;\r\n\r\n          userRef\r\n            .set(dataToCreate)\r\n            .then(() => {\r\n              console.log(`User document created with ${propertyName} set to ${incrementBy}`);\r\n              // You can also update the user interface with the new property value here.\r\n              callback(null, incrementBy);\r\n            })\r\n            .catch((error) => {\r\n              console.error(`Error creating user document: ${error}`);\r\n              callback(error, null);\r\n            });\r\n        }\r\n      })\r\n      .catch((error) => {\r\n        console.error(`Error getting user document: ${error}`);\r\n        callback(error, null);\r\n      });\r\n  } else {\r\n    // User is not logged in.\r\n    callback(new Error(\"User not logged in\"), null);\r\n  }\r\n}\r\n\r\nfunction incrementFirebaseLoginsValue(firebase) {\r\n  const user = firebase.auth().currentUser;\r\n  incrementFirebaseProperty(firebase, DbDocumentKey.USERS, user.uid, DbPropertyKey.LOGINS, 1, (error, newValue) => {\r\n    if (error) {\r\n      console.error(`Error incrementing logins count: ${error}`);\r\n    } else {\r\n      console.log(`Logins count incremented to ${newValue}`);\r\n      // You can also update the user interface with the new logins count here.\r\n    }\r\n  });\r\n}\r\n\r\nfunction incrementFirebaseScoreValue(firebase, incrementBy) {\r\n  const user = firebase.auth().currentUser;\r\n  incrementFirebaseProperty(firebase, DbDocumentKey.USERS, user.uid, \"score\", incrementBy, (error, newValue) => {\r\n    if (error) {\r\n      console.error(`Error incrementing score count: ${error}`);\r\n    } else {\r\n      console.log(`Logins count incremented to ${newValue}`);\r\n      // You can also update the user interface with the new score total here\r\n    }\r\n  });\r\n}\r\n\r\nexport function incrementFirebaseGivenPropertyValue(firebase, property, incrementBy) {\r\n  const user = firebase.auth().currentUser;\r\n  incrementFirebaseProperty(firebase, DbDocumentKey.USERS, user.uid, property, incrementBy, (error, newValue) => {\r\n    if (error) {\r\n      console.error(`Error incrementing ${property} count: ${error}`);\r\n    } else {\r\n      console.log(`${property} count incremented to ${newValue}`);\r\n      //in future might want to be more specific about what to update\r\n      updateAchievements();\r\n    }\r\n  });\r\n}\r\n\r\nexport function updateAchievements() {\r\n  let firebase = getFirebase();\r\n  if (firebase) {\r\n    const user = firebase.auth().currentUser;\r\n    if (user) {\r\n      getFirebaseProperty(firebase, DbDocumentKey.USERS, user.uid, DbPropertyKey.KILLS, (error, value) => {\r\n        if (error) {\r\n          console.error(`Error getting ${property} count: ${error}`);\r\n        } else {\r\n          allTimeKills = value;\r\n        }\r\n      });\r\n      getFirebaseProperty(firebase, DbDocumentKey.USERS, user.uid, DbPropertyKey.SCORE, (error, value) => {\r\n        if (error) {\r\n          console.error(`Error getting ${property} count: ${error}`);\r\n        } else {\r\n          allTimePoints = value * 100;\r\n        }\r\n      });\r\n      getFirebaseProperty(firebase, DbDocumentKey.USERS, user.uid, DbPropertyKey.LOGINS, (error, value) => {\r\n        if (error) {\r\n          console.error(`Error getting ${property} count: ${error}`);\r\n        } else {\r\n          allTimeLogins = value;\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n","import { maxInvincibilityTime, maxSpecialMeter, pilots } from \"./gameLogic.js\";\r\nimport { isPlayerMasterPeer, timeSinceAnyMessageRecieved, timeSinceMessageFromMaster } from \"./connectionHandlers.js\";\r\nimport { BotState, Player } from \"./player.js\";\r\nimport { executionTime } from \"./main.js\";\r\n\r\nexport function renderDebugInfo(ctx, player, bots) {\r\n  ctx.textAlign = \"start\";\r\n  const topGap = 100;\r\n  const gap = 16; // Gap between lines\r\n  const textHeight = 75; // Adjust this to the size of your text\r\n  ctx.font = \"14px Arial\";\r\n  const myIDText = `My ID: ${player.id}`;\r\n  ctx.fillStyle = \"white\";\r\n  ctx.fillText(myIDText, 558, topGap - textHeight);\r\n\r\n  const myDistanceFactorText = `distanceFactor ${player.distanceFactor}`;\r\n  ctx.fillText(myDistanceFactorText, 558, topGap + gap - textHeight);\r\n\r\n  const isMasterText = `is Master =  ${isPlayerMasterPeer(player)}`;\r\n  ctx.fillText(isMasterText, 558, topGap + gap * 2 - textHeight);\r\n  ctx.fillText(`invicible state: ${player.invincibleTimer}`, 558, topGap + gap * 3 - textHeight);\r\n\r\n  const executionTimeText = `executionTime =  ${executionTime}`;\r\n  ctx.fillText(executionTimeText, 558, topGap + gap * 4 - textHeight);\r\n\r\n  const timeSinceAnyMessageRecievedText = `timeSinceAnyMessageRecieved =  ${timeSinceAnyMessageRecieved}`;\r\n  ctx.fillText(timeSinceAnyMessageRecievedText, 558, topGap + gap * 5 - textHeight);\r\n\r\n  const timeSinceMessageFromMasterText = `timeSinceMessageFromMaster =  ${timeSinceMessageFromMaster}`;\r\n  ctx.fillText(timeSinceMessageFromMasterText, 558, topGap + gap * 6 - textHeight);\r\n\r\n  const velocityText = `player velocity = ${player.vel.x.toFixed(1)}, ${player.vel.y.toFixed(1)}`;\r\n  ctx.fillText(velocityText, 558, topGap + gap * 7 - textHeight);\r\n  let lineCount = 0;\r\n  bots.forEach((bot, index) => {\r\n    let botInfo;\r\n    if (bot.botState == BotState.FOLLOW_PLAYER) {\r\n      botInfo = `${bot.name} state: ${bot.botState} following: ${bot.followingPlayerID} `;\r\n    } else {\r\n      botInfo = `${bot.name} state: ${bot.botState} aiming: ${bot.target.x},${bot.target.y} `;\r\n    }\r\n    ctx.fillText(botInfo, 958, topGap + gap * index - textHeight);\r\n    lineCount = index;\r\n  });\r\n  if (player.currentFrictionPercent) {\r\n    const frictionPercentText = `friction percent:   ${player.currentFrictionPercent}`;\r\n    ctx.fillText(frictionPercentText, 958, topGap + gap * (lineCount + 1) - textHeight);\r\n    const speedText = `speed:   ${player.currentSpeed}`;\r\n    ctx.fillText(speedText, 958, topGap + gap * (lineCount + 2) - textHeight);\r\n  }\r\n}\r\n\r\nexport function drawFilledGauge(ctx, centerX, bottomY, gaugeWidth = 200, gaugeHeight = 50, borderWidth = 7, filled, total, color = \"#ff9900\") {\r\n  const fillPercent = filled / total;\r\n  drawGauge(ctx, centerX, bottomY, fillPercent, color, gaugeWidth, gaugeHeight, borderWidth);\r\n}\r\n\r\nexport function drawInvincibilityGauge(ctx, player, centerX, bottomY, gaugeWidth = 200, gaugeHeight = 50, borderWidth = 7) {\r\n  let pilotMaxInvcibilityTime = maxInvincibilityTime;\r\n  for (let pilot of pilots) {\r\n    if (player.pilot == pilot.name) {\r\n      pilotMaxInvcibilityTime = pilot.invincibilityTime;\r\n      break;\r\n    }\r\n  }\r\n  const fillPercent = player.invincibleTimer / pilotMaxInvcibilityTime;\r\n  drawGauge(ctx, centerX, bottomY, fillPercent, \"#ff9900\", gaugeWidth, gaugeHeight, borderWidth);\r\n}\r\n\r\nexport function drawSpecialGauge(ctx, player, centerX, bottomY, gaugeWidth = 200, gaugeHeight = 50, borderWidth = 7) {\r\n  const fillPercent = player.specialMeter / maxSpecialMeter;\r\n  drawGauge(ctx, centerX, bottomY, fillPercent, \"#00FF00\", gaugeWidth, gaugeHeight, borderWidth);\r\n}\r\n\r\nfunction drawGauge(ctx, centerX, bottomY, fillPercent, color, gaugeWidth = 200, gaugeHeight = 50, borderWidth = 7) {\r\n  const gaugeColor = color; // Fill color of the gauge\r\n  const borderColor = \"#333\"; // Border color\r\n\r\n  const fillWidth = gaugeWidth * fillPercent;\r\n\r\n  // Create a linear gradient for the gauge background\r\n  const gradient = ctx.createLinearGradient(centerX - gaugeWidth / 2, bottomY - gaugeHeight, centerX + gaugeWidth / 2, bottomY);\r\n\r\n  // Define gradient colors\r\n  gradient.addColorStop(0, \"rgba(0, 0, 0, 0.5)\"); // Start with transparent black\r\n  gradient.addColorStop(0.5, \"rgba(255, 255, 255, 0.3)\"); // Middle with semi-transparent white\r\n  gradient.addColorStop(1, \"rgba(0, 0, 0, 0.5)\"); // End with transparent black\r\n\r\n  // Draw the gradient background\r\n  ctx.fillStyle = gradient;\r\n  ctx.fillRect(centerX - gaugeWidth / 2, bottomY - gaugeHeight, gaugeWidth, gaugeHeight);\r\n\r\n  // Draw the gauge fill based on fillPercent\r\n  ctx.fillStyle = gaugeColor;\r\n  ctx.fillRect(\r\n    centerX - gaugeWidth / 2 + borderWidth,\r\n    bottomY - gaugeHeight + borderWidth,\r\n    Math.max(0, fillWidth - borderWidth * 2),\r\n    gaugeHeight - borderWidth * 2\r\n  );\r\n}\r\n\r\nexport function drawPowerupLevels(ctx, player, otherPlayers, bots) {\r\n  const topGap = 20;\r\n  const textHeight = 20; // Adjust this to the size of your text\r\n  const gap = 16; // Gap between lines\r\n  const boxPadding = 10; // Padding around the box\r\n  let boxWidth = 200; // Width of the box\r\n  let boxHeight = 2 * boxPadding; // Start with padding at the top and bottom\r\n\r\n  // Measure the maximum text width to align to the right of the box\r\n  let maxTextWidth = 0;\r\n\r\n  ctx.font = \"14px Arial\";\r\n\r\n  if (player != null) {\r\n    const score = player.powerUps * 100;\r\n    const myPowerupText = `${player.name}: ${score}`;\r\n    ctx.fillStyle = player.color;\r\n    const textWidth = ctx.measureText(myPowerupText).width;\r\n    maxTextWidth = Math.max(maxTextWidth, textWidth);\r\n    boxHeight += textHeight + gap;\r\n  }\r\n\r\n  otherPlayers.forEach((otherPlayer) => {\r\n    if (!otherPlayer.isDead && otherPlayer.isPlaying) {\r\n      if (!otherPlayer.name) {\r\n        // console.log(\"unnamed other player\");\r\n      }\r\n      let playerName = otherPlayer.name || \"Unknown\";\r\n      const score = otherPlayer.powerUps * 100;\r\n      const playerPowerupText = playerName + `: ${score}`;\r\n      const textWidth = ctx.measureText(playerPowerupText).width;\r\n      maxTextWidth = Math.max(maxTextWidth, textWidth);\r\n      boxHeight += textHeight + gap;\r\n    }\r\n  });\r\n\r\n  bots.forEach((bot) => {\r\n    if (!bot.name) {\r\n      // console.log(\"unnamed other player\");\r\n    }\r\n    if (bot.isDead) {\r\n      return;\r\n    }\r\n    let playerName = bot.name || \"Unknown\";\r\n    const score = bot.powerUps * 100;\r\n    const playerPowerupText = playerName + `: ${score}`;\r\n    const textWidth = ctx.measureText(playerPowerupText).width;\r\n    maxTextWidth = Math.max(maxTextWidth, textWidth);\r\n    boxHeight += textHeight + gap;\r\n  });\r\n\r\n  //size box to fit the largest name/score combno, with a min size\r\n  boxWidth = Math.max(150, maxTextWidth + 20);\r\n\r\n  // Calculate the position of the box\r\n  const boxX = 100; // Adjust this as needed\r\n  const boxY = topGap - boxPadding;\r\n\r\n  // Create a gradient for the box background\r\n  const gradient = ctx.createLinearGradient(boxX, boxY, boxX + boxWidth, boxY + boxHeight);\r\n  gradient.addColorStop(0, \"rgba(0, 0, 0, 0.2)\"); // Transparent black\r\n  gradient.addColorStop(1, \"rgba(0, 0, 0, 0.5)\"); // Semi-transparent black\r\n\r\n  // Draw the box background with gradient\r\n  ctx.fillStyle = gradient;\r\n  ctx.strokeStyle = \"#555\"; // Border color\r\n  // ctx.strokeStyle = gradient; // Border color\r\n  ctx.lineWidth = 2; // Border width\r\n  ctx.fillRect(boxX, boxY, boxWidth, boxHeight);\r\n  ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);\r\n\r\n  ctx.textAlign = \"center\";\r\n\r\n  // Draw the text inside the box\r\n  let currentY = boxY + boxPadding + textHeight + 10;\r\n  ctx.fillStyle = \"white\";\r\n  ctx.fillText(\"Leaderboard\", boxX + boxWidth / 2, boxY + boxPadding + 5);\r\n\r\n  ctx.textAlign = \"right\";\r\n\r\n  // Combine all players (including player) and bots into a single array\r\n  let allPlayers;\r\n  if (player == null || player.name == \"\") {\r\n    allPlayers = [...otherPlayers, ...bots];\r\n  } else {\r\n    allPlayers = [player, ...otherPlayers, ...bots];\r\n  }\r\n  ctx.font = \"14px Arial\";\r\n\r\n  // Sort allPlayers by score in descending order\r\n  allPlayers.sort((a, b) => {\r\n    return b.powerUps - a.powerUps;\r\n  });\r\n\r\n  allPlayers.forEach((currentPlayer) => {\r\n    if (!currentPlayer.isDead && currentPlayer.isPlaying) {\r\n      let playerName = currentPlayer.name || \"Unknown\";\r\n      const score = currentPlayer.powerUps * 100;\r\n      const playerPowerupText = playerName + `: ${score}`;\r\n\r\n      ctx.fillStyle = currentPlayer.color;\r\n      ctx.fillText(playerPowerupText, boxX + boxWidth - boxPadding, currentY);\r\n      currentY += textHeight + gap;\r\n    }\r\n  });\r\n}\r\n","import { renderDebugInfo, drawPowerupLevels, drawInvincibilityGauge, drawSpecialGauge } from \"./drawGameUI.js\";\r\nimport {\r\n  rotateAndScalePoint,\r\n  interpolate,\r\n  spikeyBallPoints,\r\n  drawArrow,\r\n  getComplementaryColor,\r\n  nameToRGBFullFormat,\r\n  applyGlowingEffect,\r\n} from \"./drawingUtils.js\";\r\nimport { ForceType, forces, effects, EffectType, MineType } from \"./entities.js\";\r\nimport { basicAnimationTimer } from \"./gameLogic.js\";\r\nimport { shipScale, mineScale } from \"./collisionLogic.js\";\r\n\r\n// Main function for drawing the ship\r\nexport function drawShip(ctx, camX, camY, player, points) {\r\n  if (\r\n    !player.isPlaying ||\r\n    player.isDead ||\r\n    (!player.isLocal && !player.isBot && player.timeSinceSentMessageThatWasRecieved > 120) ||\r\n    (player.name == \"\" && player.pilot == \"\")\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  const playerCenterXWorldCoords = player.x;\r\n  const playerCenterYWorldCoords = player.y;\r\n  const playerCenterXScreenCoords = playerCenterXWorldCoords - camX;\r\n  const playerCenterYScreenCoords = playerCenterYWorldCoords - camY;\r\n  const angle = player.getAngle();\r\n  const color = player.color;\r\n  const name = player.name;\r\n  const lightSourceX = 0;\r\n  const lightSourceY = 0;\r\n  const currentTime = Date.now();\r\n  let elapsedTime = currentTime - player.flameTransitionStartTime;\r\n  if (isNaN(elapsedTime)) {\r\n    elapsedTime = 0;\r\n  }\r\n  let flameAnimatationFrame = elapsedTime % 50;\r\n\r\n  if (!player.flameTransitionStartTime || elapsedTime >= 50) {\r\n    player.flameTransitionStartTime = currentTime;\r\n  }\r\n\r\n  if (player.space) {\r\n    const flameOffsetAngle = angle - Math.PI / 2 - 0.46;\r\n    const frequency = 0.5;\r\n    const amplitude = 1;\r\n    // Normalize time between 0 and 1\r\n    const time = (basicAnimationTimer % 40) / 40;\r\n    const pulse = amplitude * Math.sin(2 * Math.PI * frequency * time);\r\n\r\n    // Calculate flame size based on pulse\r\n    const baseFlameSize = 56;\r\n    const maxFlameSize = baseFlameSize + player.distanceFactor * 60;\r\n    const minFlameSize = baseFlameSize + player.distanceFactor * 0;\r\n    const flameSize = baseFlameSize + ((maxFlameSize - minFlameSize) * (pulse + 1)) / 2;\r\n\r\n    drawFlame(ctx, playerCenterXScreenCoords, playerCenterYScreenCoords, flameOffsetAngle, flameSize);\r\n  }\r\n\r\n  ctx.strokeStyle = color;\r\n  ctx.fillStyle = color;\r\n\r\n  if (player.invincibleTimer > 10 || (player.invincibleTimer > 0 && !player.isUserControlledCharacter)) {\r\n    const starTransitionDuration = 500;\r\n    let starElapsedTime = currentTime - player.flameTransitionStartTime;\r\n    let animatationFrame = starElapsedTime % starTransitionDuration;\r\n    if (!player.starTransitionStartTime || starElapsedTime >= starTransitionDuration) {\r\n      player.starTransitionStartTime = currentTime;\r\n    }\r\n    applyGlowingEffect(ctx, \"gold\", \"gold\", \"white\", starTransitionDuration, animatationFrame);\r\n  }\r\n\r\n  // if (currentTime % 2000 < 1900) {\r\n  //   drawShipOutline(ctx, player, playerCenterXScreenCoords, playerCenterYScreenCoords, points, angle, currentTime, color);\r\n  // } else {\r\n  OGdrawShipOutline(ctx, player, playerCenterXScreenCoords, playerCenterYScreenCoords, points, angle, currentTime, color);\r\n  // }\r\n  ctx.globalAlpha = 1;\r\n  ctx.shadowBlur = 0;\r\n  ctx.shadowColor = \"transparent\";\r\n\r\n  //draw mouse pos for debug\r\n  // ctx.beginPath();\r\n  // ctx.arc(player.mousePosX - camX, player.mousePosY - camY, 55, 0, Math.PI * 2);\r\n  // ctx.closePath();\r\n  // ctx.fill();\r\n  // Draw name and invincibility gauge\r\n  drawNameAndInvincibility(ctx, player, playerCenterXScreenCoords, playerCenterYScreenCoords, name, color);\r\n\r\n  if (player.recentScoreTicks > 0) {\r\n    let scoreInfoYAdjust = 0;\r\n    if (player.invincibleTimer > 0) {\r\n      scoreInfoYAdjust = 20;\r\n    }\r\n    drawScoreInfo(ctx, player, player.recentScoreText, camX, camY + scoreInfoYAdjust);\r\n    drawKillInfo(ctx, player, player.recentKillScoreText, camX, camY + scoreInfoYAdjust);\r\n  }\r\n}\r\n\r\n// Helper function to calculate shadow position for a point\r\nfunction calculateShadowPosition(silhouetteX, silhouetteY, lightSourceX, lightSourceY) {\r\n  return {\r\n    x: silhouetteX + (lightSourceX - silhouetteX),\r\n    y: silhouetteY + (lightSourceY - silhouetteY),\r\n  };\r\n}\r\n\r\n// Helper function to draw the ship's silhouette\r\nfunction drawSilhouette(ctx, silhouettePoints) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(silhouettePoints[0].x, silhouettePoints[0].y);\r\n\r\n  for (let i = 1; i < silhouettePoints.length; i++) {\r\n    ctx.lineTo(silhouettePoints[i].x, silhouettePoints[i].y);\r\n  }\r\n\r\n  ctx.closePath();\r\n  ctx.fillStyle = \"gray\"; // Fill color for the silhouette\r\n  ctx.fill();\r\n}\r\n\r\n// Helper function to draw the flame effect\r\nfunction drawFlame(ctx, centerX, centerY, flameOffsetAngle, flameSize) {\r\n  // Calculate the position for the flame relative to the ship's center\r\n  const flameOffsetX = -Math.sin(flameOffsetAngle) * 0; // Adjust the offset as needed\r\n  const flameOffsetY = Math.cos(flameOffsetAngle) * 0; // Adjust the offset as needed\r\n  const flameX = centerX + flameOffsetX;\r\n  const flameY = centerY + flameOffsetY;\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(flameX, flameY);\r\n\r\n  // Calculate the flame points relative to the flame position\r\n  for (let i = 0; i < 3; i++) {\r\n    // const adjustedAngle = flameOffsetAngle + i * 0.38; // Adjust the angle of the flame\r\n    const adjustedAngle = flameOffsetAngle + i * 0.45; // Adjust the angle of the flame\r\n    const flameEndX = flameX - Math.cos(adjustedAngle) * flameSize;\r\n    const flameEndY = flameY - Math.sin(adjustedAngle) * flameSize;\r\n    ctx.lineTo(flameEndX, flameEndY);\r\n  }\r\n\r\n  ctx.closePath();\r\n  // Create a radial gradient for the flame effect\r\n  const gradient = ctx.createRadialGradient(flameX, flameY, 0, flameX, flameY, flameSize);\r\n  gradient.addColorStop(0, \"rgba(255, 165, 0, 1)\"); // Adjust color and transparency\r\n  gradient.addColorStop(1, \"rgba(255, 0, 0, 0.1)\"); // Adjust color and transparency\r\n\r\n  // Use the gradient as the fill style for the flame\r\n  ctx.fillStyle = gradient;\r\n  ctx.fill();\r\n}\r\n\r\nfunction OGdrawShipOutline(ctx, player, playerCenterXScreenCoords, playerCenterYScreenCoords, points, angle, currentTime, color) {\r\n  ctx.beginPath();\r\n\r\n  let rotatedPoint = rotateAndScalePoint(points[0].x, points[0].y, angle, shipScale);\r\n  ctx.moveTo(playerCenterXScreenCoords + rotatedPoint.x, playerCenterYScreenCoords + rotatedPoint.y);\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n    rotatedPoint = rotateAndScalePoint(points[i].x, points[i].y, angle, shipScale);\r\n    ctx.lineTo(playerCenterXScreenCoords + rotatedPoint.x, playerCenterYScreenCoords + rotatedPoint.y);\r\n  }\r\n\r\n  try {\r\n    if (typeof player.isInSpawnProtectionTime === \"function\") {\r\n      if (player.isInSpawnProtectionTime() && !(player.invincibleTimer > 10 || (player.invincibleTimer > 0 && !player.isUserControlledCharacter))) {\r\n        const transitionDuration = 20;\r\n        const elapsedTime = currentTime - player.starTransitionStartTime;\r\n        if (!player.starTransitionStartTime || elapsedTime >= transitionDuration) {\r\n          player.starTransitionStartTime = currentTime;\r\n          player.starTransitionStartColor = color;\r\n        }\r\n        applyGlowingEffect(ctx, \"white\", \"white\", player.starTransitionStartColor, transitionDuration, elapsedTime);\r\n      } else {\r\n        // ctx.strokeStyle = color;\r\n      }\r\n    } else {\r\n      // console.log(\"isInSpawnProtectionTime method does not exist\");\r\n    }\r\n  } catch (error) {\r\n    console.log(\"An error occurred:\", error);\r\n  }\r\n\r\n  ctx.closePath();\r\n  ctx.fillStyle = ctx.strokeStyle;\r\n  ctx.fill();\r\n\r\n  ctx.strokeStyle = \"white\";\r\n  ctx.lineWidth = 5;\r\n  ctx.stroke();\r\n}\r\n\r\nfunction newDrawShipOutline(ctx, player, playerCenterXScreenCoords, playerCenterYScreenCoords, points, angle, currentTime, color) {\r\n  ctx.beginPath();\r\n  ctx.fillStyle = color;\r\n  ctx.strokeStyle = \"white\";\r\n  ctx.lineWidth = 5;\r\n\r\n  // Define carrot shape points relative to the carrot's center\r\n  const carrotPoints = [\r\n    { x: 0, y: -25 }, // Tip of the carrot\r\n    { x: -12, y: 0 }, // Left side of the carrot body\r\n    { x: -8, y: 25 }, // Left bottom edge of the carrot body\r\n    { x: 8, y: 25 }, // Right bottom edge of the carrot body\r\n    { x: 15, y: 0 }, // Right side of the carrot body\r\n    { x: 12, y: -25 }, // Back to the tip of the carrot\r\n  ];\r\n\r\n  // Rotate and scale carrot points\r\n  for (let i = 0; i < carrotPoints.length; i++) {\r\n    const rotatedPoint = rotateAndScalePoint(carrotPoints[i].x, carrotPoints[i].y, angle, shipScale);\r\n    carrotPoints[i] = {\r\n      x: playerCenterXScreenCoords + rotatedPoint.x,\r\n      y: playerCenterYScreenCoords + rotatedPoint.y,\r\n    };\r\n  }\r\n\r\n  // Create a smooth carrot shape using Bezier curves\r\n  ctx.moveTo(carrotPoints[0].x, carrotPoints[0].y);\r\n  ctx.bezierCurveTo(carrotPoints[1].x, carrotPoints[1].y, carrotPoints[2].x, carrotPoints[2].y, carrotPoints[3].x, carrotPoints[3].y);\r\n  ctx.bezierCurveTo(carrotPoints[4].x, carrotPoints[4].y, carrotPoints[5].x, carrotPoints[5].y, carrotPoints[0].x, carrotPoints[0].y);\r\n\r\n  ctx.closePath();\r\n  ctx.fillStyle = color;\r\n  ctx.lineWidth = 2;\r\n  ctx.fill();\r\n  ctx.stroke();\r\n}\r\n// ctx.bezierCurveTo(10, 20, 10, 0, 0, -25);\r\n// ctx.bezierCurveTo(10, 0, 5, -20, -5, -20);\r\nfunction drawShipOutline(ctx, player, playerCenterXScreenCoords, playerCenterYScreenCoords, points, angle, currentTime, color) {\r\n  ctx.save();\r\n  ctx.translate(playerCenterXScreenCoords, playerCenterYScreenCoords);\r\n  ctx.rotate(angle);\r\n  ctx.strokeStyle = \"orange\";\r\n  // Draw carrot body\r\n\r\n  ctx.beginPath();\r\n  // ctx.moveTo(0, -25);\r\n  // ctx.bezierCurveTo(-15, 0, -5, 20, 0, 40); // Adjusted control points for the left side\r\n  // ctx.bezierCurveTo(5, 20, 15, 0, 0, -25); // Adjusted control points for the right side\r\n  // ctx.moveTo(0, -25);\r\n  // ctx.bezierCurveTo(5, 20, 15, 0, 0, -25); // Adjusted control points for the right side\r\n  // ctx.bezierCurveTo(-15, 0, -5, 20, 0, 40); // Adjusted control points for the left side\r\n  ctx.moveTo(0, 40);\r\n  ctx.bezierCurveTo(30, 20, 25, 40, 0, -25); // Adjusted control points for the right side\r\n  ctx.bezierCurveTo(-25, 40, -30, 20, 0, 40); // Adjusted control points for the left side\r\n\r\n  ctx.closePath();\r\n  // Add details like windows, lights, etc.\r\n  // Example: ctx.arc(x, y, radius, 0, Math.PI * 2);\r\n\r\n  // Apply gradients or textures for a more dynamic look\r\n  const gradient = ctx.createLinearGradient(-10, -25, 10, 20);\r\n  gradient.addColorStop(0, \"orange\");\r\n  gradient.addColorStop(0.8, \"orange\");\r\n  gradient.addColorStop(1, \"green\");\r\n  ctx.fillStyle = gradient;\r\n\r\n  // Apply shadows and highlights for depth\r\n  ctx.shadowBlur = 10;\r\n  ctx.shadowColor = \"rgba(0, 0, 0, 0.3)\";\r\n\r\n  // Draw the spaceship\r\n  ctx.fill();\r\n  ctx.strokeStyle = \"white\";\r\n  ctx.lineWidth = 2;\r\n  ctx.stroke();\r\n\r\n  ctx.restore();\r\n}\r\n\r\n// Helper function to draw the name and invincibility gauge\r\nfunction drawNameAndInvincibility(ctx, player, centerX, centerY, name, color) {\r\n  const namePositionY = centerY - 15;\r\n  const invincibleGaugePositionY = centerY - 25;\r\n\r\n  ctx.fillStyle = getComplementaryColor(color);\r\n  ctx.strokeStyle = getComplementaryColor(color);\r\n  ctx.font = \"24px Arial\";\r\n  ctx.textAlign = \"center\";\r\n  ctx.fillText(name, centerX, namePositionY);\r\n\r\n  if (player.invincibleTimer > 0) {\r\n    drawInvincibilityGauge(ctx, player, centerX, invincibleGaugePositionY, 70, 15, 2);\r\n  }\r\n}\r\n\r\nfunction drawScoreInfo(ctx, player, score, camX, camY) {\r\n  let centerX = player.x;\r\n  let centerY = player.y;\r\n  // Calculate position for the score (above the unrotated center of the ship)\r\n  const scorePositionX = centerX - camX;\r\n  const scorePositionY = centerY - camY - 35;\r\n\r\n  // Draw the score\r\n  ctx.fillStyle = getComplementaryColor(player.color);\r\n  ctx.font = \"25px Arial\";\r\n  ctx.textAlign = \"center\";\r\n  ctx.fillText(score, scorePositionX, scorePositionY);\r\n}\r\nfunction drawKillInfo(ctx, player, killText, camX, camY) {\r\n  let centerX = player.x;\r\n  let centerY = player.y;\r\n  // Calculate position for the score (above the unrotated center of the ship)\r\n  const scorePositionX = centerX - camX;\r\n  const scorePositionY = centerY - camY - 55;\r\n\r\n  // Draw the score\r\n  ctx.fillStyle = getComplementaryColor(player.color);\r\n  ctx.font = \"25px Arial\";\r\n  ctx.textAlign = \"center\";\r\n  ctx.fillText(killText, scorePositionX, scorePositionY);\r\n}\r\n","export const spikeyBallPoints = [];\r\nimport { pilots } from \"./gameLogic.js\";\r\n// import { ctx } from \"./astroids.js\";\r\nexport const loreTablet = {\r\n  x: 0,\r\n  y: -300,\r\n  width: 450,\r\n  height: 450,\r\n  image: new Image(),\r\n};\r\n\r\nexport function centerPilots(canvas) {\r\n  // Calculate the horizontal gap between pilots (excluding the central gap)\r\n  const gapBetweenPilots = 20; // Gap between all pilots except the central gap\r\n  const centralGap = 330; // Width of the central gap\r\n\r\n  // Calculate the total width occupied by all pilots (excluding the central gap)\r\n  let totalWidth = 0;\r\n\r\n  for (let i = 0; i < pilots.length; i++) {\r\n    totalWidth += pilots[i].width;\r\n  }\r\n\r\n  // Calculate the total width including the central gap\r\n  totalWidth += centralGap;\r\n\r\n  // Calculate the starting x-position to center the pilots\r\n  const startX = (canvas.width - totalWidth) / 2 + (gapBetweenPilots * 3) / 2;\r\n\r\n  // Calculate the y-position for all pilots\r\n  const yPosition = canvas.height / 6;\r\n\r\n  // Calculate the index at which to start adding the central gap\r\n  const startIndexForCentralGap = Math.floor(pilots.length / 2) - 1;\r\n\r\n  // Set the positions for each pilot, taking the central gap into account\r\n  let currentX = startX;\r\n  for (let i = 0; i < pilots.length; i++) {\r\n    const pilot = pilots[i];\r\n    pilot.x = currentX;\r\n\r\n    if (i === startIndexForCentralGap) {\r\n      // Leave the central gap after half of the pilots\r\n      currentX += centralGap;\r\n    } else if (i < pilots.length - 1) {\r\n      // Add the regular gap between pilots\r\n      currentX += pilot.width + gapBetweenPilots;\r\n    }\r\n\r\n    pilot.y = yPosition;\r\n  }\r\n\r\n  // Position the lore tablet\r\n  loreTablet.x = canvas.width / 2 - loreTablet.width / 2;\r\n  loreTablet.y = 359;\r\n}\r\n\r\nexport function setupPilotsImages(canvas) {\r\n  centerPilots(canvas);\r\n}\r\n\r\n// initializes the canvas and sets up basic event listeners\r\nexport function setupCanvas() {\r\n  const canvas = document.getElementById(\"gameCanvas\");\r\n  const ctx = canvas.getContext(\"2d\");\r\n  setClip(ctx);\r\n\r\n  canvas.style.position = \"absolute\"; // positioning the canvas to start from the top left corner.\r\n  canvas.width = window.innerWidth;\r\n  canvas.height = window.innerHeight;\r\n  // Disable the default context menu on the canvas\r\n  canvas.addEventListener(\"contextmenu\", function (e) {\r\n    e.preventDefault();\r\n  });\r\n\r\n  // Adding event listener to handle window resizing\r\n  window.addEventListener(\"resize\", function () {\r\n    canvas.width = window.innerWidth;\r\n    canvas.height = window.innerHeight;\r\n    setClip(ctx);\r\n    //since we can now scale the canvas need to adjust the positions\r\n    centerPilots(canvas);\r\n  });\r\n\r\n  return { canvas, ctx };\r\n}\r\n\r\nfunction setClip(ctx) {\r\n  //try this clip to prevent drawing outside of canvas to see if it improves efficiency\r\n  ctx.beginPath();\r\n  ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n  ctx.clip();\r\n}\r\n// Rotate a point (x, y) by a certain angle\r\nexport function rotatePoint(x, y, angle) {\r\n  return {\r\n    x: x * Math.cos(angle) - y * Math.sin(angle),\r\n    y: x * Math.sin(angle) + y * Math.cos(angle),\r\n  };\r\n}\r\n\r\nexport function rotateAndScalePoint(x, y, angle, scale) {\r\n  return {\r\n    x: (x * Math.cos(angle) - y * Math.sin(angle)) * scale,\r\n    y: (x * Math.sin(angle) + y * Math.cos(angle)) * scale,\r\n  };\r\n}\r\n// Interpolate between two color components (e.g., red, green, blue)\r\nexport function interpolate(start, end, progress) {\r\n  return start + (end - start) * progress;\r\n}\r\n\r\nexport function drawRoundedRectangle(ctx, buttonX, buttonY, buttonWidth, buttonHeight, radius) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(buttonX + radius, buttonY);\r\n  ctx.lineTo(buttonX + buttonWidth - radius, buttonY);\r\n  ctx.arcTo(buttonX + buttonWidth, buttonY, buttonX + buttonWidth, buttonY + radius, radius);\r\n  ctx.lineTo(buttonX + buttonWidth, buttonY + buttonHeight - radius);\r\n  ctx.arcTo(buttonX + buttonWidth, buttonY + buttonHeight, buttonX + buttonWidth - radius, buttonY + buttonHeight, radius);\r\n  ctx.lineTo(buttonX + radius, buttonY + buttonHeight);\r\n  ctx.arcTo(buttonX, buttonY + buttonHeight, buttonX, buttonY + buttonHeight - radius, radius);\r\n  ctx.lineTo(buttonX, buttonY + radius);\r\n  ctx.arcTo(buttonX, buttonY, buttonX + radius, buttonY, radius);\r\n  ctx.closePath();\r\n  ctx.fill();\r\n}\r\n\r\nexport function setupSpikeyBallPoints() {\r\n  const numSpikes = 20; // Adjust the number of spikes as needed\r\n  const spikeLength = 15; // Adjust the length of spikes as needed\r\n  const ballRadius = 40; // Adjust the radius of the ball as needed\r\n\r\n  for (let i = 0; i < numSpikes; i++) {\r\n    const angle = (Math.PI * 2 * i) / numSpikes;\r\n    const x = Math.cos(angle) * ballRadius;\r\n    const y = Math.sin(angle) * ballRadius;\r\n    spikeyBallPoints.push({ x, y });\r\n\r\n    // Calculate the spike endpoint\r\n    const spikeX = x + Math.cos(angle) * spikeLength;\r\n    const spikeY = y + Math.sin(angle) * spikeLength;\r\n    spikeyBallPoints.push({ x: spikeX, y: spikeY });\r\n  }\r\n\r\n  // Close the shape by adding the first point again\r\n  spikeyBallPoints.push({ x: spikeyBallPoints[0].x, y: spikeyBallPoints[0].y });\r\n}\r\n\r\n// Function to apply a gravity warp effect only inside a specified circle\r\nexport function applyGravityWarpEffect(ctx, centerX, centerY, radius, coneAngle, direction, resolution = 5) {\r\n  const xMin = centerX - radius;\r\n  const yMin = centerY - radius;\r\n  const xMax = centerX + radius;\r\n  const yMax = centerY + radius;\r\n\r\n  const imageData = ctx.getImageData(xMin, yMin, xMax - xMin, yMax - yMin);\r\n  const data = imageData.data;\r\n\r\n  function isInsideCircle(x, y) {\r\n    const dx = x - centerX;\r\n    const dy = y - centerY;\r\n    return dx * dx + dy * dy <= radius * radius;\r\n  }\r\n\r\n  function isInsideCone(x, y, coneAngle, direction) {\r\n    const dx = x - centerX;\r\n    const dy = y - centerY;\r\n    const angleToPoint = Math.atan2(dy, dx);\r\n    const halfCone = coneAngle / 2;\r\n    const minAngle = normalizeAngle(direction - halfCone);\r\n    const maxAngle = normalizeAngle(direction + halfCone);\r\n\r\n    const normalizedAngleToPoint = normalizeAngle(angleToPoint);\r\n\r\n    if (minAngle <= maxAngle) {\r\n      return normalizedAngleToPoint >= minAngle && normalizedAngleToPoint <= maxAngle;\r\n    } else {\r\n      return normalizedAngleToPoint >= minAngle || normalizedAngleToPoint <= maxAngle;\r\n    }\r\n  }\r\n\r\n  // Helper function to normalize angles to the range [0, 2*PI]\r\n  function normalizeAngle(angle) {\r\n    while (angle < 0) {\r\n      angle += 2 * Math.PI;\r\n    }\r\n    while (angle >= 2 * Math.PI) {\r\n      angle -= 2 * Math.PI;\r\n    }\r\n    return angle;\r\n  }\r\n\r\n  for (let y = 0; y < imageData.height; y += resolution) {\r\n    for (let x = 0; x < imageData.width; x += resolution) {\r\n      const index = (y * imageData.width + x) * 4;\r\n\r\n      if (\r\n        (isInsideCircle(x + xMin, y + yMin) && coneAngle == Math.PI * 2) ||\r\n        (isInsideCircle(x + xMin, y + yMin) && isInsideCone(x + xMin, y + yMin, coneAngle, direction))\r\n      ) {\r\n        // Apply the gravity warp effect inside the cone\r\n        data[index] = 255 - data[index]; // R\r\n        data[index + 1] = 255 - data[index + 1]; // G\r\n        data[index + 2] = 255 - data[index + 2]; // B\r\n      }\r\n    }\r\n  }\r\n\r\n  ctx.putImageData(imageData, xMin, yMin);\r\n}\r\n\r\nexport function drawArrow(ctx, tail, angle, length, arrowheadLength, arrowheadAngle = Math.PI / 8) {\r\n  let head = {};\r\n\r\n  head.x = tail.x + length * Math.cos(angle);\r\n  head.y = tail.y + length * Math.sin(angle);\r\n  ctx.moveTo(head.x, head.y);\r\n  ctx.lineTo(tail.x, tail.y);\r\n\r\n  //const angle = Math.atan2(head.y - tail.y, head.x - tail.x);\r\n  const arrowhead1X = head.x - arrowheadLength * Math.cos(angle + arrowheadAngle);\r\n  const arrowhead1Y = head.y - arrowheadLength * Math.sin(angle + arrowheadAngle);\r\n  const arrowhead2X = head.x - arrowheadLength * Math.cos(angle - arrowheadAngle);\r\n  const arrowhead2Y = head.y - arrowheadLength * Math.sin(angle - arrowheadAngle);\r\n\r\n  ctx.moveTo(head.x, head.y);\r\n  ctx.lineTo(arrowhead1X, arrowhead1Y);\r\n  ctx.moveTo(head.x, head.y);\r\n  ctx.lineTo(arrowhead2X, arrowhead2Y);\r\n}\r\n\r\nfunction normalizeAngle(angle) {\r\n  return ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);\r\n}\r\n\r\nfunction isAngleInCone(angle, startAngle, endAngle) {\r\n  if (startAngle > endAngle) {\r\n    // If startAngle is greater than endAngle, it means the cone crosses the 0/2 line.\r\n    // In this case, we need to check if the angle is less than endAngle or greater than startAngle.\r\n    return angle <= endAngle || angle >= startAngle;\r\n  } else {\r\n    // If startAngle is less than endAngle, we can simply check if the angle is within this range.\r\n    return angle >= startAngle && angle <= endAngle;\r\n  }\r\n}\r\n\r\nexport function nameToRGBFullFormat(colorName) {\r\n  let rgbColor = nameToRGB(colorName);\r\n  // Match the RGB values using a regular expression\r\n  const match = rgbColor.match(/\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\r\n\r\n  if (match) {\r\n    const r = parseInt(match[1], 10);\r\n    const g = parseInt(match[2], 10);\r\n    const b = parseInt(match[3], 10);\r\n\r\n    return {\r\n      r: r,\r\n      g: g,\r\n      b: b,\r\n    };\r\n  }\r\n\r\n  return null; // Return null if the input is not a valid RGB color string\r\n}\r\n\r\nexport function nameToRGB(colorName) {\r\n  const colorMap = {\r\n    red: \"rgb(255, 0, 0)\",\r\n    green: \"rgb(0, 255, 0)\",\r\n    blue: \"rgb(0, 0, 255)\",\r\n    orange: \"rgb(255, 165, 0)\",\r\n    springgreen: \"rgb(0, 255, 127)\",\r\n    lime: \"rgb(0, 255, 0)\",\r\n    cyan: \"rgb(0, 255, 255)\",\r\n    indigo: \"rgb(75, 0, 130)\",\r\n    purple: \"rgb(128, 0, 128)\",\r\n    pink: \"rgb(255, 192, 203)\",\r\n    mediumvioletred: \"rgb(199, 21, 133)\",\r\n    violet: \"rgb(238, 130, 238)\",\r\n    maroon: \"rgb(128, 0, 0)\",\r\n    crimson: \"rgb(220, 20, 60)\",\r\n    white: \"rgb(255, 255, 255)\",\r\n    gold: \"rgb(255,215,0)\",\r\n    orangered: \"rgb(255, 69, 0)\",\r\n  };\r\n  if (colorName == null) {\r\n    colorName = \"blue\";\r\n  }\r\n  // Look up the color name in the map and return the corresponding RGB value\r\n  return colorMap[colorName.toLowerCase()] || null;\r\n}\r\n\r\nexport function getComplementaryColor(color) {\r\n  // Assuming color is in the format \"rgb(r, g, b)\"\r\n  let match = /rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/.exec(color);\r\n\r\n  if (!match) {\r\n    color = nameToRGB(color);\r\n    match = /rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/.exec(color);\r\n    if (!match) {\r\n      // Invalid color format\r\n      return null;\r\n    }\r\n  }\r\n\r\n  const r = parseInt(match[1]);\r\n  const g = parseInt(match[2]);\r\n  const b = parseInt(match[3]);\r\n\r\n  // Calculate the complementary color by subtracting each RGB component from 255\r\n  const complementaryR = 255 - r;\r\n  const complementaryG = 255 - g;\r\n  const complementaryB = 255 - b;\r\n\r\n  // Return the complementary color in \"rgb(r, g, b)\" format\r\n  return `rgb(${complementaryR},${complementaryG},${complementaryB})`;\r\n}\r\n\r\n// Function to determine if a player should be skipped\r\nexport function shouldSkipPlayer(player) {\r\n  return (\r\n    !player ||\r\n    !player.isPlaying ||\r\n    player.isDead ||\r\n    (!player.isLocal && !player.isBot && player.timeSinceSentMessageThatWasReceived > 120) ||\r\n    (player.name === \"\" && player.pilot === \"\")\r\n  );\r\n}\r\n\r\nexport function applyGlowingEffect(ctx, glowColor, transitionColor, starTransitionStartColor, transitionDuration, elapsedTime, opacity = 1) {\r\n  ctx.shadowBlur = 10;\r\n  ctx.shadowColor = glowColor;\r\n\r\n  const colorProgress = Math.min(1, elapsedTime / transitionDuration);\r\n  transitionColor = nameToRGBFullFormat(transitionColor);\r\n  starTransitionStartColor = nameToRGBFullFormat(starTransitionStartColor);\r\n  const r = Math.floor(interpolate(starTransitionStartColor.r, transitionColor.r, colorProgress));\r\n  const g = Math.floor(interpolate(starTransitionStartColor.g, transitionColor.g, colorProgress));\r\n  const b = Math.floor(interpolate(starTransitionStartColor.b, transitionColor.b, colorProgress));\r\n\r\n  // Apply opacity to the glowing effect\r\n  const interpolatedColor = `rgba(${r},${g},${b},${opacity})`;\r\n  ctx.strokeStyle = interpolatedColor;\r\n  ctx.fillStyle = interpolatedColor;\r\n}\r\n\r\nexport function drawExplosion(ctx, camX, camY, explosionEffect) {\r\n  const currentTime = Date.now();\r\n  const elapsedTime = currentTime - explosionEffect.startTime;\r\n  const animationDuration = explosionEffect.duration;\r\n  const numFrames = 10;\r\n  const frameDuration = animationDuration / numFrames;\r\n  const frameIndex = Math.floor(elapsedTime / frameDuration);\r\n  const maxRadius = explosionEffect.maxRadius;\r\n\r\n  if (frameIndex < numFrames) {\r\n    const currentRadius = (frameIndex / numFrames) * maxRadius;\r\n\r\n    ctx.beginPath();\r\n    ctx.arc(explosionEffect.x - camX, explosionEffect.y - camY, currentRadius, 0, Math.PI * 2);\r\n    ctx.fillStyle = explosionEffect.color;\r\n    ctx.fill();\r\n\r\n    ctx.strokeStyle = \"rgba(255, 0, 0, 0.5)\";\r\n    ctx.lineWidth = 2;\r\n    ctx.stroke();\r\n  }\r\n}\r\n","import { Player } from \"./player.js\";\r\nimport { player } from \"./main.js\";\r\nimport { isPlayerMasterPeer } from \"./connectionHandlers.js\";\r\nimport { sendRemoveEntityUpdate } from \"./sendData.js\";\r\n\r\nexport let forces = [];\r\nexport let effects = [];\r\n\r\nexport function setForces(newForces) {\r\n  if (newForces !== forces) {\r\n    //update original array\r\n    forces.length = 0;\r\n    forces.push(...newForces);\r\n  }\r\n}\r\n\r\nexport const EffectType = {\r\n  EXPLOSION: \"explosion\",\r\n};\r\n\r\nexport const MineType = {\r\n  REGULAR: \"regular\",\r\n  TRAIL: \"trail\",\r\n  FREE_MINE: \"freemine\",\r\n};\r\n\r\nexport class Entity {\r\n  constructor(id = null, x = null, y = null) {\r\n    this.id = id;\r\n    if (this.id == null) {\r\n      this.id = Math.floor(Math.random() * 10000);\r\n    }\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n}\r\n\r\nexport const ForceType = {\r\n  POINT: \"point\",\r\n  DIRECTIONAL: \"directional\",\r\n};\r\n\r\nexport class ForceArea extends Entity {\r\n  constructor(\r\n    id = null,\r\n    x = null,\r\n    y = null,\r\n    force = 1,\r\n    duration = 200,\r\n    radius = 100,\r\n    isAttractive,\r\n    color = \"red\",\r\n    tracks,\r\n    coneAngle = Math.PI * 2,\r\n    direction = 0,\r\n    type = ForceType.POINT,\r\n    width = 100,\r\n    length = 100,\r\n    effect = false\r\n  ) {\r\n    super(id, x, y);\r\n    this.force = force;\r\n    this.duration = duration;\r\n    this.radius = radius;\r\n    this.isAttractive = isAttractive;\r\n    this.color = color;\r\n    this.tracks = tracks;\r\n    this.coneAngle = coneAngle;\r\n    this.direction = direction;\r\n    this.type = type;\r\n    this.width = width;\r\n    this.length = length;\r\n    this.effect = effect;\r\n  }\r\n  setDuration(newDuration) {\r\n    this.duration = newDuration;\r\n    if (this.duration < 1) {\r\n      // forces = forces.filter(function (element) {\r\n      setForces(\r\n        forces.filter(function (element) {\r\n          return element !== this;\r\n        }, this)\r\n      );\r\n      if (isPlayerMasterPeer(player)) {\r\n        sendRemoveEntityUpdate(\"removeForces\", [this]);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport class Enemy extends Entity {\r\n  constructor(id = null, x = null, y = null, duration = -1, radius = 20, color = \"red\") {\r\n    super(id, x, y);\r\n  }\r\n}\r\n\r\nexport class Effect extends Enemy {\r\n  constructor(id = null, x = null, y = null, duration = -1, radius = 20, color = \"red\", type = \"\") {\r\n    super(id, x, y, duration, radius, color);\r\n    this.duration = duration;\r\n    this.radius = radius;\r\n    this.color = color;\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nexport class Mine extends Enemy {\r\n  constructor(\r\n    id = null,\r\n    x = null,\r\n    y = null,\r\n    duration = -1,\r\n    radius = 20,\r\n    color = \"red\",\r\n    force = 0,\r\n    mineType = MineType.REGULAR,\r\n    hitFrame = -105,\r\n    playerId = \"\"\r\n  ) {\r\n    super(id, x, y, duration, radius, color);\r\n    this.duration = duration;\r\n    this.radius = radius;\r\n    this.color = color;\r\n    this.hitFrames = hitFrame;\r\n    this.force = force;\r\n    if (force != 0) {\r\n      this.createForce();\r\n    }\r\n    this.mineType = mineType;\r\n    this.playerId = playerId;\r\n  }\r\n  createForce() {\r\n    // Check if there is already a force with the same id\r\n    const existingForce = forces.find((force) => force.id === \"mine-\" + this.id);\r\n\r\n    if (!existingForce) {\r\n      // If no force with the same id exists, create a new one\r\n      if (this.force !== 0) {\r\n        let minesForce = new ForceArea(\"mine-\" + this.id, this.x, this.y, 0.3, 10, 200, this.force == 1, \"pink\", this);\r\n        //currently mine doesn't keep a reference to it's force, is that fine?\r\n        forces.push(minesForce);\r\n      }\r\n    } else {\r\n      existingForce.duration = 10;\r\n      existingForce.x = this.x;\r\n      existingForce.y = this.y;\r\n      //may need to update other properties in future if mine/ mine force behaviour change\r\n    }\r\n  }\r\n}\r\n\r\nexport class Trail extends Mine {\r\n  constructor(\r\n    id = null,\r\n    x = null,\r\n    y = null,\r\n    duration = -1,\r\n    radius = 20,\r\n    color = \"red\",\r\n    force = 0,\r\n    mineType = MineType.TRAIL,\r\n    hitFrame = -105,\r\n    playerId = \"\",\r\n    angle,\r\n    length,\r\n    width\r\n  ) {\r\n    super(id, x, y, duration, radius, color, force, mineType, hitFrame, playerId);\r\n    this.angle = angle;\r\n    this.length = length;\r\n    this.width = width;\r\n  }\r\n  createForce() {\r\n    super.createForce();\r\n  }\r\n}\r\n\r\nexport class FreeMine extends Mine {\r\n  constructor(\r\n    id = null,\r\n    x = null,\r\n    y = null,\r\n    duration = -1,\r\n    radius = 20,\r\n    color = \"red\",\r\n    force = 0,\r\n    mineType = MineType.FREE_MINE,\r\n    hitFrame = -105,\r\n    playerId = \"\",\r\n    angle,\r\n    points\r\n  ) {\r\n    super(id, x, y, duration, radius, color, force, mineType, hitFrame, playerId);\r\n    this.angle = angle;\r\n    this.points = points;\r\n  }\r\n  createForce() {\r\n    super.createForce();\r\n  }\r\n}\r\n\r\nexport class PowerUp extends Entity {\r\n  constructor(id = null, x = null, y = null, color = null, isStar = false, radius = 5, value = 1, force = 0) {\r\n    super(id, x, y);\r\n    this.color = color;\r\n    this.isStar = isStar;\r\n    this.radius = radius;\r\n    this.value = value;\r\n    this.hitFrames = -56;\r\n    this.force = force;\r\n    if (force != 0) {\r\n      this.createForce();\r\n    }\r\n  }\r\n\r\n  createForce() {\r\n    // Check if there is already a force with the same id\r\n    const existingForce = forces.find((force) => force.id === \"powerUp-\" + this.id);\r\n\r\n    if (!existingForce) {\r\n      // If no force with the same id exists, create a new one\r\n      if (this.force !== 0) {\r\n        let powerUpForce = new ForceArea(\"powerUp-\" + this.id, this.x, this.y, 0.3, 10, 200, this.force == 1, \"yellow\", this);\r\n        forces.push(powerUpForce);\r\n      }\r\n    } else {\r\n      existingForce.duration = 10;\r\n      existingForce.x = this.x;\r\n      existingForce.y = this.y;\r\n      //may need to update other properties in future behaviour changes\r\n    }\r\n  }\r\n}\r\n\r\nexport function createForceFromObject(obj) {\r\n  //why is tracks a new player not a found one?\r\n  let tracks = null;\r\n  if (obj.tracks != null) {\r\n    tracks = new Player(\r\n      obj.tracks.id,\r\n      obj.tracks.x,\r\n      obj.tracks.y,\r\n      obj.tracks.powerUps,\r\n      obj.tracks.color,\r\n      obj.tracks.angle,\r\n      obj.tracks.pilot,\r\n      obj.tracks.name,\r\n      obj.tracks.isPlaying,\r\n      obj.tracks.isUserControlledCharacter\r\n    );\r\n  }\r\n  let force = new ForceArea(\r\n    obj.id,\r\n    obj.x,\r\n    obj.y,\r\n    obj.force,\r\n    obj.duration,\r\n    obj.radius,\r\n    obj.isAttractive,\r\n    obj.color,\r\n    tracks,\r\n    obj.coneAngle,\r\n    obj.direction,\r\n    obj.type,\r\n    obj.width,\r\n    obj.length\r\n  );\r\n  force.numberArrowsEachSide = obj.numberArrowsEachSide;\r\n  force.numberArrowsDeep = obj.numberArrowsDeep;\r\n  return force;\r\n}\r\nexport function createMineFromObject(obj) {\r\n  let mine = new Mine(obj.id, obj.x, obj.y, obj.duration, obj.radius, obj.color, obj.force, obj.mineType, obj.hitFrame, obj.playerId);\r\n  return mine;\r\n}\r\nexport function createTrailFromObject(obj) {\r\n  let trail = new Trail(\r\n    obj.id,\r\n    obj.x,\r\n    obj.y,\r\n    obj.duration,\r\n    obj.radius,\r\n    obj.color,\r\n    obj.force,\r\n    obj.mineType,\r\n    obj.hitFrame,\r\n    obj.playerId,\r\n    obj.angle,\r\n    obj.length,\r\n    obj.width\r\n  );\r\n  return trail;\r\n}\r\nexport function createFreeMineFromObject(obj) {\r\n  let freeMine = new FreeMine(\r\n    obj.id,\r\n    obj.x,\r\n    obj.y,\r\n    obj.duration,\r\n    obj.radius,\r\n    obj.color,\r\n    obj.force,\r\n    obj.mineType,\r\n    obj.hitFrame,\r\n    obj.playerId,\r\n    obj.points,\r\n    obj.angle\r\n  );\r\n  return freeMine;\r\n}\r\nexport function createPowerUpFromObject(obj) {\r\n  let powerUp = new PowerUp(obj.id, obj.x, obj.y, obj.color, obj.isStar, obj.radius, obj.value);\r\n  return powerUp;\r\n}\r\nexport function createEffectFromObject(obj) {\r\n  let effect = new Effect(obj.id, obj.x, obj.y, obj.duration, obj.radius, obj.color, obj.type);\r\n  return effect;\r\n}\r\n\r\nexport function setEffects(newEffects) {\r\n  if (newEffects !== effects) {\r\n    //update original array while keeping the reference\r\n    effects.length = 0;\r\n    effects.push(...newEffects);\r\n  }\r\n}\r\n","let lastSentMasterMineData = [];\r\nlet lastSentGlobalPowerUps = [];\r\nlet lastSentForces = [];\r\nlet lastSentEffects = [];\r\nimport { MineType, Trail, FreeMine } from \"./entities.js\";\r\n\r\nexport function serializeForces(forces, onlyChangedData = false) {\r\n  if (onlyChangedData) {\r\n    // Serialize and return only the changed forces\r\n    const changedForceData = forces\r\n      .map((currentForce) => {\r\n        const lastSentForceData = lastSentForces.find((lastForceData) => lastForceData.id === currentForce.id);\r\n        const serializedForce = serializeForce(currentForce);\r\n\r\n        // Compare the serialized data of the current force with the last sent data\r\n        if (!lastSentForceData || !isEqualForce(serializedForce, lastSentForceData)) {\r\n          // Update lastSentForces with the new serialized data if changed\r\n          lastSentForces = lastSentForces.map((force) => (force.id === currentForce.id ? serializedForce : force));\r\n          return serializedForce;\r\n        }\r\n\r\n        // Return null for forces that haven't changed\r\n        return null;\r\n      })\r\n      .filter((changedData) => changedData !== null);\r\n\r\n    return changedForceData;\r\n  } else {\r\n    // If onlyChangedData is false, update lastSentForces with the current serialized data\r\n    lastSentForces = forces.map(serializeForce);\r\n\r\n    // Serialize and return all forces\r\n    return lastSentForces;\r\n  }\r\n}\r\n\r\n// Define a function to serialize a force's data\r\nfunction serializeForce(force) {\r\n  return {\r\n    id: force.id,\r\n    x: force.x,\r\n    y: force.y,\r\n    force: force.force,\r\n    duration: force.duration,\r\n    radius: force.radius,\r\n    isAttractive: force.isAttractive,\r\n    color: force.color,\r\n    tracks: force.tracks,\r\n    coneAngle: force.coneAngle,\r\n    direction: force.direction,\r\n    type: force.type,\r\n    numberArrowsEachSide: force.numberArrowsEachSide,\r\n    numberArrowsDeep: force.numberArrowsDeep,\r\n    width: force.width,\r\n    length: force.length,\r\n  };\r\n}\r\n\r\n// compare force objects for equality\r\nfunction isEqualForce(force1, force2) {\r\n  const tolerance = 1e-4;\r\n  return (\r\n    Math.abs(force1.x - force2.x) < tolerance &&\r\n    Math.abs(force1.y - force2.y) < tolerance &&\r\n    force1.force === force2.force &&\r\n    //we won't sent if only the duration is different\r\n    // force1.duration === force2.duration &&\r\n    force1.radius === force2.radius &&\r\n    force1.isAttractive === force2.isAttractive &&\r\n    force1.color === force2.color &&\r\n    force1.tracks === force2.tracks &&\r\n    force1.coneAngle === force2.coneAngle &&\r\n    force1.direction === force2.direction &&\r\n    force1.type === force2.type &&\r\n    force1.numberArrowsEachSide === force2.numberArrowsEachSide &&\r\n    force1.numberArrowsDeep === force2.numberArrowsDeep &&\r\n    force1.width === force2.width &&\r\n    force1.length === force2.length\r\n  );\r\n}\r\n\r\nexport function serializeMines(mines, onlyChangedData = false, omitTrailMines = true) {\r\n  let minesToSerialize = null;\r\n  if (omitTrailMines) {\r\n    minesToSerialize = mines.filter((mine) => mine.mineType == MineType.REGULAR || mine.mineType == MineType.FREE_MINE);\r\n  } else {\r\n    minesToSerialize = mines;\r\n  }\r\n  if (onlyChangedData) {\r\n    // Serialize and return only the changed mines\r\n    const changedMineData = minesToSerialize\r\n      .map((currentMine) => {\r\n        const lastSentMineData = lastSentMasterMineData.find((lastMineData) => lastMineData.id === currentMine.id);\r\n        let serializedMine;\r\n        if (currentMine instanceof Trail) {\r\n          serializedMine = serializeTrail(currentMine);\r\n          // Compare the serialized data of the current mine with the last sent data\r\n          if (!lastSentMineData || !isEqualTrail(serializedMine, lastSentMineData)) {\r\n            // Update lastSentMasterMineData with the new serialized data if changed\r\n            lastSentMasterMineData = lastSentMasterMineData.map((mine) => (mine.id === currentMine.id ? serializedMine : mine));\r\n            return serializedMine;\r\n          }\r\n        } else if (currentMine instanceof FreeMine) {\r\n          serializedMine = serializeFreeMine(currentMine);\r\n\r\n          // Compare the serialized data of the current mine with the last sent data\r\n          if (!lastSentMineData || !isEqualFreeMine(serializedMine, lastSentMineData)) {\r\n            // Update lastSentMasterMineData with the new serialized data if changed\r\n            lastSentMasterMineData = lastSentMasterMineData.map((mine) => (mine.id === currentMine.id ? serializedMine : mine));\r\n            return serializedMine;\r\n          }\r\n        } else {\r\n          serializedMine = serializeMine(currentMine);\r\n\r\n          // Compare the serialized data of the current mine with the last sent data\r\n          if (!lastSentMineData || !isEqualMine(serializedMine, lastSentMineData)) {\r\n            // Update lastSentMasterMineData with the new serialized data if changed\r\n            lastSentMasterMineData = lastSentMasterMineData.map((mine) => (mine.id === currentMine.id ? serializedMine : mine));\r\n            return serializedMine;\r\n          }\r\n        }\r\n        // Return null for mines that haven't changed\r\n        return null;\r\n      })\r\n      .filter((changedData) => changedData !== null);\r\n\r\n    return changedMineData;\r\n  } else {\r\n    // If onlyChangedData is false, update lastSentMasterMineData with the current serialized data\r\n    lastSentMasterMineData = minesToSerialize.map(serializeMine);\r\n\r\n    // Serialize and return all mines\r\n    return lastSentMasterMineData;\r\n  }\r\n}\r\n\r\nfunction serializeMine(mine) {\r\n  return {\r\n    id: mine.id,\r\n    x: mine.x,\r\n    y: mine.y,\r\n    force: mine.force,\r\n    duration: mine.duration,\r\n    radius: mine.radius,\r\n    hitFrames: mine.hitFrames,\r\n    color: mine.color,\r\n    mineType: mine.mineType,\r\n    playerId: mine.playerId,\r\n  };\r\n}\r\n\r\n// Define a function to compare mine objects for equality\r\nfunction isEqualMine(mine1, mine2) {\r\n  const tolerance = 1e-4;\r\n  return (\r\n    Math.abs(mine1.x - mine2.x) < tolerance &&\r\n    Math.abs(mine1.y - mine2.y) < tolerance &&\r\n    mine1.force === mine2.force &&\r\n    mine1.duration === mine2.duration &&\r\n    mine1.radius === mine2.radius &&\r\n    mine1.hitFrames === mine2.hitFrames &&\r\n    mine1.color === mine2.color &&\r\n    mine1.mineType === mine2.mineType &&\r\n    mine1.playerId === mine2.playerId\r\n  );\r\n}\r\n\r\nfunction serializeFreeMine(mine) {\r\n  return {\r\n    id: mine.id,\r\n    x: mine.x,\r\n    y: mine.y,\r\n    force: mine.force,\r\n    duration: mine.duration,\r\n    radius: mine.radius,\r\n    hitFrames: mine.hitFrames,\r\n    color: mine.color,\r\n    mineType: mine.mineType,\r\n    playerId: mine.playerId,\r\n    points: mine.points,\r\n    angle: mine.angle,\r\n  };\r\n}\r\n\r\n// Define a function to compare mine objects for equality\r\nfunction isEqualFreeMine(mine1, mine2) {\r\n  const tolerance = 1e-4;\r\n  return (\r\n    Math.abs(mine1.x - mine2.x) < tolerance &&\r\n    Math.abs(mine1.y - mine2.y) < tolerance &&\r\n    mine1.force === mine2.force &&\r\n    mine1.duration === mine2.duration &&\r\n    mine1.radius === mine2.radius &&\r\n    mine1.hitFrames === mine2.hitFrames &&\r\n    mine1.color === mine2.color &&\r\n    mine1.mineType === mine2.mineType &&\r\n    mine1.playerId === mine2.playerId &&\r\n    mine1.points === mine2.points &&\r\n    mine1.angle === mine2.angle\r\n  );\r\n}\r\n\r\nfunction serializeTrail(trail) {\r\n  return {\r\n    id: trail.id,\r\n    x: trail.x,\r\n    y: trail.y,\r\n    force: trail.force,\r\n    duration: trail.duration,\r\n    radius: trail.radius,\r\n    hitFrames: trail.hitFrames,\r\n    color: trail.color,\r\n    trail: trail.mineType,\r\n    playerId: trail.playerId,\r\n    angle: trail.angle,\r\n    length: trail.length,\r\n    width: trail.width,\r\n  };\r\n}\r\n\r\n// Define a function to compare mine objects for equality\r\nfunction isEqualTrail(trail1, trail2) {\r\n  const tolerance = 1e-4;\r\n  return (\r\n    Math.abs(trail1.x - trail2.x) < tolerance &&\r\n    Math.abs(trail1.y - trail2.y) < tolerance &&\r\n    trail1.force === trail2.force &&\r\n    trail1.duration === trail2.duration &&\r\n    trail1.radius === trail2.radius &&\r\n    trail1.hitFrames === trail2.hitFrames &&\r\n    trail1.color === trail2.color &&\r\n    trail1.mineType === trail2.mineType &&\r\n    trail1.playerId === trail2.playerId\r\n  );\r\n}\r\n\r\nexport function serializeGlobalPowerUps(globalPowerUps, onlyChangedData = false) {\r\n  if (onlyChangedData) {\r\n    // Serialize and return only the changed globalPowerUps\r\n    let changedGlobalPowerUpData = globalPowerUps\r\n      .map((currentPowerUp) => {\r\n        const lastSentPowerUpData = lastSentGlobalPowerUps.find((lastPowerUpData) => lastPowerUpData.id === currentPowerUp.id);\r\n        const serializedPowerUp = serializeGlobalPowerUp(currentPowerUp);\r\n\r\n        // Compare the serialized data of the current globalPowerUp with the last sent data\r\n        if (!lastSentPowerUpData || !isEqualGlobalPowerUp(serializedPowerUp, lastSentPowerUpData)) {\r\n          // Update lastSentGlobalPowerUps with the new serialized data if changed\r\n          lastSentGlobalPowerUps = lastSentGlobalPowerUps.map((powerUp) => (powerUp.id === currentPowerUp.id ? serializedPowerUp : powerUp));\r\n          return serializedPowerUp;\r\n        }\r\n\r\n        // Return null for globalPowerUps that haven't changed\r\n        return null;\r\n      })\r\n      .filter((changedData) => changedData !== null);\r\n    return changedGlobalPowerUpData;\r\n  } else {\r\n    // If onlyChangedData is false, update lastSentGlobalPowerUps with the current serialized data\r\n    lastSentGlobalPowerUps = globalPowerUps.map(serializeGlobalPowerUp);\r\n\r\n    // Serialize and return all globalPowerUps\r\n    return lastSentGlobalPowerUps;\r\n  }\r\n}\r\n\r\n// Define a function to serialize a globalPowerUp's data\r\nfunction serializeGlobalPowerUp(powerUp) {\r\n  return {\r\n    id: powerUp.id,\r\n    x: powerUp.x,\r\n    y: powerUp.y,\r\n    color: powerUp.color,\r\n    isStar: powerUp.isStar,\r\n    radius: powerUp.radius,\r\n    value: powerUp.value,\r\n    hitFrames: powerUp.hitFrames,\r\n  };\r\n}\r\n\r\n// Define a function to compare globalPowerUp objects for equality\r\nfunction isEqualGlobalPowerUp(powerUp1, powerUp2) {\r\n  const tolerance = 1e-4;\r\n  return (\r\n    Math.abs(powerUp1.x - powerUp2.x) < tolerance &&\r\n    Math.abs(powerUp1.y - powerUp2.y) < tolerance &&\r\n    powerUp1.color === powerUp2.color &&\r\n    powerUp1.isStar === powerUp2.isStar &&\r\n    powerUp1.radius === powerUp2.radius &&\r\n    powerUp1.value === powerUp2.value &&\r\n    powerUp1.hitFrames === powerUp2.hitFrames\r\n  );\r\n}\r\n\r\nexport function serializeEffects(effects, onlyChangedData = false) {\r\n  if (onlyChangedData) {\r\n    // Serialize and return only the changed globalPowerUps\r\n    let changedEffectsData = effects\r\n      .map((currentEffect) => {\r\n        const lastSentEffectData = lastSentEffects.find((lastPowerUpData) => lastPowerUpData.id === currentEffect.id);\r\n        const serializedEffect = serializeEffect(currentEffect);\r\n\r\n        // Compare the serialized data of the current globalPowerUp with the last sent data\r\n        if (!lastSentEffectData || !isEqualEffect(serializedEffect, lastSentEffectData)) {\r\n          // Update lastSentEffects with the new serialized data if changed\r\n          lastSentEffects = lastSentEffects.map((effect) => (effect.id === currentEffect.id ? serializedEffect : effect));\r\n          return serializedEffect;\r\n        }\r\n\r\n        // Return null for effects that haven't changed\r\n        return null;\r\n      })\r\n      .filter((changedData) => changedData !== null);\r\n    return changedEffectsData;\r\n  } else {\r\n    // If onlyChangedData is false, update lastSentEffects with the current serialized data\r\n    lastSentEffects = effects.map(serializeEffect);\r\n\r\n    // Serialize and return all effects\r\n    return lastSentEffects;\r\n  }\r\n}\r\n\r\n// Define a function to serialize a globalPowerUp's data\r\nfunction serializeEffect(effect) {\r\n  return {\r\n    id: effect.id,\r\n    x: effect.x,\r\n    y: effect.y,\r\n    color: effect.color,\r\n    duration: effect.isStar,\r\n    radius: effect.radius,\r\n    type: effect.type,\r\n  };\r\n}\r\n\r\n// Define a function to compare globalPowerUp objects for equality\r\nfunction isEqualEffect(effect1, effect2) {\r\n  const tolerance = 1e-4;\r\n  return (\r\n    Math.abs(effect1.x - effect2.x) < tolerance &&\r\n    Math.abs(effect1.y - effect2.y) < tolerance &&\r\n    effect1.color === effect2.color &&\r\n    effect1.duration === effect2.duration &&\r\n    effect1.type === effect2.type &&\r\n    effect1.radius === effect2.radius\r\n  );\r\n}\r\n","import { drawArrow } from \"./drawingUtils.js\";\r\nimport { ForceType } from \"./entities.js\";\r\nimport { basicAnimationTimer } from \"./gameLogic.js\";\r\n\r\nexport function drawForce(ctx, camX, camY, force) {\r\n  if (force.duration <= 0) {\r\n    return;\r\n  }\r\n  let centerX = force.x - camX;\r\n  let centerY = force.y - camY;\r\n  let color = force.color;\r\n  let radius = force.radius;\r\n  let width = force.width;\r\n  let length = force.length;\r\n  let attractive = force.isAttractive;\r\n  let coneAngle = force.coneAngle;\r\n  let direction = force.direction;\r\n  ctx.strokeStyle = color;\r\n\r\n  // Adjust the position based on the viewport\r\n  let screenX = centerX;\r\n  let screenY = centerY;\r\n  ctx.beginPath();\r\n  if (force.type == ForceType.POINT) {\r\n    // Calculate the angle range for the cone\r\n    let startAngle = direction - coneAngle / 2;\r\n    let endAngle = direction + coneAngle / 2;\r\n\r\n    // Normalize startAngle and endAngle to be within the range 0 to 2\r\n    startAngle = ((startAngle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);\r\n    endAngle = ((endAngle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);\r\n    let speed = 1;\r\n\r\n    //this will be 0.2-1\r\n    let animationPosition = 0;\r\n    let animationPosition2 = 0;\r\n    if (attractive) {\r\n      animationPosition = 1 - ((basicAnimationTimer * speed) % 85) / 100;\r\n      animationPosition2 = 1 - ((basicAnimationTimer * speed + 42.5) % 85) / 100;\r\n    } else {\r\n      animationPosition = ((basicAnimationTimer * speed) % 85) / 100 + 0.15;\r\n      animationPosition2 = ((basicAnimationTimer * speed + 42.5) % 85) / 100 + 0.15;\r\n    }\r\n\r\n    if (coneAngle == 2 * Math.PI) {\r\n      ctx.beginPath();\r\n      ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);\r\n      ctx.closePath();\r\n      ctx.stroke();\r\n      // Animated Circles\r\n      ctx.beginPath();\r\n      ctx.arc(screenX, screenY, radius * animationPosition, 0, Math.PI * 2);\r\n      ctx.closePath();\r\n      ctx.stroke();\r\n\r\n      ctx.beginPath();\r\n      ctx.arc(screenX, screenY, radius * animationPosition2, 0, Math.PI * 2);\r\n      ctx.closePath();\r\n      ctx.stroke();\r\n    } else {\r\n      ctx.moveTo(screenX, screenY); // Move to the center of the cone\r\n      ctx.lineTo(screenX + Math.cos(direction - coneAngle / 2) * radius, screenY + Math.sin(direction - coneAngle / 2) * radius); // Draw one edge of the cone\r\n      ctx.arc(screenX, screenY, radius, direction - coneAngle / 2, direction + coneAngle / 2); // Draw the arc representing the cone\r\n      ctx.lineTo(screenX, screenY); // Connect back to the center to close the shape\r\n      ctx.stroke();\r\n      ctx.beginPath();\r\n      ctx.moveTo(screenX, screenY); // Move to the center of the cone\r\n      ctx.lineTo(\r\n        screenX + Math.cos(direction - coneAngle / 2) * radius * animationPosition,\r\n        screenY + Math.sin(direction - coneAngle / 2) * radius * animationPosition\r\n      ); // Draw one edge of the cone\r\n      ctx.arc(screenX, screenY, radius * animationPosition, direction - coneAngle / 2, direction + coneAngle / 2); // Draw the arc representing the cone\r\n      ctx.lineTo(screenX, screenY);\r\n      ctx.closePath();\r\n      ctx.stroke();\r\n\r\n      ctx.beginPath();\r\n      ctx.moveTo(screenX, screenY); // Move to the center of the cone\r\n      ctx.lineTo(\r\n        screenX + Math.cos(direction - coneAngle / 2) * radius * animationPosition2,\r\n        screenY + Math.sin(direction - coneAngle / 2) * radius * animationPosition2\r\n      ); // Draw one edge of the cone\r\n      ctx.arc(screenX, screenY, radius * animationPosition2, direction - coneAngle / 2, direction + coneAngle / 2); // Draw the arc representing the cone\r\n      ctx.lineTo(screenX, screenY);\r\n      ctx.closePath();\r\n      ctx.stroke();\r\n    }\r\n\r\n    ctx.moveTo(screenX, screenY);\r\n\r\n    let increment = 10;\r\n    if (coneAngle > 5) {\r\n      increment = 40;\r\n    }\r\n    if (startAngle > endAngle) {\r\n      // If startAngle is greater than endAngle, it means the cone crosses the 0/2 line.\r\n      // In this case, we need to check if the angle is less than endAngle or greater than startAngle.\r\n      for (let i = 0; i < 360; i += increment) {\r\n        let angle = (i * Math.PI) / 180;\r\n        angle = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);\r\n\r\n        if (angle <= endAngle || angle >= startAngle) {\r\n          drawForceLines(ctx, attractive, radius, angle, screenX, screenY);\r\n        }\r\n      }\r\n    } else {\r\n      // If startAngle is less than endAngle, we can simply check if the angle is within this range.\r\n      for (let i = 0; i < 360; i += increment) {\r\n        let angle = (i * Math.PI) / 180;\r\n        angle = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);\r\n\r\n        if ((angle >= startAngle && angle <= endAngle) || coneAngle == 2 * Math.PI) {\r\n          drawForceLines(ctx, attractive, radius, angle, screenX, screenY);\r\n        }\r\n      }\r\n    }\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n    if (force.effect == true && force.tracks != null && force.tracks.isLocal) {\r\n      // applyGravityWarpEffect(ctx, screenX, screenY, radius,coneAngle,direction);\r\n    }\r\n  }\r\n  if (force.type == ForceType.DIRECTIONAL) {\r\n    // Calculate the coordinates of the four corners of the rectangle\r\n    const halfWidth = width / 2;\r\n    const halfLength = length / 2;\r\n    let angle = direction;\r\n\r\n    const x1 = screenX + halfWidth * Math.cos(angle) - halfLength * Math.sin(angle);\r\n    const y1 = screenY + halfWidth * Math.sin(angle) + halfLength * Math.cos(angle);\r\n\r\n    const x2 = screenX - halfWidth * Math.cos(angle) - halfLength * Math.sin(angle);\r\n    const y2 = screenY - halfWidth * Math.sin(angle) + halfLength * Math.cos(angle);\r\n\r\n    const x3 = screenX - halfWidth * Math.cos(angle) + halfLength * Math.sin(angle);\r\n    const y3 = screenY - halfWidth * Math.sin(angle) - halfLength * Math.cos(angle);\r\n\r\n    const x4 = screenX + halfWidth * Math.cos(angle) + halfLength * Math.sin(angle);\r\n    const y4 = screenY + halfWidth * Math.sin(angle) - halfLength * Math.cos(angle);\r\n\r\n    const rectCenterX = (x1 + x3) / 2;\r\n    const rectCenterY = (y1 + y3) / 2;\r\n\r\n    // Draw the rectangle by connecting the four corners\r\n    ctx.moveTo(x1, y1);\r\n    ctx.lineWidth = 1;\r\n    ctx.lineTo(x2, y2);\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n\r\n    // Start the second path with a thick line for the segment from (x2, y2) to (x3, y3)\r\n    ctx.beginPath();\r\n    ctx.moveTo(x2, y2);\r\n    ctx.lineWidth = 8;\r\n    ctx.lineTo(x3, y3);\r\n    ctx.stroke();\r\n    ctx.closePath();\r\n\r\n    // Continue with the first path with a thin line\r\n    // ctx.beginPath();\r\n    ctx.moveTo(x3, y3);\r\n    ctx.lineWidth = 1;\r\n    ctx.lineTo(x4, y4);\r\n    ctx.stroke();\r\n    ctx.lineTo(x1, y1);\r\n\r\n    //ctx.closePath();\r\n\r\n    if (!force.attractive) {\r\n      angle = angle + Math.PI;\r\n    }\r\n\r\n    const centerX = (x1 + x2 + x3 + x4) / 4;\r\n    const centerY = (y1 + y2 + y3 + y4) / 4;\r\n\r\n    const distX21 = x2 - x1;\r\n    const distY21 = y2 - y1;\r\n    const halfRectHeight = Math.sqrt(distX21 ** 2 + distY21 ** 2) / 2;\r\n\r\n    const distX32 = x3 - x2;\r\n    const distY32 = y3 - y2;\r\n    const halfRectWidth = Math.sqrt(distX32 ** 2 + distY32 ** 2) / 2;\r\n\r\n    let numPointsWide = force.numberArrowsEachSide;\r\n    if (numPointsWide == null || numPointsWide == 0) {\r\n      numPointsWide = Math.floor(halfRectWidth / 20);\r\n      force.numberArrowsEachSide = numPointsWide;\r\n    }\r\n    let numPointsDeep = force.numberArrowsDeep;\r\n    if (numPointsDeep == null || numPointsDeep == 0) {\r\n      numPointsDeep = Math.floor(halfRectHeight / 40);\r\n      force.numberArrowsDeep = numPointsDeep;\r\n    }\r\n    let speed = 1 + width / 150;\r\n    let animationPosition = ((basicAnimationTimer * speed) % 100) / 100 / numPointsDeep;\r\n\r\n    let offsetWidthLeft = 0.05; // adjust the offset to create more or less space around the arrows\r\n    let offsetWidthRight = 0.05; // adjust the offset to create more or less space around the arrows\r\n    let startWidth = offsetWidthLeft;\r\n    let endWidth = 1 - offsetWidthRight;\r\n\r\n    let offsetHeightBottom = -0.5 + animationPosition; // adjust the offset to create more or less space around the arrows\r\n    let offsetHeightTop = -0.2 - animationPosition; // adjust the offset to create more or less space around the arrows\r\n\r\n    let startHeight = offsetHeightBottom;\r\n    let endHeight = 1 - offsetHeightTop;\r\n\r\n    const clipRect1 = {\r\n      clipx1: x1,\r\n      clipy1: y1,\r\n      clipx2: x2,\r\n      clipy2: y2,\r\n      clipx3: x3,\r\n      clipy3: y3,\r\n      clipx4: x4,\r\n      clipy4: y4,\r\n    };\r\n\r\n    ctx.save();\r\n    //   Create clipping paths for the custom rectangles\r\n    ctx.beginPath();\r\n    ctx.moveTo(clipRect1.clipx1, clipRect1.clipy1);\r\n    ctx.lineTo(clipRect1.clipx2, clipRect1.clipy2);\r\n    ctx.lineTo(clipRect1.clipx3, clipRect1.clipy3);\r\n    ctx.lineTo(clipRect1.clipx4, clipRect1.clipy4);\r\n    ctx.closePath();\r\n    ctx.clip();\r\n\r\n    // ctx.strokeStyle = color;\r\n    for (let i = startHeight * numPointsDeep; i <= endHeight * numPointsDeep; i++) {\r\n      // for (let i = startHeight * (numPointsDeep - 1); i <= endHeight * (numPointsDeep - 1); i++) {\r\n      for (let j = startWidth * numPointsWide; j <= endWidth * numPointsWide; j++) {\r\n        let t = j / numPointsWide; // Parameter value along the direction of the arrows.\r\n        let s = i / numPointsDeep; // Parameter value along the direction perpendicular to arrows.\r\n\r\n        // Calculate a point in the rectangle using (1 - t)(1 - s)P1 + (1 - t)sP2 + t(1 - s)P3 + tsP4.\r\n        let x = (1 - t) * ((1 - s) * x1 + s * x2) + t * ((1 - s) * x4 + s * x3);\r\n        let y = (1 - t) * ((1 - s) * y1 + s * y2) + t * ((1 - s) * y4 + s * y3);\r\n        drawArrow(ctx, { x, y }, angle, 50, 20);\r\n      }\r\n    }\r\n\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  }\r\n}\r\n\r\nfunction drawForceLines(ctx, attractive, radius, angle, screenX, screenY) {\r\n  const arrowheadLength = 15;\r\n  const arrowheadAngle = Math.PI / 8;\r\n\r\n  if (attractive) {\r\n    // Draw inwards arrows\r\n    const arrowX = screenX + 0.8 * radius * Math.cos(angle);\r\n    const arrowY = screenY + 0.8 * radius * Math.sin(angle);\r\n\r\n    drawArrow(ctx, { x: arrowX, y: arrowY }, angle + Math.PI, 100, arrowheadLength, arrowheadAngle);\r\n  } else {\r\n    // Draw outwards arrows\r\n    const arrowX = screenX + 0.3 * radius * Math.cos(angle);\r\n    const arrowY = screenY + 0.3 * radius * Math.sin(angle);\r\n\r\n    drawArrow(ctx, { x: arrowX, y: arrowY }, angle, 100, arrowheadLength, arrowheadAngle);\r\n  }\r\n}\r\n","import { renderDebugInfo, drawPowerupLevels, drawSpecialGauge } from \"./drawGameUI.js\";\r\nimport { spikeyBallPoints, applyGlowingEffect } from \"./drawingUtils.js\";\r\nimport { forces, effects, EffectType } from \"./entities.js\";\r\nimport { drawBackground, drawWorldBounds } from \"./backgroundDrawing.js\";\r\nimport { drawMinimap, drawMinimapPowerups } from \"./miniMapDrawing.js\";\r\nimport { drawShip } from \"./drawShip.js\";\r\nimport { drawForce } from \"./forceDrawing.js\";\r\nimport { drawMine } from \"./mineDrawing.js\";\r\nimport { basicAnimationTimer } from \"./gameLogic.js\";\r\n\r\nlet backLayer = new Image();\r\nlet midBackLayer = new Image();\r\nlet middleLayer = new Image();\r\nlet midFrontLayer = new Image();\r\nlet frontLayer = new Image();\r\nbackLayer.src = \"images/parallax-space-background.png\";\r\nmidBackLayer.src = \"images/parallax-space-stars.png\";\r\nmiddleLayer.src = \"images/parallax-space-far-planets.png\";\r\nmidFrontLayer.src = \"images/parallax-space-ring-planet.png\";\r\nfrontLayer.src = \"images/parallax-space-big-planet.png\";\r\n\r\nconst shipPoints = [\r\n  { x: 0, y: -20 },\r\n  { x: -10, y: 20 },\r\n  { x: 0, y: 10 },\r\n  { x: 10, y: 20 },\r\n];\r\n\r\nexport function drawScene(player, otherPlayers, bots, mines, ctx, camX, camY, worldDimensions, canvas, globalPowerUps) {\r\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n  drawBackground(ctx, camX, camY, canvas, backLayer, midBackLayer, middleLayer, midFrontLayer, frontLayer);\r\n  drawWorldBounds(ctx, camX, camY, worldDimensions.width, worldDimensions.height);\r\n  ctx.lineWidth = 2;\r\n  drawPowerups(globalPowerUps, ctx, camX, camY);\r\n  mines.forEach((mine) => drawMine(ctx, camX, camY, mine, spikeyBallPoints));\r\n  forces.forEach((force) => drawForce(ctx, camX, camY, force));\r\n  effects.forEach((effect) => drawEffect(ctx, camX, camY, effect));\r\n  bots.forEach((bot) => drawShip(ctx, camX, camY, bot, shipPoints));\r\n  otherPlayers.forEach((player) => drawShip(ctx, camX, camY, player, shipPoints));\r\n\r\n  drawMinimap(player, otherPlayers, bots, worldDimensions.width, worldDimensions.height);\r\n  drawMinimapPowerups(globalPowerUps, worldDimensions.width, worldDimensions.height);\r\n  if (player != null) {\r\n    drawShip(ctx, camX, camY, player, shipPoints);\r\n    renderDebugInfo(ctx, player, bots);\r\n    // drawInvincibilityGauge(ctx, player, canvas.width / 2, canvas.height - 70);\r\n    drawSpecialGauge(ctx, player, canvas.width / 2, canvas.height - 20);\r\n  }\r\n  drawPowerupLevels(ctx, player, otherPlayers, bots);\r\n}\r\n\r\nexport function drawPowerups(globalPowerUps, ctx, camX, camY) {\r\n  globalPowerUps.forEach((powerUp) => {\r\n    const currentTime = Date.now();\r\n    let elapsedTime = currentTime - powerUp.starTransitionStartTime;\r\n    const transitionDuration = 200;\r\n    if (isNaN(elapsedTime)) {\r\n      elapsedTime = Math.floor(Math.random() * transitionDuration);\r\n    }\r\n    if (!powerUp.starTransitionStartTime || elapsedTime >= transitionDuration) {\r\n      powerUp.starTransitionStartTime = currentTime - elapsedTime;\r\n    }\r\n    const animationFrame = elapsedTime % transitionDuration;\r\n\r\n    // Save the current canvas state\r\n    ctx.save();\r\n\r\n    if (powerUp.hitFrames < -1) {\r\n      applyGlowingEffect(ctx, \"white\", powerUp.color, \"white\", transitionDuration, animationFrame, 0.2);\r\n    } else if (powerUp.isStar) {\r\n      // Apply a glowing effect for star ships\r\n      ctx.shadowBlur = 10;\r\n      ctx.strokeStyle = \"gold\"; // Adjust the stroke color to match the glow\r\n\r\n      // Gradually change the star's color\r\n      const transitionEndColor = \"gold\"; // Final color\r\n      applyGlowingEffect(ctx, \"gold\", powerUp.color, transitionEndColor, transitionDuration, animationFrame);\r\n    } else {\r\n      ctx.strokeStyle = powerUp.color;\r\n      ctx.fillStyle = powerUp.color;\r\n    }\r\n    // Rotate the star\r\n    const rotationSpeed = 2 / (powerUp.radius * powerUp.radius); // Adjust the rotation speed\r\n    const rotationAngle = (elapsedTime * rotationSpeed) % (2 * Math.PI);\r\n\r\n    // Translate the canvas origin to the power-up position\r\n    ctx.translate(powerUp.x - camX, powerUp.y - camY);\r\n    ctx.rotate(rotationAngle);\r\n    drawStar(ctx, powerUp.radius);\r\n\r\n    // Restore the canvas state to prevent transformations from affecting other objects\r\n    ctx.restore();\r\n  });\r\n}\r\n\r\n// Function to draw a simple star shape (you can replace this with your custom image/icon drawing logic)\r\nfunction drawStar(ctx, radius) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(0, -radius);\r\n  for (let i = 0; i < 5; i++) {\r\n    ctx.rotate(Math.PI / 5);\r\n    ctx.lineTo(0, -0.6 * radius);\r\n    ctx.rotate(Math.PI / 5);\r\n    ctx.lineTo(0, -radius);\r\n  }\r\n  ctx.closePath();\r\n  ctx.fill();\r\n  ctx.stroke();\r\n}\r\n\r\nexport function drawEffect(ctx, camX, camY, effect) {\r\n  const currentTime = Date.now();\r\n  const elapsedTime = currentTime - effect.starTransitionStartTime;\r\n  const transitionDuration = 80;\r\n  const animatationFrame = elapsedTime % transitionDuration;\r\n  if (effect.duration >= 0) {\r\n    if (!effect.starTransitionStartTime || elapsedTime >= transitionDuration) {\r\n      effect.starTransitionStartTime = currentTime;\r\n    }\r\n    applyGlowingEffect(ctx, \"white\", effect.color, \"white\", transitionDuration, animatationFrame, 0.2);\r\n  } else {\r\n    ctx.strokeStyle = effect.color;\r\n    ctx.fillStyle = effect.color;\r\n  }\r\n\r\n  if (!effect.type || effect.type == \"\") {\r\n    ctx.beginPath();\r\n    ctx.arc(effect.x - camX, effect.y - camY, effect.radius, 0, Math.PI * 2);\r\n\r\n    ctx.fill();\r\n  } else if (effect.type == \"temp\") {\r\n    const animationDuration = 120;\r\n    const animatationFrame = elapsedTime % animationDuration;\r\n  } else if (effect.type === EffectType.EXPLOSION) {\r\n    const animationDuration = 120;\r\n    const numFrames = 10; // Number of frames for the explosion\r\n    const frameDuration = animationDuration / numFrames;\r\n    const frameIndex = Math.floor(elapsedTime / frameDuration);\r\n    const maxRadius = effect.radius * 3; // Maximum explosion radius\r\n\r\n    if (frameIndex < numFrames) {\r\n      // Calculate the current radius for the explosion\r\n      let currentRadius = (frameIndex / numFrames) * maxRadius;\r\n      currentRadius = Math.max(currentRadius, 0);\r\n      // Draw the expanding circle\r\n      ctx.beginPath();\r\n      ctx.arc(effect.x - camX, effect.y - camY, currentRadius, 0, Math.PI * 2);\r\n      ctx.fill();\r\n\r\n      // Optionally, add a stroke for an outline effect\r\n      ctx.strokeStyle = \"rgba(255, 0, 0, 0.5)\";\r\n      ctx.lineWidth = 2;\r\n      ctx.stroke();\r\n    }\r\n  }\r\n\r\n  ctx.shadowBlur = 0;\r\n  ctx.shadowColor = \"transparent\";\r\n}\r\n","import { isPlayerMasterPeer, setTimeSinceMessageFromMaster, timeSinceMessageFromMaster } from \"./connectionHandlers.js\";\r\nimport { detectCollisions } from \"./collisionLogic.js\";\r\nimport {\r\n  getTopScores,\r\n  incrementFirebaseGivenPropertyValue,\r\n  readUserDataFromFirestore,\r\n  getFirebaseProperty,\r\n  DbPropertyKey,\r\n  DbDocumentKey,\r\n  getFirebase,\r\n  allTimeKills,\r\n  allTimePoints,\r\n  allTimeLogins,\r\n} from \"./db.js\";\r\nimport { forces, Entity, effects, MineType } from \"./entities.js\";\r\nimport { achievementsTitleText } from \"./login.js\";\r\nimport { generatePowerups, generateMines, generateDirectionalForces, generateBots } from \"./generateEntities.js\";\r\nimport { player, bots, otherPlayers, mines, setGameTimer, gameTimer, globalPowerUps, worldDimensions, colors, powerUpColors } from \"./main.js\";\r\nimport { Player, Bot } from \"./player.js\";\r\nimport { sendPlayerStates, sendEntitiesState, sendEntitiesUpdate, sendBotEntitiesUpdate, sendRemoveEntityUpdate } from \"./sendData.js\";\r\nimport { ProcessTrailShapesAllPlayers } from \"./trailShapes.js\";\r\n\r\nexport let initialInvincibleTime = 60 * 10;\r\nexport let maxInvincibilityTime = initialInvincibleTime;\r\nexport let maxSpecialMeter = 200;\r\n\r\n// let directionalForces = [];\r\nexport let spawnProtectionTime = 200;\r\nexport let endGameMessage = \"\";\r\nexport let gameWon = false;\r\nexport let basicAnimationTimer = 0;\r\nexport let updateRequested = false;\r\nexport function setUpdateRequested(newValue) {\r\n  updateRequested = newValue;\r\n}\r\nexport const botRespawnDelay = 240;\r\nexport const PilotName = {\r\n  PILOT_1: \"pilot1\",\r\n  PILOT_2: \"pilot2\",\r\n  PILOT_3: \"pilot3\",\r\n  PILOT_4: \"pilot4\",\r\n};\r\nexport let levelAnimationFrame = 0;\r\n\r\nexport function incrementLevelAnimationFrame() {\r\n  levelAnimationFrame++;\r\n}\r\nexport let achievementsTitle = achievementsTitleText.LOGIN_TO_TRACK;\r\n\r\nexport function setAchievementsTitle(newTitle) {\r\n  achievementsTitle = newTitle;\r\n}\r\n\r\nexport class Pilot extends Entity {\r\n  constructor(\r\n    id = null,\r\n    x = null,\r\n    y = null,\r\n    width = 100,\r\n    height = 130,\r\n    lore = \"\",\r\n    name = \"\",\r\n    src = \"\",\r\n    pilotInvincibilityTime = 600,\r\n    trailTime = 100,\r\n    selected = false\r\n  ) {\r\n    super(id, x, y);\r\n    this.image = new Image();\r\n    this.width = width;\r\n    this.height = height;\r\n    this.lore = lore;\r\n    this.name = name;\r\n    this.src = src;\r\n    //deafult 600 is 10 seconds\r\n    this.invincibilityTime = pilotInvincibilityTime;\r\n    this.trailTime = trailTime;\r\n    this.selected = selected;\r\n    this.pilotAnimationFrame = 0;\r\n  }\r\n  setSelected(newSelectedValue) {\r\n    if (newSelectedValue && !this.selected) {\r\n      this.pilotAnimationFrame = 0;\r\n    }\r\n    this.selected = newSelectedValue;\r\n  }\r\n}\r\nexport const pilot1 = new Pilot(\r\n  PilotName.PILOT_1,\r\n  0,\r\n  0,\r\n  100,\r\n  130,\r\n  \"Sunny Sam; Speed: 4; Invicible Time: 10;Special: Gravity Attract; Ugh, here's Sunny Side-Up Sam, the carrot who's always shining bright. How original, right? He's the 'hero' of this carrot caper, or so he thinks. Just an average carrot trying way too hard to be cool. Yawn. Is he in this tournament to prove he's the 'coolest' carrot around?;Agressive: likes to get powered up and use Gravity Attract to get kills\",\r\n  PilotName.PILOT_1,\r\n  \"carrot1Canvas\",\r\n  600,\r\n  100\r\n);\r\nexport const pilot2 = new Pilot(\r\n  PilotName.PILOT_2,\r\n  0,\r\n  0,\r\n  100,\r\n  130,\r\n  \"Girthy Gordon; Speed: 2; Invicible Time: 15;Special: Gravity Repel; A Grumpy, portly carrot with a penchant for defense. You've seen it all before, right? He might be slow, but that doesn't stop him from being the predictable 'tank' of the group. Originality, anyone? Is he here for vengeance, or is there something even darker lurking beneath his carrot exterior?;Defensive: not so fast but can use Gravity Repel to keep attackers away \",\r\n  PilotName.PILOT_2,\r\n  \"carrot2Canvas\",\r\n  900,\r\n  120\r\n);\r\nexport const pilot3 = new Pilot(\r\n  PilotName.PILOT_3,\r\n  0,\r\n  0,\r\n  100,\r\n  130,\r\n  \"Zippy; Speed: 5; Invicible Time: 10; Special: Speed Boost; Fast but weak, unathletic, and clumsier than a bull in a china shop. He's also surprisingly tight with his money, counting every last carrot coin. Zipping around like he's in a hurry to save a few bucks. A tiny carrot with a big clich and an even smaller wallet. Maybe he stumbled into the tournament by accident, and now he's just trying to survive the chaos!;Speedy: tricky to control. Not for scrubs! \",\r\n  PilotName.PILOT_3,\r\n  \"carrot3Canvas\",\r\n  600,\r\n  100\r\n);\r\nexport const pilot4 = new Pilot(\r\n  PilotName.PILOT_4,\r\n  0,\r\n  0,\r\n  100,\r\n  130,\r\n  \"Stan; Speed: 3; Invicible Time: 12; Special: Tractor Beam; Forever in shock, like he just found out he's a carrot. With his bleeding eyes and a backstory that involves suffering radiation poisoning from being half-cooked in the microwave. In endless pain some say he want's to win the tournament only as part of his plan to make sure the entire universe suffers as he does.;Sneaky!: Powerful long range narrow tractor beam can cause havok from afar!\",\r\n  PilotName.PILOT_4,\r\n  \"carrot4Canvas\",\r\n  700,\r\n  150\r\n);\r\n\r\nexport let pilots = [pilot1, pilot2, pilot3, pilot4];\r\n\r\nexport const max_player_name = 15;\r\n\r\nexport function setEndGameMessage(newMessage) {\r\n  endGameMessage = newMessage;\r\n}\r\n\r\nfunction resetPowerLevels(player, otherPlayers, globalPowerUps) {\r\n  // Reset my powerUps\r\n  player.powerUps = 0;\r\n\r\n  // Reset powerUps of other players\r\n  otherPlayers.forEach((player) => {\r\n    player.powerUps = 0;\r\n  });\r\n\r\n  // Send updated powerUps to other players\r\n  sendPlayerStates(player, isPlayerMasterPeer(player));\r\n}\r\n\r\nfunction shipHitsBorder(x, y) {\r\n  return x < 0 || y < 0 || x > worldWidth || y > worldHeight;\r\n}\r\n\r\nexport function setGameWon(won) {\r\n  gameWon = won;\r\n}\r\n\r\nexport function updateEnemies(deltaTime) {\r\n  // Update the positions, velocities, etc. of the enemies, create and track forces\r\n  //todo sync forces to deltaTime... could the level of force be linked?\r\n  //or could we get away with only creating new force if old one doesn't exist?\r\n  // Remove mines with hit frames that have expired.\r\n  for (let i = mines.length - 1; i >= 0; i--) {\r\n    let mine = mines[i];\r\n    mine.createForce();\r\n    if (mine.hitFrames < -1) {\r\n      // in \"initialising\" state - do this first before potential splicing\r\n      mine.hitFrames++;\r\n    }\r\n    if (mine.hitFrames >= 0) {\r\n      mine.hitFrames--;\r\n      // If hit frames have expired, remove the mine.\r\n      if (mine.hitFrames < 0) {\r\n        if (isPlayerMasterPeer(player)) {\r\n          sendRemoveEntityUpdate(\"removeMines\", [mine]);\r\n        }\r\n        mines.splice(i, 1);\r\n      }\r\n    }\r\n\r\n    if (mine.mineType == MineType.TRAIL || mine.mineType == MineType.FREE_MINE) {\r\n      if (mine.duration > 0) {\r\n        mine.duration--;\r\n      }\r\n      if (mine.duration <= 0) {\r\n        if (isPlayerMasterPeer(player)) {\r\n          //trying letting trails ride without syncing\r\n          //sendRemoveEntityUpdate(\"removeMines\", [mine]);\r\n        }\r\n        mines.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  for (let powerUp of globalPowerUps) {\r\n    powerUp.createForce();\r\n  }\r\n\r\n  for (let force of forces) {\r\n    if (force.duration > 0) {\r\n      // for (let effectedPlayer of allPlayers){\r\n      if (force.tracks != null && force.tracks.isPlaying && !force.tracks.isDead) {\r\n        force.x = force.tracks.x;\r\n        force.y = force.tracks.y;\r\n      }\r\n      // }\r\n      try {\r\n        force.setDuration(force.duration - 1);\r\n      } catch (Exception) {\r\n        console.log(\"force issue\");\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function updateOtherPlayers(deltaTime, mines, camX, camY) {\r\n  otherPlayers.forEach((otherPlayer, index) => {\r\n    // Check if player is an instance of the Player class\r\n    if (otherPlayer != null && otherPlayer instanceof Player) {\r\n      if (otherPlayer.name != \"\") {\r\n        otherPlayer.updateTick(deltaTime, mines, camX, camY);\r\n      }\r\n    } else {\r\n      console.log(\"otherPlayer is not an instance of the Player class. Reinitializing...\");\r\n\r\n      // Create a new Player object using the properties of the otherplayer\r\n      const newPlayer = new Player(\r\n        otherPlayer.id,\r\n        otherPlayer.x,\r\n        otherPlayer.y,\r\n        otherPlayer.powerUps,\r\n        otherPlayer.color,\r\n        otherPlayer.getAngle(),\r\n        otherPlayer.pilot,\r\n        otherPlayer.name,\r\n        otherPlayer.isPlaying\r\n      );\r\n\r\n      // Replace the old player with the new Player instance in the array\r\n      otherPlayer[index] = newPlayer;\r\n    }\r\n  });\r\n}\r\n\r\nexport function updateBots(deltaTime, mines, camX, camY) {\r\n  bots.forEach((bot, index) => {\r\n    // Check if bot is an instance of the Bot class\r\n    if (bot == null || !(bot instanceof Bot)) {\r\n      // console.log(\"Bot is not an instance of the Bot class. Reinitializing...\");\r\n\r\n      // Create a new Bot object using the properties of the bot\r\n      const newPlayer = new Bot(\r\n        bot.id,\r\n        bot.x,\r\n        bot.y,\r\n        bot.powerUps,\r\n        bot.color,\r\n        bot.getAngle(),\r\n        bot.pilot,\r\n        bot.name\r\n        // Add other properties as needed\r\n      );\r\n      console.log(\"had to reinitialise bot\");\r\n      // Replace the old bot with the new Bot instance in the array\r\n      bots[index] = newPlayer;\r\n    }\r\n    if (bot != null && bot instanceof Bot && bot.isDead) {\r\n      bot.delayReset(botRespawnDelay, true, true);\r\n    }\r\n    if (bot != null && bot instanceof Bot && !bot.isDead) {\r\n      //todo not sure about this conditional\r\n      if (isPlayerMasterPeer(player)) {\r\n        bot.updateBotInputs();\r\n      }\r\n      bot.updateTick(deltaTime, mines, camX, camY);\r\n    }\r\n  });\r\n}\r\n\r\nexport function updatePowerups(deltaTime) {\r\n  // Update the positions, velocities, etc. of the powerups once they move... they need their own update tick\r\n  //setGlobalPowerUps(getGlobalPowerUps());\r\n}\r\n\r\nexport function masterUpdateGame(player, globalPowerUps, otherPlayers, bots, mines, deltaTime, camX, camY) {\r\n  //this isn't synced between peers\r\n  setGameTimer(gameTimer + 1);\r\n  if (!isPlayerMasterPeer(player)) {\r\n    setTimeSinceMessageFromMaster(timeSinceMessageFromMaster + 1);\r\n  }\r\n  player.updateTick(deltaTime, mines, camX, camY);\r\n  // generateBots(worldWidth,worldHeight,colors);\r\n  updateBots(deltaTime, mines, camX, camY);\r\n  updateOtherPlayers(deltaTime, mines, camX, camY);\r\n  updateEnemies(deltaTime);\r\n  updatePowerups(deltaTime);\r\n\r\n  // Detect collisions with powerups or other ships\r\n  detectCollisions(player, globalPowerUps, bots, otherPlayers, forces);\r\n\r\n  // The master peer also detects collisions between all ships and powerups\r\n  otherPlayers.forEach((otherPlayer) => {\r\n    detectCollisions(otherPlayer, globalPowerUps, bots, otherPlayers, forces);\r\n  });\r\n\r\n  bots.forEach((bot) => {\r\n    detectCollisions(bot, globalPowerUps, bots, otherPlayers, forces);\r\n  });\r\n\r\n  if (gameTimer % 2 == 0) {\r\n    ProcessTrailShapesAllPlayers(player, otherPlayers, mines, effects, globalPowerUps);\r\n  }\r\n  removeExpiredPowerUps(globalPowerUps, player);\r\n  removeExpiredEffects(effects, player);\r\n  basicAnimationTimer++;\r\n  incrementLevelAnimationFrame();\r\n  if (isPlayerMasterPeer(player)) {\r\n    if (gameTimer % 89 == 1) {\r\n      sendEntitiesState();\r\n    } else if (gameTimer % 21 == 1) {\r\n      sendEntitiesUpdate();\r\n    } else if (gameTimer % 2 == 1) {\r\n      sendBotEntitiesUpdate();\r\n    }\r\n  }\r\n  if (!player.isDead && gameTimer % 1 == 0) {\r\n    sendPlayerStates(player, isPlayerMasterPeer(player));\r\n  }\r\n\r\n  if (gameTimer % 100 == 2 && isPlayerMasterPeer(player)) {\r\n    generateBots(worldDimensions.width, worldDimensions.height, colors);\r\n    generatePowerups(globalPowerUps, worldDimensions.width, worldDimensions.height, powerUpColors);\r\n    generateMines(worldDimensions.width, worldDimensions.height, colors);\r\n    generateDirectionalForces(worldDimensions.width, worldDimensions.height, colors);\r\n  }\r\n}\r\n\r\n// Function to remove expired power-ups\r\nfunction removeExpiredPowerUps(globalPowerUps, player) {\r\n  for (let i = globalPowerUps.length - 1; i >= 0; i--) {\r\n    if (globalPowerUps[i].hitFrames < -1) {\r\n      globalPowerUps[i].hitFrames++;\r\n    }\r\n    if (globalPowerUps[i].hitFrames >= 0) {\r\n      globalPowerUps[i].hitFrames--;\r\n      if (globalPowerUps[i].hitFrames < 0) {\r\n        if (isPlayerMasterPeer(player)) {\r\n          sendRemoveEntityUpdate(\"removePowerUps\", [globalPowerUps[i]]);\r\n        }\r\n        globalPowerUps.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Function to remove expired effects\r\nfunction removeExpiredEffects(effects, player) {\r\n  for (let i = effects.length - 1; i >= 0; i--) {\r\n    if (effects[i].duration >= 0) {\r\n      effects[i].duration--;\r\n      if (effects[i].duration < 0) {\r\n        if (isPlayerMasterPeer(player)) {\r\n          sendRemoveEntityUpdate(\"removeEffect\", [effects[i]]);\r\n        }\r\n        effects.splice(i, 1);\r\n      }\r\n    }\r\n  }\r\n}\r\n// Initial XP required for first level up\r\nlet initialXPRequired = 100;\r\nlet xpRequiredGrowthFactor = 1.6;\r\n\r\nexport function getXp() {\r\n  let totalXp = 0;\r\n  totalXp += allTimePoints;\r\n  totalXp += allTimeKills * 500;\r\n  totalXp += allTimeLogins * 1;\r\n  return totalXp;\r\n}\r\n\r\nexport function calculateLevelXP(xp, initialXPRequired, growthFactor) {\r\n  let level = 1;\r\n  let xpRequired = initialXPRequired;\r\n\r\n  // Find the level at which the given XP belongs\r\n  while (xp >= xpRequired) {\r\n    xp -= xpRequired;\r\n    level++;\r\n    xpRequired = Math.floor(xpRequired * growthFactor); // Increase XP required for the next level\r\n  }\r\n  let xpToNextLevel = xpRequired - xp;\r\n\r\n  return { level, remainingXP: xp, nextLevelXP: xpRequired, xpToNextLevel };\r\n}\r\n\r\nexport function getLevel(xp) {\r\n  const { level } = calculateLevelXP(xp, initialXPRequired, xpRequiredGrowthFactor);\r\n  return level;\r\n}\r\n\r\nexport function getLevelXP(xp) {\r\n  const { remainingXP } = calculateLevelXP(xp, initialXPRequired, xpRequiredGrowthFactor);\r\n  return remainingXP;\r\n}\r\n\r\nexport function getNextLevelXP(xp) {\r\n  const { nextLevelXP } = calculateLevelXP(xp, initialXPRequired, xpRequiredGrowthFactor);\r\n  return nextLevelXP;\r\n}\r\n\r\nexport function getXpToNextLevel(xp) {\r\n  const { xpToNextLevel } = calculateLevelXP(xp, initialXPRequired, xpRequiredGrowthFactor);\r\n  return xpToNextLevel;\r\n}\r\n","import { forces, effects, MineType } from \"./entities.js\";\r\nimport { bots, globalPowerUps, mines } from \"./main.js\";\r\n// Function to find a bot by ID in the bots array\r\nexport function findBotById(id) {\r\n  return bots.find((bot) => bot.id === id);\r\n}\r\n\r\nexport function findForceById(id) {\r\n  return forces.find((force) => force.id === id);\r\n}\r\n\r\nexport function findMineById(id) {\r\n  return mines.find((mine) => mine.id === id);\r\n}\r\n\r\nexport function findEffectById(id) {\r\n  return effects.find((effect) => effect.id === id);\r\n}\r\n\r\nexport function findPowerUpById(id) {\r\n  return globalPowerUps.find((powerUp) => powerUp.id === id);\r\n}\r\n\r\nexport function differsFrom(firstArray, secondArray) {\r\n  // Convert the second array to a Set for efficient lookup\r\n  const secondArraySet = new Set(secondArray);\r\n\r\n  // Check if any element in the first array is not in the second array\r\n  for (const element of firstArray) {\r\n    if (!secondArraySet.has(element)) {\r\n      return true; // Found a value in the first array that's not in the second array\r\n    }\r\n  }\r\n  return false; // All values in the first array are also in the second array\r\n}\r\n\r\n//check if the first letter of the string is a space\r\nexport function checkFirstLetterSpace(string) {\r\n  return /^\\s/.test(string);\r\n}\r\n\r\nexport function screenShake(canvas, intensity, duration) {\r\n  const originalX = canvas.style.left || \"0px\";\r\n  const originalY = canvas.style.top || \"0px\";\r\n\r\n  const startTime = Date.now();\r\n\r\n  function shake() {\r\n    const currentTime = Date.now();\r\n    const elapsedTime = currentTime - startTime;\r\n\r\n    if (elapsedTime < duration) {\r\n      // Generate random displacement within the intensity range\r\n      const deltaX = (Math.random() - 0.5) * intensity * 2;\r\n      const deltaY = (Math.random() - 0.5) * intensity * 2;\r\n\r\n      canvas.style.left = `${parseFloat(originalX) + deltaX}px`;\r\n      canvas.style.top = `${parseFloat(originalY) + deltaY}px`;\r\n\r\n      // Request the next frame\r\n      requestAnimationFrame(shake);\r\n    } else {\r\n      // Reset the canvas position after the duration\r\n      // canvas.style.left = originalX;\r\n      // canvas.style.top = originalY;\r\n      canvas.style.left = \"0px\";\r\n      canvas.style.top = \"0px\";\r\n    }\r\n  }\r\n\r\n  // Start the shake effect\r\n  shake();\r\n}\r\n\r\nexport function getRandomUniqueColor(colors, selectedColors) {\r\n  let remainingColors;\r\n  if (selectedColors) {\r\n    remainingColors = colors.filter((color) => !selectedColors.includes(color));\r\n  } else {\r\n    remainingColors = colors;\r\n  }\r\n  if (remainingColors.length === 0 && selectedColors) {\r\n    // Reset the selected colors array if all colors have been used\r\n    selectedColors.length = 0;\r\n    remainingColors = colors;\r\n  }\r\n\r\n  const randomIndex = Math.floor(Math.random() * remainingColors.length);\r\n  const selectedColor = remainingColors[randomIndex];\r\n  if (selectedColors) {\r\n    selectedColors.push(selectedColor);\r\n  }\r\n  if (!selectedColor) {\r\n    console.log(\"issue getting random unique color\");\r\n  }\r\n  return selectedColor;\r\n}\r\n\r\n// Generate circles to approximate the shape\r\nfunction generateCircles(shapePath, radius) {\r\n  const circles = [];\r\n\r\n  for (let i = 0; i < shapePath.length; i++) {\r\n    const currentPoint = shapePath[i];\r\n    const nextPoint = shapePath[(i + 1) % shapePath.length];\r\n\r\n    const distance = Math.sqrt((nextPoint.x - currentPoint.x) ** 2 + (nextPoint.y - currentPoint.y) ** 2);\r\n    const numCircles = Math.max(2, Math.ceil(distance / (2 * radius))); // Ensure a minimum of 2 circles\r\n\r\n    for (let j = 0; j < numCircles; j++) {\r\n      const fraction = j / (numCircles - 1); // Adjusted for inclusiveness\r\n      const x = currentPoint.x + fraction * (nextPoint.x - currentPoint.x);\r\n      const y = currentPoint.y + fraction * (nextPoint.y - currentPoint.y);\r\n      circles.push({ x, y, radius });\r\n    }\r\n  }\r\n\r\n  return circles;\r\n}\r\n\r\nexport function findCompleteShape(playerID, mines, minShapeArea) {\r\n  // Filter mines belonging to the specified player\r\n  const playerMines = mines.filter((mine) => mine.playerId === playerID && mine.mineType == MineType.TRAIL);\r\n  // Sort the player mines by mine.duration (in descending order)\r\n  playerMines.sort((a, b) => b.duration - a.duration);\r\n\r\n  if (playerMines.length < 15) {\r\n    // Not enough mines to form a shape\r\n    return null;\r\n  }\r\n\r\n  // Check if there is a closed shape\r\n  const shapePath = [];\r\n\r\n  for (let i = 0; i < playerMines.length; i++) {\r\n    const currentMine = playerMines[i];\r\n    shapePath.push({ x: currentMine.x, y: currentMine.y });\r\n  }\r\n\r\n  // Check if the shapePath forms a closed shape\r\n  if (shapePath.length >= 3) {\r\n    const firstPoint = shapePath[0];\r\n    const lastPoint = shapePath[shapePath.length - 1];\r\n    const distanceBetweenStartAndEnd = Math.sqrt((firstPoint.x - lastPoint.x) ** 2 + (firstPoint.y - lastPoint.y) ** 2);\r\n\r\n    // if (distanceBetweenStartAndEnd <= minShapeArea) {\r\n    if (distanceBetweenStartAndEnd <= 100) {\r\n      // Calculate the center of the shape\r\n      const centerX = shapePath.reduce((sum, point) => sum + point.x, 0) / shapePath.length;\r\n      const centerY = shapePath.reduce((sum, point) => sum + point.y, 0) / shapePath.length;\r\n\r\n      // Calculate the area of the shape\r\n      let shapeArea = 0;\r\n      for (let i = 0; i < shapePath.length; i++) {\r\n        const currentPoint = shapePath[i];\r\n        const nextPoint = shapePath[(i + 1) % shapePath.length];\r\n        shapeArea += (currentPoint.x * nextPoint.y - nextPoint.x * currentPoint.y) / 2;\r\n      }\r\n      shapeArea = Math.abs(shapeArea);\r\n      //let triangulationShapeArea = calculateArea(shapePath);\r\n      if (shapeArea < minShapeArea) {\r\n        return null;\r\n      }\r\n      // Describe the shape\r\n      if (playerMines.length === 2) {\r\n        return { type: \"Ring\", center: { x: centerX, y: centerY }, area: shapeArea };\r\n      } else {\r\n        // const circles = generateCircles(shapePath, playerMines[0].width / 2);\r\n        // const spokeLength = 3 * calculateAverageDistance(centerX, centerY, shapePath);\r\n        const spokeLength = 3.5 * calculateAverageDistance(centerX, centerY, shapePath);\r\n        const spokeWidth = 70;\r\n        // const spokeWidth = 250;\r\n        return {\r\n          type: \"Bounded Shape\",\r\n          center: { x: centerX, y: centerY },\r\n          area: shapeArea,\r\n          mines: playerMines,\r\n          shapePath: shapePath,\r\n          spokeLength: spokeLength,\r\n          spokeWidth: spokeWidth,\r\n          // circles: circles,\r\n        };\r\n      }\r\n    } else {\r\n      //remove the first matching mine\r\n      // playerMines.pop();\r\n      // return findCompleteShape(playerID, playerMines, minShapeArea)\r\n    }\r\n  }\r\n\r\n  // No closed shape found or it's too small or not closed enough\r\n  return null;\r\n}\r\n\r\nfunction calculateAverageDistance(centerX, centerY, points) {\r\n  const numSamplePoints = 10;\r\n  let totalDistance = 0;\r\n\r\n  for (let i = 0; i < numSamplePoints; i++) {\r\n    const randomIndex = Math.floor(Math.random() * points.length);\r\n    const samplePoint = points[randomIndex];\r\n\r\n    const dx = samplePoint.x - centerX;\r\n    const dy = samplePoint.y - centerY;\r\n    totalDistance += Math.sqrt(dx * dx + dy * dy);\r\n  }\r\n\r\n  return totalDistance / numSamplePoints;\r\n}\r\n\r\nfunction calculateArea(shapePath) {\r\n  if (shapePath.length < 3) {\r\n    // Cannot calculate area for shapes with less than 3 vertices.\r\n    return 0;\r\n  }\r\n\r\n  let totalArea = 0;\r\n  const n = shapePath.length;\r\n\r\n  // Triangulate the shape and sum up the areas of individual triangles.\r\n  for (let i = 1; i < n - 1; i++) {\r\n    const x1 = shapePath[0].x;\r\n    const y1 = shapePath[0].y;\r\n    const x2 = shapePath[i].x;\r\n    const y2 = shapePath[i].y;\r\n    const x3 = shapePath[i + 1].x;\r\n    const y3 = shapePath[i + 1].y;\r\n\r\n    const area = 0.5 * Math.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2));\r\n    totalArea += area;\r\n  }\r\n\r\n  return totalArea;\r\n}\r\n\r\nexport function isPointInsideShape(shapePath, point) {\r\n  const x = point.x;\r\n  const y = point.y;\r\n\r\n  let isInside = false;\r\n  const n = shapePath.length;\r\n\r\n  for (let i = 0, j = n - 1; i < n; j = i++) {\r\n    const xi = shapePath[i].x;\r\n    const yi = shapePath[i].y;\r\n    const xj = shapePath[j].x;\r\n    const yj = shapePath[j].y;\r\n\r\n    const intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\r\n\r\n    if (intersect) {\r\n      isInside = !isInside;\r\n    }\r\n  }\r\n\r\n  return isInside;\r\n}\r\n\r\nexport function shuffleArray(array) {\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]]; // Swap elements at i and j\r\n  }\r\n}\r\n\r\nexport function calculateAngle(player) {\r\n  return Math.atan2(player.mousePosY - player.y, player.mousePosX - player.x);\r\n}\r\n","import { isPlayerMasterPeer } from \"./connectionHandlers.js\";\r\nimport { player, setMines, bots, mines, selectedColors } from \"./main.js\";\r\nimport { sendRemoveEntityUpdate, sendMinesUpdate, sendPowerUpsUpdate, sendForcesUpdate, sendBotsUpdate } from \"./sendData.js\";\r\nimport { forces, Mine, PowerUp, ForceType, ForceArea, MineType } from \"./entities.js\";\r\nimport { Bot } from \"./player.js\";\r\nimport { getRandomUniqueColor } from \"./gameUtils.js\";\r\n\r\nlet maxPowerups = 10;\r\nlet maxMines = 14;\r\nlet maxBots = 4;\r\nlet maxDirectionalForces = 7;\r\nlet chancePowerUpIsStar = 0.2;\r\n\r\nexport const BoundaryForce = {\r\n  LEFT: \"leftBoundaryForce-\",\r\n  RIGHT: \"rightBoundaryForce-\",\r\n  TOP: \"topBoundaryForce-\",\r\n  BOTTOM: \"bottomBoundaryForce-\",\r\n};\r\n\r\nexport function generatePowerups(globalPowerUps, worldWidth, worldHeight, colors) {\r\n  if (!isPlayerMasterPeer(player)) {\r\n    return;\r\n  }\r\n  let addedPowerUps = false;\r\n  // Check if there are less than max powerups powerups\r\n  while (globalPowerUps.length < maxPowerups) {\r\n    let isStar = false;\r\n    let radius = 50;\r\n    let value = 2;\r\n\r\n    if (Math.random() > 1 - chancePowerUpIsStar) {\r\n      isStar = true;\r\n      radius = 15;\r\n      value = 1;\r\n    }\r\n    let hasGravity = 0;\r\n    if (Math.random() > 0.9) {\r\n      if (Math.random() > 0.2) {\r\n        //push force\r\n        hasGravity = -1;\r\n        if (isStar) {\r\n          value = 2;\r\n          radius = 15;\r\n        } else {\r\n          value = 5;\r\n          radius = 30;\r\n        }\r\n      } else {\r\n        hasGravity = 1;\r\n      }\r\n    }\r\n\r\n    let powerUp = new PowerUp(\r\n      \"regularPU-\" + Math.floor(Math.random() * 10000),\r\n      (Math.random() * 0.8 + 0.1) * worldWidth,\r\n      (Math.random() * 0.8 + 0.1) * worldHeight,\r\n      getRandomUniqueColor(colors, null),\r\n      isStar,\r\n      radius,\r\n      value,\r\n      hasGravity\r\n    );\r\n    addedPowerUps = true;\r\n    globalPowerUps.push(powerUp);\r\n    // setGlobalPowerUps(globalPowerUps);\r\n    // Send the powerups every time you generate one\r\n    // sendPowerups(globalPowerUps);\r\n\r\n    //cf test do we need this sendGameState(globalPowerUps);\r\n  }\r\n  if (addedPowerUps) {\r\n    sendPowerUpsUpdate(true);\r\n  }\r\n  let regularPowerUps = globalPowerUps.filter((powerup) => powerup.id.startsWith(\"mineConvert-\"));\r\n  // Remove excess powerUps if there are more than maxPowerups\r\n  while (regularPowerUps.length > maxPowerups) {\r\n    let removedPowerUp = globalPowerUps.pop();\r\n    removedPowerUp = regularPowerUps.pop();\r\n    if (isPlayerMasterPeer(player)) {\r\n      sendRemoveEntityUpdate(\"removePowerUps\", [removedPowerUp]);\r\n    }\r\n    //- in futre can add effect for this\r\n  }\r\n}\r\n\r\nexport function generateBots(worldWidth, worldHeight, colors) {\r\n  if (!isPlayerMasterPeer(player)) {\r\n    return;\r\n  }\r\n  let addedBots = false;\r\n\r\n  // Check if there are fewer than maxBots bots\r\n  while (bots.length < maxBots) {\r\n    let botID = Math.floor(Math.random() * 10000);\r\n    let bot = new Bot(\r\n      botID,\r\n      (Math.random() * 0.8 + 0.1) * worldWidth,\r\n      (Math.random() * 0.8 + 0.1) * worldHeight,\r\n      0, // Set other properties for the bot as needed\r\n      getRandomUniqueColor(colors, selectedColors)\r\n    );\r\n\r\n    bot.isBot = true;\r\n    bot.name = getRandomName();\r\n    bots.push(bot);\r\n    addedBots = true;\r\n  }\r\n\r\n  if (addedBots) {\r\n    sendBotsUpdate(true);\r\n  }\r\n\r\n  // Remove excess bots if there are more than maxBots\r\n  while (bots.length > maxBots) {\r\n    const removedBot = bots.pop();\r\n    if (isPlayerMasterPeer(player)) {\r\n      sendRemoveEntityUpdate(\"removeBots\", [removedBot]);\r\n    }\r\n    //  add effects in the future\r\n  }\r\n}\r\n\r\nexport function generateMines(worldWidth, worldHeight, colors) {\r\n  if (!isPlayerMasterPeer(player)) {\r\n    return;\r\n  }\r\n  let addedMines = false;\r\n  const regularMines = mines.filter((mine) => mine.mineType === MineType.REGULAR);\r\n  // Check if there are less than max powerups powerups\r\n  while (regularMines.length < maxMines) {\r\n    let hasGravity = 0;\r\n    if (Math.random() > 0.8) {\r\n      if (Math.random() > 0.9) {\r\n        //test out push force even though it doesn't really make sense for a mine\r\n        hasGravity = -1;\r\n      } else {\r\n        hasGravity = 1;\r\n      }\r\n    }\r\n    let mine = new Mine(\r\n      Math.floor(Math.random() * 10000),\r\n      (Math.random() * 0.8 + 0.1) * worldWidth,\r\n      (Math.random() * 0.8 + 0.1) * worldHeight,\r\n      100,\r\n      10,\r\n      getRandomUniqueColor(colors, null),\r\n      hasGravity\r\n    );\r\n    mines.push(mine);\r\n    regularMines.push(mine);\r\n    addedMines = true;\r\n  }\r\n  if (addedMines) {\r\n    sendMinesUpdate(true);\r\n  }\r\n  // Remove excess regularMines if there are more than maxMines\r\n  while (regularMines.length > maxMines) {\r\n    const removedMine = regularMines.pop();\r\n    setMines(mines.filter((mine) => mine.id != removedMine.id));\r\n    if (isPlayerMasterPeer(player)) {\r\n      sendRemoveEntityUpdate(\"removeMines\", [removedMine]);\r\n    }\r\n    //- in futre can add effect for this\r\n  }\r\n}\r\n\r\nexport function generateDirectionalForces(worldWidth, worldHeight, colors) {\r\n  if (!isPlayerMasterPeer(player)) {\r\n    return;\r\n  }\r\n  let addedDirectionalForces = false;\r\n  const directionalForces = forces.filter((force) => force.type === ForceType.DIRECTIONAL);\r\n  const boundaryForceSize = 500;\r\n  // Check if there are less than max powerups powerups\r\n  while (directionalForces.length < maxDirectionalForces) {\r\n    if (!hasGivenBoundaryForce(BoundaryForce.LEFT, directionalForces)) {\r\n      addedDirectionalForces = true;\r\n      addBoundaryForce(boundaryForceSize / 2, worldHeight / 2, boundaryForceSize, worldHeight, Math.PI, BoundaryForce.LEFT, directionalForces);\r\n    }\r\n    if (!hasGivenBoundaryForce(BoundaryForce.RIGHT, directionalForces)) {\r\n      addedDirectionalForces = true;\r\n      addBoundaryForce(\r\n        worldWidth - boundaryForceSize / 2,\r\n        worldHeight / 2,\r\n        boundaryForceSize,\r\n        worldHeight,\r\n        0,\r\n        BoundaryForce.RIGHT,\r\n        directionalForces\r\n      );\r\n    }\r\n    if (!hasGivenBoundaryForce(BoundaryForce.TOP, directionalForces)) {\r\n      addedDirectionalForces = true;\r\n      addBoundaryForce(worldWidth / 2, boundaryForceSize / 2, boundaryForceSize, worldWidth, (3 * Math.PI) / 2, BoundaryForce.TOP, directionalForces);\r\n    }\r\n    if (!hasGivenBoundaryForce(BoundaryForce.BOTTOM, directionalForces)) {\r\n      addedDirectionalForces = true;\r\n      addBoundaryForce(\r\n        worldWidth / 2,\r\n        worldHeight - boundaryForceSize / 2,\r\n        boundaryForceSize,\r\n        worldWidth,\r\n        Math.PI / 2,\r\n        BoundaryForce.BOTTOM,\r\n        directionalForces\r\n      );\r\n    }\r\n    let force = new ForceArea(\r\n      \"force-\" + Math.floor(Math.random() * 10000),\r\n      (Math.random() * 0.8 + 0.1) * worldWidth,\r\n      (Math.random() * 0.8 + 0.1) * worldHeight,\r\n      0.7,\r\n      10,\r\n      200,\r\n      true,\r\n      \"green\",\r\n      null,\r\n      0,\r\n      Math.random() * 2 * Math.PI,\r\n      ForceType.DIRECTIONAL,\r\n      420 + Math.floor((Math.random() - 1) * 300),\r\n      600 + Math.floor((Math.random() - 1) * 300)\r\n    );\r\n\r\n    forces.push(force);\r\n    directionalForces.push(force);\r\n    addedDirectionalForces = true;\r\n  }\r\n  if (addedDirectionalForces) {\r\n    sendForcesUpdate(true);\r\n  }\r\n  // Remove excess directional forces if there are more than maxDirectionalForces\r\n  while (directionalForces.length > maxDirectionalForces) {\r\n    const removedForce = directionalForces.pop();\r\n    const index = forces.indexOf(removedForce);\r\n    if (index !== -1) {\r\n      if (isPlayerMasterPeer(player)) {\r\n        sendRemoveEntityUpdate(\"removeForces\", [forces[index]]);\r\n      }\r\n      forces.splice(index, 1);\r\n    }\r\n  }\r\n}\r\n\r\nfunction addBoundaryForce(x, y, width, height, angle, id, directionalForces) {\r\n  let force = new ForceArea(id, x, y, 1.2, 10, 200, true, \"blue\", null, 0, angle, ForceType.DIRECTIONAL, width, height);\r\n  forces.push(force);\r\n  directionalForces.push(force);\r\n}\r\n\r\nfunction hasGivenBoundaryForce(id, boundaryForces) {\r\n  // Use the some() method to check if any force meets the condition\r\n  return boundaryForces.some((force) => force.id.startsWith(id));\r\n}\r\n\r\nexport function getRandomName() {\r\n  const prefixes = [\r\n    \"Astro\",\r\n    \"Galaxy\",\r\n    \"Star\",\r\n    \"Cosmo\",\r\n    \"Rocket\",\r\n    \"Lunar\",\r\n    \"Solar\",\r\n    \"Free\",\r\n    \"Quasar\",\r\n    \"Pulsar\",\r\n    \"Meteor\",\r\n    \"Poopy\",\r\n    \"Sneaky\",\r\n    \"Stinky\",\r\n    \"Drunk\",\r\n    \"Mean\",\r\n    \"Tree\",\r\n    \"Dave\",\r\n    \"Chuck\",\r\n    \"Fire\",\r\n    \"Ice\",\r\n    \"Mystic\",\r\n    \"Electric\",\r\n    \"Nebula\",\r\n    \"Aqua\",\r\n    \"Cyber\",\r\n    \"Shadow\",\r\n    \"Crystal\",\r\n    \"Golden\",\r\n    \"Silver\",\r\n    \"Ein\",\r\n    \"Kevin\",\r\n    \"Wesely\",\r\n    \"Jiggly\",\r\n    \"Pork\",\r\n    \"Battle\",\r\n    \"Flexy\",\r\n  ];\r\n  const suffixes = [\r\n    \"Rider\",\r\n    \"Pilot\",\r\n    \"Crusher\",\r\n    \"Dasher\",\r\n    \"Blaster\",\r\n    \"Racoon\",\r\n    \"Buster\",\r\n    \"Zoomer\",\r\n    \"Flyer\",\r\n    \"Racer\",\r\n    \"Striker\",\r\n    \"Tosser\",\r\n    \"Wanderer\",\r\n    \"Maverick\",\r\n    \"Slinger\",\r\n    \"Jester\",\r\n    \"Lover\",\r\n    \"Ranger\",\r\n    \"Champion\",\r\n    \"Seeker\",\r\n    \"Phantom\",\r\n    \"Hunter\",\r\n    \"Shifter\",\r\n    \"Whisper\",\r\n    \"Dreamer\",\r\n    \"Log\",\r\n    \"stein\",\r\n    \"Freedom\",\r\n    \"Pup\",\r\n    \"Beast\",\r\n  ];\r\n\r\n  // Generate random indexes for prefix and suffix\r\n  const prefixIndex = Math.floor(Math.random() * prefixes.length);\r\n  const suffixIndex = Math.floor(Math.random() * suffixes.length);\r\n\r\n  // Generate a random number between 10 and 99\r\n  const randomNumber = Math.floor(Math.random() * 90) + 10;\r\n\r\n  // Decide whether to place the number at the beginning or end\r\n  const placeAtEnd = Math.random() < 0.3;\r\n\r\n  const skipSuffix = Math.random() < 0.3;\r\n\r\n  // Build the name based on the placement of the number\r\n  let randomName;\r\n  if (!placeAtEnd) {\r\n    randomName = prefixes[prefixIndex] + suffixes[suffixIndex];\r\n  } else if (skipSuffix) {\r\n    randomName = prefixes[prefixIndex] + randomNumber;\r\n  } else {\r\n    randomName = prefixes[prefixIndex] + suffixes[suffixIndex] + randomNumber;\r\n  }\r\n\r\n  // If the name is longer than 15 characters, truncate it\r\n  if (randomName.length > 15) {\r\n    randomName = randomName.slice(0, 15);\r\n  }\r\n\r\n  return randomName;\r\n}\r\n","import { setGlobalPowerUps, bots, mines, setBots, setMines } from \"./main.js\";\r\nimport {\r\n  connectedPeers,\r\n  setConnectedPeers,\r\n  setTimeSinceMessageFromMaster,\r\n  setTimeSinceAnyMessageRecieved,\r\n  isPlayerMasterPeer,\r\n  wrappedResolveConflicts,\r\n  chooseNewMasterPeer,\r\n  setMasterPeerId,\r\n} from \"./connectionHandlers.js\";\r\nimport { incrementFirebaseGivenPropertyValue, DbPropertyKey, getFirebase } from \"./db.js\";\r\nimport { setEndGameMessage } from \"./gameLogic.js\";\r\nimport {\r\n  forces,\r\n  setForces,\r\n  createMineFromObject,\r\n  createForceFromObject,\r\n  createPowerUpFromObject,\r\n  createEffectFromObject,\r\n  effects,\r\n  setEffects,\r\n  MineType,\r\n} from \"./entities.js\";\r\nimport { createBotFromObject, Player } from \"./player.js\";\r\nimport { differsFrom, findForceById, findBotById, findMineById, findPowerUpById, findEffectById } from \"./gameUtils.js\";\r\nimport { sendPlayerStates, sendEntitiesState } from \"./sendData.js\";\r\nconst interpFactor = 0.05;\r\nconst threshold = 50;\r\nconst velocityInterpFactor = 0.4;\r\nconst velocityThreshold = 2;\r\n\r\nexport function handleData(player, otherPlayers, globalPowerUps, data) {\r\n  setTimeSinceAnyMessageRecieved(0);\r\n  const currentTimestamp = Date.now();\r\n  const messageTimestamp = data.timestamp;\r\n  // let timeThreshold = 2 * fixedDeltaTime;\r\n  let timeThreshold = 20;\r\n  if (data.priority < 3) {\r\n    timeThreshold = 30;\r\n  }\r\n  if (data.priority < 2) {\r\n    timeThreshold = 60;\r\n  }\r\n  let timeDifference = currentTimestamp - messageTimestamp;\r\n  if (timeDifference > timeThreshold) {\r\n    //lets try not ignoring old messages\r\n    //return;\r\n  }\r\n\r\n  let otherPlayer = otherPlayers.find((player) => player.id === data.id);\r\n  if (otherPlayer) {\r\n    otherPlayer.timeSinceSentMessageThatWasRecieved = 0;\r\n  }\r\n  if (isPlayerMasterPeer(player) && data.isMaster) {\r\n    wrappedResolveConflicts(player, otherPlayers, globalPowerUps, true);\r\n    console.log(\"master conflict\");\r\n    return;\r\n  }\r\n  if (data.requestForFullStates) {\r\n    sendPlayerStates(player, isPlayerMasterPeer(player), true);\r\n    return;\r\n  }\r\n  if (data.requestFullUpdate && isPlayerMasterPeer(player) && ticksSinceLastConnectionAttempt > 200) {\r\n    setTicksSinceLastConnectionAttempt(0);\r\n    sendEntitiesState(player, isPlayerMasterPeer(player), true);\r\n    return;\r\n  }\r\n\r\n  if (!otherPlayer) {\r\n    otherPlayer = findBotById(data.id);\r\n  }\r\n  if (otherPlayer) {\r\n    updateOtherPlayerData(otherPlayer, data, otherPlayers, globalPowerUps, player);\r\n  } // If the player is not found, add them to the array\r\n  else if (data.id && data.id != player.id && !data.isBot) {\r\n    let newPlayer = new Player(data.id, data.x, data.y, data.powerUps, data.color, data.angle, data.pilot, data.name, data.isPlaying, true);\r\n    otherPlayers.push(newPlayer);\r\n    if (!connectedPeers.includes(data.id)) {\r\n      connectedPeers.push(data.id);\r\n    }\r\n    connectedPeers.sort();\r\n\r\n    setMasterPeerId(chooseNewMasterPeer(player, otherPlayers));\r\n  } else if (data.id && data.id == player.id) {\r\n    // // If this is our own data, update key properties from the master, not position, velocity, etc.\r\n    updateOwnPlayerData(player, data);\r\n  }\r\n\r\n  updateGlobalPowerUps(data, globalPowerUps);\r\n  removeGlobalPowerUps(data, globalPowerUps);\r\n\r\n  updateBots(data, bots);\r\n  removeBots(data, bots);\r\n\r\n  updateMines(data, mines);\r\n  removeMines(data, mines);\r\n\r\n  updateEffects(data, effects);\r\n  removeEffects(data, effects);\r\n\r\n  updateForces(data, player, forces, player.id);\r\n  removeForces(data, forces);\r\n  //don't curently send this data could be used for master to send out key properties of otherplayers (score,kills etc.. not pos,vel etc)\r\n  if (data.otherPlayers && data.otherPlayers.length > 0) {\r\n    setTimeSinceMessageFromMaster(0);\r\n    const dataPlayer = data.otherPlayers.find((otherPlayer) => otherPlayer.id === player.id);\r\n\r\n    if (dataPlayer != null) {\r\n      player.kills = dataPlayer.kills;\r\n      player.setIsDead(dataPlayer.isDead);\r\n      player.lives = dataPlayer.lives;\r\n      player.powerUps = dataPlayer.powerUps;\r\n      player.ticksSincePowerUpCollection = dataPlayer.ticksSincePowerUpCollection;\r\n      player.setInvincibleTimer(dataPlayer.invincibleTimer);\r\n      if (dataPlayer.hitBy != null && dataPlayer.hitBy != \"\" && player.isDead) {\r\n        player.hitBy = dataPlayer.hitBy;\r\n        setEndGameMessage(\"Killed by: \" + player.hitBy + \"\\nScore: \" + player.powerUps * 100);\r\n      } else if (player.isDead) {\r\n        setEndGameMessage(\"Score: \" + player.powerUps * 100);\r\n      }\r\n      player.killed = dataPlayer.killed;\r\n      player.killedBy = dataPlayer.killedBy;\r\n    }\r\n    //we will just replace select properties of otherplayers from the master\r\n    for (let otherPlayer of otherPlayers) {\r\n      const foundDataOtherPlayer = data.otherPlayers.find((dataOtherPlayer) => dataOtherPlayer.id === otherPlayer.id);\r\n      if (foundDataOtherPlayer != null) {\r\n        otherPlayer.kills = foundDataOtherPlayer.kills;\r\n        otherPlayer.setIsDead(foundDataOtherPlayer.isDead);\r\n        otherPlayer.lives = foundDataOtherPlayer.lives;\r\n        otherPlayer.powerUps = foundDataOtherPlayer.powerUps;\r\n        otherPlayer.ticksSincePowerUpCollection = foundDataOtherPlayer.ticksSincePowerUpCollection;\r\n        otherPlayer.setInvincibleTimer(foundDataOtherPlayer.invincibleTimer);\r\n      }\r\n    }\r\n  }\r\n\r\n  if (data.connectedPeers && data.connectedPeers.length > 0) {\r\n    //we don't currently send peer data, need to review this if we add peer sharing back, particually attemptConnections\r\n    //check if connectedPeers has any id's (strings) not in data.connectedPeers\r\n    let combine = false;\r\n    if (differsFrom(connectedPeers, data.connectedPeers)) {\r\n      combine = true;\r\n    }\r\n\r\n    //then check if data.connectedPeers has any id's (strings) not in connectedPeers\r\n    if (differsFrom(data.connectedPeers, connectedPeers)) {\r\n      combine = true;\r\n    }\r\n\r\n    if (combine) {\r\n      // Combine the arrays and set connectedPeers = the combined array\r\n      setConnectedPeers([...new Set([...data.connectedPeers, ...connectedPeers])]);\r\n      // connectedPeers.forEach((connectedID) => {\r\n      //   connection.\r\n      // });\r\n      setTimeout(() => attemptConnections(player, otherPlayers, globalPowerUps), 50);\r\n      sendConnectedPeers();\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateOtherPlayerData(otherPlayer, data, otherPlayers, globalPowerUps, player) {\r\n  if (!otherPlayer) return;\r\n\r\n  for (const key in data) {\r\n    if (data.hasOwnProperty(key)) {\r\n      if (key === \"name\") {\r\n        if (data.name != null && data.name != \"\") {\r\n          otherPlayer.name = data.name;\r\n        }\r\n      } else if (key === \"pilot\") {\r\n        if (data.pilot != null && data.pilot != \"\") {\r\n          otherPlayer.pilot = data.pilot;\r\n        }\r\n      } else if (key === \"x\" || key === \"y\") {\r\n        //check if the gap is closer than the threshold\r\n        if (Math.abs(otherPlayer[key] - data[key]) <= threshold) {\r\n          // Interpolate x and y values\r\n          otherPlayer[key] += (data[key] - otherPlayer[key]) * interpFactor;\r\n        } else {\r\n          // Update x and y values directly\r\n          otherPlayer[key] = data[key];\r\n        }\r\n      } else if (key === \"powerUps\") {\r\n        if (otherPlayer.ticksSincePowerUpCollection > -1 && otherPlayer.powerUps < data.powerUps) {\r\n          console.log(\"possible double powerup collection attempt?\");\r\n        } else {\r\n          otherPlayer[key] = data[key];\r\n        }\r\n      } else if (key === \"isDead\") {\r\n        otherPlayer.setIsDead(data.isDead);\r\n      } else if (key === \"invincibleTimer\") {\r\n        otherPlayer.setInvincibleTimer(data.invincibleTimer);\r\n      } else if (key === \"comboScaler\") {\r\n        otherPlayer.setComboScaler(data.comboScaler);\r\n      } else if (key === \"velX\" || key === \"velY\") {\r\n        // Check if velocities are further apart than the threshold\r\n        if (Math.abs(otherPlayer[key] - data[key]) > velocityThreshold) {\r\n          // Interpolate velocities\r\n          otherPlayer[key] += (data[key] - otherPlayer[key]) * velocityInterpFactor;\r\n        } else {\r\n          // Update velocities directly\r\n          otherPlayer[key] = data[key];\r\n        }\r\n      } else if (key === \"angle\") {\r\n        // Log the name, angle before, and angle after\r\n        //console.log(`Updating angle for ${otherPlayer.name}: Before: ${otherPlayer.getAngle()}, After: ${data[key]}`);\r\n        otherPlayer.setAngle(data[key]);\r\n      } else {\r\n        otherPlayer[key] = data[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  if (isPlayerMasterPeer(player) && isPlayerMasterPeer(otherPlayer) && !otherPlayer.isBot) {\r\n    wrappedResolveConflicts(player, otherPlayers, globalPowerUps, true);\r\n  }\r\n}\r\n\r\nfunction updateOwnPlayerData(player, data) {\r\n  if (!player || !data.id || data.id !== player.id) return;\r\n\r\n  if (data.hasOwnProperty(\"powerUps\")) {\r\n    if (player.ticksSincePowerUpCollection > -1 && player.powerUps < data.powerUps) {\r\n      console.log(\"possible double powerup collection attempt? (own data)\");\r\n    } else {\r\n      player.powerUps = data.powerUps;\r\n    }\r\n    // setGameOverText(player);\r\n    player.updateKilledAndKilledByLists(player.hitBy);\r\n  }\r\n  if (data.hasOwnProperty(\"comboScaler\")) {\r\n    player.setComboScaler(data.comboScaler);\r\n  }\r\n  if (data.hasOwnProperty(\"isDead\")) {\r\n    if (data.isDead && !player.isDead) {\r\n      //just found out we're dead\r\n      let firebase = getFirebase();\r\n      if (firebase) {\r\n        const user = firebase.auth().currentUser;\r\n        if (user) {\r\n          if (player.powerUps) {\r\n            incrementFirebaseGivenPropertyValue(firebase, DbPropertyKey.SCORE, player.powerUps);\r\n          }\r\n          if (player.kills) {\r\n            incrementFirebaseGivenPropertyValue(firebase, DbPropertyKey.KILLS, player.kills);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    player.setIsDead(data.isDead);\r\n    if (data.isDead) {\r\n      player.vel.x = 0;\r\n      player.vel.y = 0;\r\n    }\r\n  }\r\n  if (data.hasOwnProperty(\"lives\")) {\r\n    player.lives = data.lives;\r\n  }\r\n  if (data.hasOwnProperty(\"hitBy\")) {\r\n    player.hitBy = data.hitBy;\r\n    player.updateKilledAndKilledByLists(player.hitBy);\r\n    // setGameOverText(player);\r\n  }\r\n  if (data.hasOwnProperty(\"kills\")) {\r\n    player.kills = data.kills;\r\n  }\r\n  if (data.hasOwnProperty(\"killed\")) {\r\n    player.killed = data.killed;\r\n    player.updateKilledAndKilledByLists(player.hitBy);\r\n  }\r\n  if (data.hasOwnProperty(\"killedBy\")) {\r\n    player.killedBy = data.killedBy;\r\n    player.updateKilledAndKilledByLists(player.hitBy);\r\n  }\r\n  if (data.hasOwnProperty(\"invincibleTimer\")) {\r\n    player.setInvincibleTimer(data.invincibleTimer);\r\n  }\r\n  if (data.hasOwnProperty(\"ticksSincePowerUpCollection\")) {\r\n    player.ticksSincePowerUpCollection = data.ticksSincePowerUpCollection;\r\n  }\r\n  if (data.hasOwnProperty(\"recentScoreTicks\")) {\r\n    player.recentScoreTicks = data.recentScoreTicks;\r\n  }\r\n  if (data.hasOwnProperty(\"recentScoreText\")) {\r\n    player.recentScoreText = data.recentScoreText;\r\n  }\r\n  if (data.hasOwnProperty(\"recentKillScoreText\")) {\r\n    player.recentKillScoreText = data.recentKillScoreText;\r\n  }\r\n}\r\n\r\nfunction setGameOverText(player) {\r\n  if (player.hitBy != null && player.hitBy != \"\") {\r\n    setEndGameMessage(\"Killed by: \" + player.hitBy + \"\\nScore: \" + player.powerUps * 100);\r\n  } else {\r\n    setEndGameMessage(\"Score: \" + player.powerUps * 100);\r\n  }\r\n}\r\nfunction updateGlobalPowerUps(data, globalPowerUps) {\r\n  if (data.globalPowerUps && data.globalPowerUps.length > 0) {\r\n    for (const receivedPowerUp of data.globalPowerUps) {\r\n      // Find the corresponding local powerup by ID\r\n      const localPowerUp = findPowerUpById(receivedPowerUp.id);\r\n\r\n      if (localPowerUp) {\r\n        const xDiff = Math.abs(receivedPowerUp.x - localPowerUp.x);\r\n        const yDiff = Math.abs(receivedPowerUp.y - localPowerUp.y);\r\n\r\n        if (xDiff <= threshold && yDiff <= threshold) {\r\n          // Interpolate x and y values\r\n          localPowerUp.x = localPowerUp.x + (receivedPowerUp.x - localPowerUp.x) * interpFactor;\r\n          localPowerUp.y = localPowerUp.y + (receivedPowerUp.y - localPowerUp.y) * interpFactor;\r\n        } else {\r\n          // Update x and y values directly\r\n          localPowerUp.x = receivedPowerUp.x;\r\n          localPowerUp.y = receivedPowerUp.y;\r\n        }\r\n        localPowerUp.color = receivedPowerUp.color;\r\n        localPowerUp.isStar = receivedPowerUp.isStar;\r\n        localPowerUp.value = receivedPowerUp.value;\r\n        localPowerUp.radius = receivedPowerUp.radius;\r\n        localPowerUp.hitFrames = receivedPowerUp.hitFrames;\r\n      } else {\r\n        // If the local powerup doesn't exist, add it to the globalPowerUps array\r\n        globalPowerUps.push(createPowerUpFromObject(receivedPowerUp));\r\n      }\r\n    }\r\n  }\r\n  if (data.fullSend && data.globalPowerUps) {\r\n    // Create a new globalPowerUps array by filtering only the powerUps that exist in data.globalPowerUps\r\n    const updatedGlobalPowerUps = globalPowerUps.filter(\r\n      (powerUpToCheck) => powerUpToCheck.id == null || data.globalPowerUps.some((dataPowerUp) => dataPowerUp.id === powerUpToCheck.id)\r\n    );\r\n\r\n    // Update the globalPowerUps array once\r\n    setGlobalPowerUps(updatedGlobalPowerUps);\r\n  }\r\n}\r\n\r\nfunction removeGlobalPowerUps(data, globalPowerUps) {\r\n  if (data.removePowerUps && data.removePowerUps.length > 0) {\r\n    let filteredPowerUps = [...globalPowerUps]; // Create a copy of the original globalPowerUps array\r\n\r\n    for (let dataPowerUp of data.removePowerUps) {\r\n      if (dataPowerUp.id != null) {\r\n        const matchingPowerUpIndex = filteredPowerUps.findIndex((currentPowerUp) => currentPowerUp.id === dataPowerUp.id);\r\n        if (matchingPowerUpIndex !== -1) {\r\n          filteredPowerUps.splice(matchingPowerUpIndex, 1);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Update the globalPowerUps array once after the loop\r\n    setGlobalPowerUps(filteredPowerUps);\r\n  }\r\n}\r\n\r\nfunction updateMines(data, mines) {\r\n  if (data.mines && data.mines.length > 0) {\r\n    setTimeSinceMessageFromMaster(0);\r\n\r\n    for (const receivedMine of data.mines) {\r\n      // Find the corresponding local bot by ID\r\n      const localMine = findMineById(receivedMine.id);\r\n\r\n      if (localMine) {\r\n        const xDiff = Math.abs(receivedMine.x - localMine.x);\r\n        const yDiff = Math.abs(receivedMine.y - localMine.y);\r\n\r\n        if (xDiff <= threshold && yDiff <= threshold) {\r\n          // Interpolate x and y values\r\n          localMine.x = localMine.x + (receivedMine.x - localMine.x) * interpFactor;\r\n          localMine.y = localMine.y + (receivedMine.y - localMine.y) * interpFactor;\r\n        } else {\r\n          // Update x and y values directly\r\n          localMine.x = receivedMine.x;\r\n          localMine.y = receivedMine.y;\r\n        }\r\n        localMine.force = receivedMine.force;\r\n        localMine.duration = receivedMine.duration;\r\n        localMine.radius = receivedMine.radius;\r\n        localMine.hitFrames = receivedMine.hitFrames;\r\n        localMine.color = receivedMine.color;\r\n        localMine.mineType = receivedMine.mineType;\r\n        localMine.playerId = receivedMine.playerId;\r\n        if (localMine.mineType == MineType.FREE_MINE || localMine.mineType == MineType.TRAIL) {\r\n          if (receivedMine.angle) {\r\n            localMine.angle = receivedMine.angle;\r\n          }\r\n          if (localMine.mineType == MineType.FREE_MINE) {\r\n            if (receivedMine.points && receivedMine.points.length > 0) localMine.points = receivedMine.points;\r\n          }\r\n        }\r\n      } else {\r\n        // If the local mine doesn't exist, add it to the mines array\r\n        mines.push(createMineFromObject(receivedMine));\r\n      }\r\n    }\r\n  }\r\n  if (data.fullSend && data.mines) {\r\n    // Create a new mines array by filtering only the mines that exist in data.mines\r\n    const updatedMines = mines.filter(\r\n      (mineToCheck) => /^trail-/.test(mineToCheck.id) || mineToCheck.id == null || data.mines.some((dataMine) => dataMine.id === mineToCheck.id)\r\n    );\r\n\r\n    // Update the mines array once\r\n    setMines(updatedMines);\r\n  }\r\n}\r\n\r\nfunction removeMines(data, mines) {\r\n  if (data.removeMines && data.removeMines.length > 0) {\r\n    let filteredMines = [...mines]; // Create a copy of the original mines array\r\n\r\n    for (let dataMine of data.removeMines) {\r\n      if (dataMine.id != null) {\r\n        filteredMines = filteredMines.filter((mine) => mine.id !== dataMine.id);\r\n      }\r\n    }\r\n\r\n    // Update the mines array once after the loop\r\n    setMines(filteredMines);\r\n  }\r\n}\r\n\r\nfunction updateEffects(data, effects) {\r\n  if (data.effects && data.effects.length > 0) {\r\n    setTimeSinceMessageFromMaster(0);\r\n\r\n    for (const receivedEffect of data.effects) {\r\n      // Find the corresponding local bot by ID\r\n      const localEffect = findEffectById(receivedEffect.id);\r\n\r\n      if (localEffect) {\r\n        const xDiff = Math.abs(receivedEffect.x - localEffect.x);\r\n        const yDiff = Math.abs(receivedEffect.y - localEffect.y);\r\n\r\n        if (xDiff <= threshold && yDiff <= threshold) {\r\n          // Interpolate x and y values\r\n          localEffect.x = localEffect.x + (receivedEffect.x - localEffect.x) * interpFactor;\r\n          localEffect.y = localEffect.y + (receivedEffect.y - localEffect.y) * interpFactor;\r\n        } else {\r\n          // Update x and y values directly\r\n          localEffect.x = receivedEffect.x;\r\n          localEffect.y = receivedEffect.y;\r\n        }\r\n        localEffect.radius = receivedEffect.radius;\r\n        localEffect.duration = receivedEffect.duration;\r\n        localEffect.color = receivedEffect.color;\r\n        localEffect.type = receivedEffect.type;\r\n      } else {\r\n        // If the local effects doesn't exist, add it to the effects array\r\n        effects.push(createEffectFromObject(receivedEffect));\r\n      }\r\n    }\r\n  }\r\n  if (data.fullSend && data.effects) {\r\n    // Create a new effects array by filtering only the effects that exist in data.effects\r\n    const updatedEffects = effects.filter(\r\n      (effectToCheck) => effectToCheck.id == null || data.effects.some((dataEffect) => dataEffect.id === effectToCheck.id)\r\n    );\r\n\r\n    // Update the effects array once\r\n    setEffects(updatedEffects);\r\n  }\r\n}\r\n\r\nfunction removeEffects(data, effects) {\r\n  if (data.removeEffects && data.removeEffects.length > 0) {\r\n    let filteredEffects = [...effects]; // Create a copy of the original effects array\r\n\r\n    for (let dataEffect of data.removeEffects) {\r\n      if (dataEffect.id != null) {\r\n        filteredEffects = filteredEffects.filter((effect) => effect.id !== dataEffect.id);\r\n      }\r\n    }\r\n\r\n    // Update the effects array once after the loop\r\n    setEffects(filteredEffects);\r\n  }\r\n}\r\n\r\nfunction updateBots(data, bots) {\r\n  if (data.bots && data.bots.length > 0) {\r\n    setTimeSinceMessageFromMaster(0);\r\n\r\n    for (const receivedBot of data.bots) {\r\n      // Find the corresponding local bot by ID\r\n      const localBot = findBotById(receivedBot.id);\r\n\r\n      if (localBot) {\r\n        if (localBot.isDead && !receivedBot.isDead) {\r\n          //if we are getting respawn info just set the new coordinates\r\n          localBot.x = receivedBot.x;\r\n          localBot.y = receivedBot.y;\r\n          localBot.vel.x = receivedBot.vel.x;\r\n          localBot.vel.y = receivedBot.vel.y;\r\n        } else {\r\n          // else interpolate to smooth the update\r\n          const xDiff = Math.abs(receivedBot.x - localBot.x);\r\n          const yDiff = Math.abs(receivedBot.y - localBot.y);\r\n\r\n          if (xDiff <= threshold && yDiff <= threshold) {\r\n            // Interpolate x and y values\r\n            localBot.x = localBot.x + (receivedBot.x - localBot.x) * interpFactor;\r\n            localBot.y = localBot.y + (receivedBot.y - localBot.y) * interpFactor;\r\n          } else {\r\n            // Update x and y values directly\r\n            localBot.x = receivedBot.x;\r\n            localBot.y = receivedBot.y;\r\n          }\r\n\r\n          // Check if velocities are further apart than the threshold\r\n          const velXDiff = Math.abs(receivedBot.vel.x - localBot.vel.x);\r\n          const velYDiff = Math.abs(receivedBot.vel.y - localBot.vel.y);\r\n\r\n          if (velXDiff > velocityThreshold || velYDiff > velocityThreshold) {\r\n            // Interpolate velocities\r\n            localBot.vel.x = localBot.vel.x + (receivedBot.vel.x - localBot.vel.x) * velocityInterpFactor;\r\n            localBot.vel.y = localBot.vel.y + (receivedBot.vel.y - localBot.vel.y) * velocityInterpFactor;\r\n          } else {\r\n            // Update velocities directly\r\n            localBot.vel.x = receivedBot.vel.x;\r\n            localBot.vel.y = receivedBot.vel.y;\r\n          }\r\n        }\r\n        localBot.setIsDead(receivedBot.isDead);\r\n\r\n        // Don't interpolate the angle because that can naturally change very sharply\r\n        localBot.setAngle(receivedBot.angle);\r\n        localBot.currentSpeed = receivedBot.currentSpeed;\r\n        localBot.timeOfLastActive = receivedBot.timeOfLastActive;\r\n        localBot.playerAngleData = receivedBot.playerAngleData;\r\n        localBot.mousePosX = receivedBot.mousePosX;\r\n        localBot.mousePosY = receivedBot.mousePosY;\r\n        localBot.isPlaying = receivedBot.isPlaying;\r\n        localBot.special = receivedBot.special;\r\n        localBot.distanceFactor = receivedBot.distanceFactor;\r\n        localBot.lives = receivedBot.lives;\r\n        localBot.space = receivedBot.space;\r\n        localBot.shift = receivedBot.shift;\r\n        if (receivedBot.resetting != null) {\r\n          localBot.resetting = receivedBot.resetting;\r\n        }\r\n        localBot.u = receivedBot.u;\r\n        localBot.forceCoolDown = receivedBot.forceCoolDown;\r\n        localBot.setComboScaler(receivedBot.comboScaler);\r\n        localBot.kills = receivedBot.kills;\r\n        localBot.ticksSincePowerUpCollection = receivedBot.ticksSincePowerUpCollection;\r\n        localBot.timeSinceSpawned = receivedBot.timeSinceSpawned;\r\n        localBot.botState = receivedBot.botState;\r\n        localBot.target = receivedBot.target;\r\n        localBot.followingPlayerID = receivedBot.followingPlayerID;\r\n        localBot.previousAngleDifference = receivedBot.previousAngleDifference;\r\n        localBot.previousTurnDirection = receivedBot.previousTurnDirection;\r\n        localBot.setInvincibleTimer(receivedBot.invincibleTimer);\r\n        localBot.forceCoolDown = receivedBot.forceCoolDown;\r\n        localBot.playerAngleData = receivedBot.playerAngleData;\r\n        localBot.mousePosX = receivedBot.mousePosX;\r\n        localBot.mousePosY = receivedBot.mousePosY;\r\n        if (receivedBot.name != null && receivedBot.name != \"\") {\r\n          localBot.name = receivedBot.name;\r\n        }\r\n        if (receivedBot.inForce != null) {\r\n          localBot.inForce = receivedBot.inForce;\r\n        }\r\n      } else {\r\n        // If the local bot doesn't exist, add it to the bots array\r\n        bots.push(createBotFromObject(receivedBot));\r\n      }\r\n    }\r\n\r\n    updateBotsFromFullSend(data, bots);\r\n    // This ensures that local bots that have been removed on the master peer are also removed locally\r\n    setBots(bots.filter((localBot) => data.bots.some((receivedBot) => receivedBot.id === localBot.id)));\r\n  }\r\n}\r\n\r\nfunction updateBotsFromFullSend(data, bots) {\r\n  if (data.fullSend && data.bots) {\r\n    // Create a new bots array by filtering only the bots that exist in data.bots\r\n    const updatedBots = bots.filter((botToCheck) => botToCheck.id == null || data.bots.some((dataBot) => dataBot.id === botToCheck.id));\r\n\r\n    // Update the bots array once\r\n    setBots(updatedBots);\r\n  }\r\n}\r\n\r\nfunction removeBots(data, bots) {\r\n  if (data.removeBots && data.removeBots.length > 0) {\r\n    for (let dataBot of data.removeBots) {\r\n      if (dataBot.id != null) {\r\n        let matchingBot = bots.find((currentBot) => currentBot.id === dataBot.id);\r\n        if (matchingBot == null) {\r\n          setBots(bots.filter((bot) => bot.id !== dataBot.id));\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction updateLocalForce(localForce, receivedForce, playerId) {\r\n  if (localForce.tracks == null || localForce.tracks.id != playerId) {\r\n    const xDiff = Math.abs(receivedForce.x - localForce.x);\r\n    const yDiff = Math.abs(receivedForce.y - localForce.y);\r\n\r\n    if (xDiff <= threshold && yDiff <= threshold) {\r\n      // Interpolate x and y values\r\n      localForce.x = localForce.x + (receivedForce.x - localForce.x) * interpFactor;\r\n      localForce.y = localForce.y + (receivedForce.y - localForce.y) * interpFactor;\r\n    } else {\r\n      // Update x and y values directly\r\n      localForce.x = receivedForce.x;\r\n      localForce.y = receivedForce.y;\r\n    }\r\n\r\n    localForce.force = receivedForce.force;\r\n    localForce.duration = receivedForce.duration;\r\n    localForce.radius = receivedForce.radius;\r\n    localForce.isAttractive = receivedForce.isAttractive;\r\n    localForce.color = receivedForce.color;\r\n    localForce.tracks = receivedForce.tracks;\r\n    localForce.coneAngle = receivedForce.coneAngle;\r\n    localForce.direction = receivedForce.direction;\r\n    localForce.type = receivedForce.type;\r\n    localForce.width = receivedForce.width;\r\n    localForce.length = receivedForce.length;\r\n    localForce.numberArrowsEachSide = receivedForce.numberArrowsEachSide;\r\n    localForce.numberArrowsDeep = receivedForce.numberArrowsDeep;\r\n  }\r\n}\r\n\r\nfunction updateForces(data, player, forces, playerId) {\r\n  if (data.forces && data.forces.length > 0) {\r\n    setTimeSinceMessageFromMaster(0);\r\n\r\n    for (const receivedForce of data.forces) {\r\n      // Find the corresponding local bot by ID\r\n      const localForce = findForceById(receivedForce.id);\r\n      if (localForce) {\r\n        updateLocalForce(localForce, receivedForce, playerId);\r\n      } else if (receivedForce.tracks == null || receivedForce.tracks.id != player.id) {\r\n        // If the local force doesn't exist, add it to the forces array\r\n        forces.push(createForceFromObject(receivedForce));\r\n      }\r\n    }\r\n\r\n    if (data.fullSend && data.forces) {\r\n      // Create a new forces array by filtering only the forces that exist in data.forces\r\n      const updatedForces = forces.filter(\r\n        (forceToCheck) => forceToCheck.id == null || data.forces.some((dataForce) => dataForce.id === forceToCheck.id)\r\n      );\r\n\r\n      // Update the forces array once\r\n      setForces(updatedForces);\r\n    }\r\n  }\r\n}\r\n\r\nfunction removeForces(data, forces) {\r\n  if (data.removeForces && data.removeForces.length > 0) {\r\n    let filteredForces = [...forces];\r\n    for (let dataForce of data.removeForces) {\r\n      if (dataForce.id != null) {\r\n        filteredForces = filteredForces.filter((force) => force.id !== dataForce.id);\r\n      }\r\n    }\r\n    // Update the forces array once after the loop\r\n    setForces(filteredForces);\r\n  }\r\n}\r\n","import { camX, camY, getGameState, setGameState, getCanvas, GameState, player } from \"./main.js\";\r\nimport {\r\n  drawNameEntry,\r\n  drawInputField,\r\n  playButtonX,\r\n  playButtonY,\r\n  playButtonWidth,\r\n  playButtonHeight,\r\n  menuButtonX,\r\n  menuButtonY,\r\n  menuButtonWidth,\r\n  menuButtonHeight,\r\n} from \"./canvasDrawingFunctions.js\";\r\nimport { getFirebase } from \"./db.js\";\r\nimport { getRandomName } from \"./generateEntities.js\";\r\nimport { pilots, max_player_name } from \"./gameLogic.js\";\r\nimport { calculateAngle } from \"./gameUtils.js\";\r\nimport { loginButton, firebaseGoogleLogin } from \"./login.js\";\r\n\r\nlet pilotMouseMoveListener;\r\nlet pilotClickListener;\r\nlet keysDown = {};\r\n\r\nlet keys = {\r\n  up: false,\r\n  down: false,\r\n  left: false,\r\n  right: false,\r\n  space: false,\r\n  shift: false,\r\n  u: false,\r\n};\r\n\r\nexport let mousePos = { x: 0, y: 0 };\r\nexport { handleInputEvents };\r\n\r\nexport function handleMouseMove(canvas, evt, player) {\r\n  let coords = getMousePos(canvas, evt);\r\n  handleMouseMoveDirect(coords.x, coords.y, player);\r\n}\r\n\r\nexport function handleMouseMoveDirect(x, y, player) {\r\n  mousePos.x = x + camX;\r\n  mousePos.y = y + camY;\r\n  player.absoluteMousePosX = x;\r\n  player.absoluteMousePosY = y;\r\n  player.mousePosX = mousePos.x;\r\n  player.mousePosY = mousePos.y;\r\n}\r\n\r\nfunction handleInputEvents(canvas, player) {\r\n  window.addEventListener(\"keydown\", function (e) {\r\n    if (e.code === \"Space\") {\r\n      player.space = true;\r\n      keys.space = true;\r\n    }\r\n    if (e.code === \"Shift\") {\r\n      player.shift = true;\r\n      keys.shift = true;\r\n    }\r\n    if (e.ctrlKey && e.key === \"b\") {\r\n      player.setDevMode(true);\r\n    }\r\n  });\r\n\r\n  window.addEventListener(\"keyup\", function (e) {\r\n    if (e.code === \"Space\") {\r\n      player.space = false;\r\n      keys.space = false;\r\n    }\r\n    if (e.code === \"Shift\") {\r\n      player.shift = false;\r\n      keys.shift = false;\r\n    }\r\n  });\r\n\r\n  canvas.addEventListener(\r\n    \"mousemove\",\r\n    function (evt) {\r\n      handleMouseMove(canvas, evt, player);\r\n    },\r\n    false\r\n  );\r\n\r\n  function getMousePos(canvas, evt) {\r\n    let rect = canvas.getBoundingClientRect();\r\n    return {\r\n      x: evt.clientX - rect.left,\r\n      y: evt.clientY - rect.top,\r\n    };\r\n  }\r\n\r\n  canvas.addEventListener(\"mousedown\", function (e) {\r\n    if (e.button === 2) {\r\n      player.shift = true;\r\n      keys.shift = true;\r\n    } else if (e.button === 1) {\r\n      player.u = true;\r\n      keys.u = true;\r\n      if (keys.shift && keys.space) {\r\n        player.setDevMode(true);\r\n      }\r\n    } else {\r\n      player.space = true;\r\n      keys.space = true;\r\n    }\r\n  });\r\n\r\n  canvas.addEventListener(\"mouseup\", function (e) {\r\n    if (e.button === 2) {\r\n      player.shift = false;\r\n      keys.shift = false;\r\n    } else if (e.button === 1) {\r\n      player.u = false;\r\n      keys.u = false;\r\n    } else {\r\n      player.space = false;\r\n      keys.space = false;\r\n    }\r\n  });\r\n\r\n  canvas.addEventListener(\"touchstart\", function (e) {\r\n    player.space = true;\r\n    keys.space = true;\r\n\r\n    // Update mouse position on touch start\r\n    if (e.touches) {\r\n      mousePos.x = e.touches[0].clientX + camX;\r\n      mousePos.y = e.touches[0].clientY + camY;\r\n      player.mousePosX = mousePos.x;\r\n      player.mousePosY = mousePos.y;\r\n      player.setAngle(calculateAngle(player));\r\n    }\r\n  });\r\n\r\n  canvas.addEventListener(\"touchend\", function (e) {\r\n    player.space = false;\r\n    keys.space = false;\r\n  });\r\n\r\n  canvas.addEventListener(\r\n    \"touchmove\",\r\n    function (e) {\r\n      // Prevent scrolling when touching the canvas\r\n      e.preventDefault();\r\n\r\n      if (e.touches) {\r\n        let coords = getMousePos(canvas, e.touches[0]);\r\n        mousePos.x = coords.x + camX;\r\n        mousePos.y = coords.y + camY;\r\n        player.mousePosX = mousePos.x;\r\n        player.mousePosY = mousePos.y;\r\n        player.setAngle(calculateAngle(player));\r\n      }\r\n    },\r\n    { passive: false }\r\n  ); // Set passive to false to prevent scrolling\r\n}\r\n\r\nfunction getMousePos(canvas, evt) {\r\n  var rect = canvas.getBoundingClientRect();\r\n  return {\r\n    x: evt.clientX - rect.left,\r\n    y: evt.clientY - rect.top,\r\n  };\r\n}\r\n\r\nexport function addPilotEventListners(canvas, ctx) {\r\n  pilotMouseMoveListener = function (event) {\r\n    if (getGameState() === GameState.PILOT_SELECT || getGameState() === GameState.INTRO) {\r\n    }\r\n  };\r\n\r\n  //selectPilot();\r\n  pilotClickListener = function (event) {\r\n    //just in case set canvas back\r\n    canvas.style.left = \"0px\";\r\n    canvas.style.top = \"0px\";\r\n    //x and y that are passed to drawNameEntry, need to remove the need for this duplication\r\n    let x = canvas.width / 2 - 100;\r\n    let y = 80;\r\n    // Play button dimensions and location\r\n    let buttonX = x + 50;\r\n    let buttonY = y + 70;\r\n    let buttonWidth = 100;\r\n    let buttonHeight = 20;\r\n\r\n    // Check if the mouse click is within the bounds of the play button\r\n    if (event.clientX > buttonX && event.clientX < buttonX + buttonWidth && event.clientY > buttonY && event.clientY < buttonY + buttonHeight) {\r\n      // Play button has been clicked\r\n      // selectPilot();\r\n      // setGameState(GameState.GAME);\r\n      startGame();\r\n    }\r\n    // Iterate over pilots\r\n    for (let i = 0; i < pilots.length; i++) {\r\n      let pilot = pilots[i];\r\n\r\n      if (event.clientX > pilot.x && event.clientX < pilot.x + pilot.width && event.clientY > pilot.y && event.clientY < pilot.y + pilot.height) {\r\n        pilot.setSelected(true);\r\n        for (let i = 0; i < pilots.length; i++) {\r\n          let otherPilot = pilots[i];\r\n          if (pilot != otherPilot) {\r\n            otherPilot.setSelected(false);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  canvas.addEventListener(\"click\", pilotClickListener);\r\n  canvas.addEventListener(\"mousemove\", pilotMouseMoveListener);\r\n}\r\n\r\nfunction selectPilot() {\r\n  if (getGameState() === GameState.PILOT_SELECT || getGameState() === GameState.INTRO) {\r\n    // Check if a pilot was clicked\r\n    let pilotSelected = null; // Initialize pilotSelected to null\r\n\r\n    for (let i = 0; i < pilots.length; i++) {\r\n      let pilot = pilots[i];\r\n\r\n      if (pilot.selected) {\r\n        pilotSelected = pilot.name;\r\n        break; // Exit the loop once a pilot is selected\r\n      }\r\n    }\r\n\r\n    if (pilotSelected) {\r\n      // If a pilot was selected, update the player object and change the game state to 'game'\r\n      player.setPilot(pilotSelected);\r\n    }\r\n  }\r\n}\r\n\r\nexport function removePilotsEventListeners(canvas) {\r\n  canvas.removeEventListener(\"mousemove\", pilotMouseMoveListener);\r\n  canvas.removeEventListener(\"click\", pilotClickListener);\r\n}\r\n\r\nfunction handleNameKeyDown(event) {\r\n  // Check if the key is already down\r\n  if (keysDown[event.key]) {\r\n    return;\r\n  }\r\n  keysDown[event.key] = true;\r\n\r\n  // Check if the key pressed is a printable character\r\n  if (/^[\\x20-\\x7E]$/.test(event.key) && player.getPlayerName().length < max_player_name) {\r\n    // player.name += event.key;\r\n    player.setPlayerName(player.getPlayerName() + event.key);\r\n  } else if (event.key === \"Backspace\") {\r\n    //player.name = player.name.slice(0, -1);\r\n    player.setPlayerName(player.getPlayerName().slice(0, -1));\r\n  }\r\n  // Check if the key pressed is enter\r\n  else if (event.key === \"Enter\") {\r\n    // setGameState(GameState.PILOT_SELECT);\r\n    //setGameState(GameState.GAME);\r\n    startGame();\r\n  }\r\n\r\n  if (player.getPlayerName().length >= max_player_name) {\r\n    //inform the user somehow\r\n  }\r\n\r\n  // Redraw name entry\r\n  drawNameEntry(getCanvas(), getCanvas().getContext(\"2d\"), player.getPlayerName(), getCanvas().width / 2 - 100, 80);\r\n}\r\n\r\nfunction startGame() {\r\n  if (player.getPlayerName() == \"\") {\r\n    player.setPlayerName(getRandomName());\r\n  }\r\n  selectPilot();\r\n  setGameState(GameState.GAME);\r\n}\r\n\r\nexport function handleNameKeyUp(event) {\r\n  // Remove the key from the keysDown object\r\n  delete keysDown[event.key];\r\n}\r\n\r\nexport function handleWinStateKeyDown(event) {\r\n  // Check if the key pressed is enter\r\n  if (event.key === \"Enter\") {\r\n    setGameState(GameState.GAME);\r\n  }\r\n  if (event.key === \"r\") {\r\n    setGameState(GameState.INTRO);\r\n  }\r\n}\r\n\r\nexport function handleGameKeyDown(event) {\r\n  // Handle game-specific keydown events here\r\n}\r\n\r\nexport function handleGameKeyUp(event) {\r\n  // Handle game-specific keyup events here\r\n}\r\n\r\nexport function setupNameEventListeners(window) {\r\n  window.addEventListener(\"keydown\", handleNameKeyDown);\r\n  window.addEventListener(\"keyup\", handleNameKeyUp);\r\n}\r\nexport function removeNameEventListeners(window) {\r\n  window.removeEventListener(\"keydown\", handleNameKeyDown);\r\n  window.removeEventListener(\"keyup\", handleNameKeyUp);\r\n}\r\n\r\nexport function setupGameEventListeners() {}\r\nexport function removeGameStateEventListeners() {}\r\nexport function setupWinStateEventListeners(window, canvas) {\r\n  // window.addEventListener(\"keydown\", handleWinStateKeyDown);\r\n  canvas.addEventListener(\"click\", handleWinStateClick);\r\n}\r\n\r\nexport function removeWinStateEventListeners(window, canvas) {\r\n  // window.removeEventListener(\"keydown\", handleWinStateKeyDown);\r\n  canvas.removeEventListener(\"click\", handleWinStateClick);\r\n}\r\n\r\nfunction handleWinStateClick(event) {\r\n  //just in case set canvas back\r\n  this.style.left = \"0px\";\r\n  this.style.top = \"0px\";\r\n  // Play button dimensions and location\r\n  let buttonX = playButtonX;\r\n  let buttonY = playButtonY;\r\n  let buttonWidth = playButtonWidth;\r\n  let buttonHeight = playButtonHeight;\r\n\r\n  // Check if the mouse click is within the bounds of the play button\r\n  if (event.clientX > buttonX && event.clientX < buttonX + buttonWidth && event.clientY > buttonY && event.clientY < buttonY + buttonHeight) {\r\n    // Play button has been clicked\r\n    setGameState(GameState.GAME);\r\n  }\r\n  buttonX = menuButtonX;\r\n  buttonY = menuButtonY;\r\n  buttonWidth = menuButtonWidth;\r\n  buttonHeight = menuButtonHeight;\r\n  // Check if the mouse click is within the bounds of the menu button\r\n  if (event.clientX > buttonX && event.clientX < buttonX + buttonWidth && event.clientY > buttonY && event.clientY < buttonY + buttonHeight) {\r\n    // Menu button has been clicked\r\n    setGameState(GameState.INTRO);\r\n  }\r\n}\r\n\r\nexport function removeLoginHandler(ctx) {\r\n  ctx.canvas.removeEventListener(\"click\", handleLoginButtonClick);\r\n}\r\n\r\nexport function addLoginHandler(ctx) {\r\n  ctx.canvas.removeEventListener(\"click\", handleLoginButtonClick);\r\n  ctx.canvas.addEventListener(\"click\", (event) => handleLoginButtonClick(event, ctx));\r\n}\r\n// Add a click event listener to handle login button click.\r\nfunction handleLoginButtonClick(event, ctx) {\r\n  let firebase = getFirebase();\r\n  let user = firebase.auth().currentUser;\r\n  if (user) {\r\n    console.log(\"Already logged in\");\r\n    return;\r\n  }\r\n  const mouseX = event.clientX - ctx.canvas.getBoundingClientRect().left;\r\n  const mouseY = event.clientY - ctx.canvas.getBoundingClientRect().top;\r\n\r\n  // Calculate the new position of the login button based on the updated drawing code.\r\n  const loginButtonX = ctx.canvas.width - loginButton.width - loginButton.x;\r\n  const loginButtonY = loginButton.y;\r\n\r\n  if (mouseX >= loginButtonX && mouseX <= loginButtonX + loginButton.width && mouseY >= loginButtonY && mouseY <= loginButtonY + loginButton.height) {\r\n    // Handle login button click event.\r\n    if (user) {\r\n      // User is signed in, handle sign out or other actions.\r\n      // For example:\r\n      // signOut();\r\n    } else {\r\n      // User is not signed in, handle sign in.\r\n      firebaseGoogleLogin(firebase);\r\n    }\r\n  }\r\n}\r\n","import { player } from \"./main.js\";\r\nimport { DbPropertyKey, DbDocumentKey, incrementFirebaseGivenPropertyValue, readUserDataFromFirestore, updateAchievements } from \"./db.js\";\r\nimport { setAchievementsTitle } from \"/gameLogic.js\";\r\n\r\nconst emailInput = {\r\n  x: 50,\r\n  y: 50,\r\n  width: 200,\r\n  height: 30,\r\n  text: \"\",\r\n};\r\n\r\nconst passwordInput = {\r\n  x: 50,\r\n  y: 100,\r\n  width: 200,\r\n  height: 30,\r\n  text: \"\",\r\n};\r\n\r\nexport const loginButton = {\r\n  x: 50,\r\n  y: 50,\r\n  width: 200,\r\n  height: 40,\r\n  text: \"Login with Google\",\r\n};\r\n\r\nexport const achievementsTitleText = {\r\n  YOUR_ACHIEVEMENTS: \"Your achievements\",\r\n  LOGIN_TO_TRACK: \"login to track your achievements\",\r\n};\r\n\r\nlet googleSignInPopupOpen = false;\r\n\r\n// Function to draw a rounded rectangle.\r\nfunction drawRoundRect(ctx, x, y, width, height, radius) {\r\n  ctx.beginPath();\r\n  ctx.moveTo(x + radius, y);\r\n  ctx.lineTo(x + width - radius, y);\r\n  ctx.arcTo(x + width, y, x + width, y + radius, radius);\r\n  ctx.lineTo(x + width, y + height - radius);\r\n  ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);\r\n  ctx.lineTo(x + radius, y + height);\r\n  ctx.arcTo(x, y + height, x, y + height - radius, radius);\r\n  ctx.lineTo(x, y + radius);\r\n  ctx.arcTo(x, y, x + radius, y, radius);\r\n  ctx.closePath();\r\n  ctx.fill();\r\n  ctx.stroke();\r\n}\r\n\r\nexport function drawLoginForm(ctx) {\r\n  // Function to calculate the width of the text.\r\n  function getTextWidth(text, font) {\r\n    ctx.font = font;\r\n    return ctx.measureText(text).width;\r\n  }\r\n\r\n  // Could update loginButton text here... but then I'm doing that every tick...\r\n\r\n  // Calculate the width of the updated text.\r\n  const textWidth = getTextWidth(loginButton.text, \"bold 12px Arial\");\r\n\r\n  // Adjust the button width to fit the text.\r\n  loginButton.width = textWidth + 50; // You can adjust the padding as needed.\r\n\r\n  // Draw login button.\r\n  ctx.fillStyle = \"blue\";\r\n  drawRoundRect(ctx, ctx.canvas.width - loginButton.width - loginButton.x, loginButton.y, loginButton.width, loginButton.height, 5);\r\n\r\n  ctx.fillStyle = \"white\";\r\n  ctx.fillText(loginButton.text, ctx.canvas.width - loginButton.width - loginButton.x + 25, loginButton.y + 20);\r\n}\r\n\r\nfunction firebaseLogin(firebase, email, password) {\r\n  // Initialize Firebase app if it's not already initialized.\r\n  if (!firebase.apps.length) {\r\n    firebase.initializeApp(firebaseConfig);\r\n  }\r\n\r\n  firebase\r\n    .auth()\r\n    .signInWithEmailAndPassword(email, password)\r\n    .then((userCredential) => {\r\n      // User signed in with email and password.\r\n      const user = userCredential.user;\r\n      console.log(`Signed in as ${user.email}`);\r\n      loginButton.text = `${user.email}`;\r\n      player.setPlayerName(user.displayName);\r\n      setAchievementsTitle(achievementsTitleText.YOUR_ACHIEVEMENTS);\r\n    })\r\n    .catch((error) => {\r\n      // Handle login errors.\r\n      const errorCode = error.code;\r\n      const errorMessage = error.message;\r\n      console.error(`Login failed with error code: ${errorCode}, message: ${errorMessage}`);\r\n      // You can display an error message to the user on the canvas or in another way.\r\n    });\r\n}\r\n\r\nexport function firebaseGoogleLogin() {\r\n  // If a popup is already open, don't open another one.\r\n  if (googleSignInPopupOpen) {\r\n    return;\r\n  }\r\n\r\n  const googleAuthProvider = new firebase.auth.GoogleAuthProvider();\r\n\r\n  // Set the boolean variable to true to indicate that a popup is open.\r\n  googleSignInPopupOpen = true;\r\n\r\n  firebase\r\n    .auth()\r\n    .signInWithPopup(googleAuthProvider)\r\n    .then((userCredential) => {\r\n      // User signed in with Google.\r\n      const user = userCredential.user;\r\n      console.log(`Signed in with Google as ${user.displayName}`);\r\n      loginButton.text = `${user.email}`;\r\n      player.setPlayerName(user.displayName);\r\n      setSignInCookie();\r\n      //   updateLoginsCount(firebase);\r\n      //   incrementFirebaseLoginsValue(firebase);\r\n      incrementFirebaseGivenPropertyValue(firebase, DbPropertyKey.LOGINS, 1);\r\n      setAchievementsTitle(achievementsTitleText.YOUR_ACHIEVEMENTS);\r\n    })\r\n    .catch((error) => {\r\n      // Handle Google Sign-In errors.\r\n      const errorCode = error.code;\r\n      const errorMessage = error.message;\r\n      console.error(`Google Sign-In failed with error code: ${errorCode}, message: ${errorMessage}`);\r\n      // You can display an error message to the user on the canvas or in another way.\r\n    })\r\n    .finally(() => {\r\n      // Set the boolean variable to false when the popup is closed.\r\n      googleSignInPopupOpen = false;\r\n    });\r\n}\r\n\r\nfunction setSignInCookie() {\r\n  const expirationDate = new Date();\r\n  expirationDate.setDate(expirationDate.getDate() + 7); // Cookie expires in 7 days\r\n  document.cookie = `user_signed_in=true; expires=${expirationDate.toUTCString()}; path=/`;\r\n}\r\n\r\n// Function to check if the user is signed in (cookie exists).\r\nfunction isUserSignedIn() {\r\n  const cookies = document.cookie.split(\"; \");\r\n  for (const cookie of cookies) {\r\n    const [name, value] = cookie.split(\"=\");\r\n    if (name === \"user_signed_in\" && value === \"true\") {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function autoSignInWithGoogle(firebase) {\r\n  if (!isUserSignedIn()) {\r\n    // Don't want to auto make them login\r\n    // firebaseGoogleLogin();\r\n  } else if (!firebase.auth().currentUser) {\r\n    // If the user is signed in via the cookie but not authenticated in the current session we log them in again.\r\n    firebaseGoogleLogin();\r\n  } else {\r\n    //handle user logged in\r\n    // updateLoginsCount(firebase);\r\n    //   incrementFirebaseLoginsValue(firebase);\r\n    incrementFirebaseGivenPropertyValue(firebase, DbPropertyKey.LOGINS, 1);\r\n    setAchievementsTitle(achievementsTitleText.YOUR_ACHIEVEMENTS);\r\n    let loginButtonText = `${firebase.auth().currentUser.email}`;\r\n    player.setPlayerName(firebase.auth().currentUser.displayName);\r\n    readUserDataFromFirestore(firebase, DbDocumentKey.USERS, (error, userData) => {\r\n      if (error) {\r\n        if (error.message === \"User not logged in\") {\r\n          console.log(\"User is not logged in.\");\r\n          // Handle not logged in state in your UI.\r\n        } else {\r\n          console.error(`Error reading user data: ${error.message}`);\r\n          // Handle other errors, such as data not found, in your UI.\r\n        }\r\n      } else {\r\n        const loginsCount = userData.logins || 0;\r\n        console.log(`Logins count: ${loginsCount}`);\r\n        // Use the logins count in your UI.\r\n      }\r\n    });\r\n    loginButton.text = loginButtonText;\r\n  }\r\n}\r\n\r\nfunction firebaseLogout() {\r\n  firebase\r\n    .auth()\r\n    .signOut()\r\n    .then(() => {\r\n      // Sign-out successful.\r\n      console.log(\"User signed out\");\r\n      // You can add any post-logout logic here, such as redirecting to a login screen.\r\n      // For example, you could call a function to show the login form:\r\n      // showLoginForm();\r\n    })\r\n    .catch((error) => {\r\n      // Handle errors, if any.\r\n      console.error(\"Logout failed:\", error);\r\n    });\r\n}\r\n\r\n// Function to update the logins count for the current user.\r\nfunction updateLoginsCount(firebase) {\r\n  const user = firebase.auth().currentUser;\r\n\r\n  if (user) {\r\n    const userRef = firebase.firestore().collection(DbDocumentKey.USERS).doc(user.uid);\r\n\r\n    // Get the current logins count and increment it by 1.\r\n    userRef\r\n      .get()\r\n      .then((doc) => {\r\n        if (doc.exists) {\r\n          const loginsCount = doc.data().logins || 0;\r\n          const newLoginsCount = loginsCount + 1;\r\n\r\n          // Update the logins count in Firestore.\r\n          userRef\r\n            .update({ logins: newLoginsCount })\r\n            .then(() => {\r\n              console.log(`Logins count updated to ${newLoginsCount}`);\r\n              // You can also update the user interface with the new logins count here.\r\n            })\r\n            .catch((error) => {\r\n              console.error(`Error updating logins count: ${error}`);\r\n            });\r\n        } else {\r\n          // User document doesn't exist; create it and set logins count to 1.\r\n          userRef\r\n            .set({ logins: 1 })\r\n            .then(() => {\r\n              console.log(\"Logins count created and set to 1\");\r\n              // You can also update the user interface with the logins count here.\r\n            })\r\n            .catch((error) => {\r\n              console.error(`Error creating logins count: ${error}`);\r\n            });\r\n        }\r\n      })\r\n      .catch((error) => {\r\n        console.error(`Error getting user document: ${error}`);\r\n      });\r\n  }\r\n}\r\n","import {\r\n  drawInputField,\r\n  drawNameEntry,\r\n  drawGameOverMessage,\r\n  drawTextCursorFromText,\r\n  updateTopScoresInfo,\r\n  drawPreGameOverlay,\r\n  drawDailyScores,\r\n  drawAchievements,\r\n  setupCarrots,\r\n} from \"./canvasDrawingFunctions.js\";\r\nimport {\r\n  createPeer,\r\n  isPlayerMasterPeer,\r\n  removeClosedConnections,\r\n  setTicksSinceLastConnectionAttempt,\r\n  ticksSinceLastConnectionAttempt,\r\n  setTicksSinceLastFullSendRequestResponse,\r\n  ticksSinceLastFullSendRequestResponse,\r\n  setTimeSinceAnyMessageRecieved,\r\n  timeSinceAnyMessageRecieved,\r\n  timeSinceMessageFromMaster,\r\n  setTimeSinceMessageFromMaster,\r\n  setMasterPeerId,\r\n  chooseNewMasterPeer,\r\n} from \"./connectionHandlers.js\";\r\nimport { addScoreToDB, getFirebase } from \"./db.js\";\r\nimport { setupCanvas, setupSpikeyBallPoints, centerPilots } from \"./drawingUtils.js\";\r\nimport { drawScene } from \"./gameDrawing.js\";\r\nimport { endGameMessage, setGameWon, pilots, masterUpdateGame } from \"./gameLogic.js\";\r\nimport { shuffleArray } from \"./gameUtils.js\";\r\nimport {\r\n  handleInputEvents,\r\n  addPilotEventListners,\r\n  removePilotsEventListeners,\r\n  setupNameEventListeners,\r\n  removeNameEventListeners,\r\n  setupGameEventListeners,\r\n  setupWinStateEventListeners,\r\n  removeWinStateEventListeners,\r\n  addLoginHandler,\r\n  removeLoginHandler,\r\n} from \"./inputHandlers.js\";\r\nimport { drawLoginForm, autoSignInWithGoogle } from \"./login.js\";\r\nimport { sendPlayerStates } from \"./sendData.js\";\r\nimport { Player } from \"./player.js\";\r\n\r\nexport let gameTimer = 0;\r\nexport function setGameTimer(newTime) {\r\n  gameTimer = newTime;\r\n}\r\nexport const { canvas, ctx } = setupCanvas();\r\nexport const worldDimensions = { width: 7200, height: 5400 };\r\nexport const colors = [\r\n  \"red\",\r\n  \"blue\",\r\n  \"SpringGreen\",\r\n  \"green\",\r\n  \"lime\",\r\n  \"cyan\",\r\n  \"indigo\",\r\n  \"purple\",\r\n  \"orange\",\r\n  \"pink\",\r\n  \"MediumVioletRed\",\r\n  \"violet\",\r\n  \"maroon\",\r\n  \"crimson\",\r\n];\r\n\r\nexport const powerUpColors = [\r\n  \"red\",\r\n  \"blue\",\r\n  \"SpringGreen\",\r\n  \"green\",\r\n  \"lime\",\r\n  \"cyan\",\r\n  \"indigo\",\r\n  \"purple\",\r\n  \"orange\",\r\n  \"pink\",\r\n  \"MediumVioletRed\",\r\n  \"violet\",\r\n  \"maroon\",\r\n  \"crimson\",\r\n];\r\nexport const selectedColors = [];\r\n\r\nexport const acceleration = 0.25;\r\n\r\n// let lastTime = Date.now();\r\nlet lastTime = performance.now();\r\nexport let executionTime = 0;\r\nexport const GameState = {\r\n  PILOT_SELECT: \"pilotSelect\",\r\n  INTRO: \"intro\",\r\n  FINISHED: \"finished\",\r\n  GAME: \"game\",\r\n  UNSET: \"\",\r\n};\r\n\r\nlet gameState = GameState.UNSET;\r\nlet accumulator = 0;\r\nexport let fixedDeltaTime = 1 / 60; // 60 updates per second\r\nlet playerToSpectate = null;\r\n//if below is true if there are any connected humans they will first be used to spectate if possible\r\nlet prioritizeHumanSpectate = false;\r\n\r\nexport const player = new Player(null, null, null, 0, null, 0, \"\", \"\", false, true);\r\nplayer.isMaster = true;\r\nplayer.isLocal = true;\r\nexport let otherPlayers = [];\r\nexport let bots = [];\r\nexport let mines = [];\r\nexport let globalPowerUps = [];\r\n\r\nexport let camX = player.x - canvas.width / 2;\r\nexport let camY = player.y - canvas.height / 2;\r\n\r\nexport function setCam(newCamX, newCamY) {\r\n  if (newCamX != null) {\r\n    camX = newCamX;\r\n  }\r\n  if (newCamX != null) {\r\n    camY = newCamY;\r\n  }\r\n}\r\n\r\nconst camSpeedX = 0.065;\r\nconst camSpeedY = 0.11;\r\n\r\nexport function getCanvas() {\r\n  return canvas;\r\n}\r\n\r\nexport function setBots(newBots) {\r\n  if (newBots !== bots) {\r\n    bots.length = 0;\r\n    bots.push(...newBots);\r\n  }\r\n}\r\n\r\nfunction setOtherPlayers(newPlayers) {\r\n  if (newPlayers !== otherPlayers) {\r\n    //update original array\r\n    otherPlayers.length = 0;\r\n    otherPlayers.push(...newPlayers);\r\n\r\n    // Remove player from otherPlayers array\r\n    otherPlayers = otherPlayers.filter((otherPlayer) => otherPlayer.id !== player.id);\r\n  }\r\n}\r\n\r\nfunction updateCamera(playerToFollow, deltaTime) {\r\n  const targetCamX = playerToFollow.x - canvas.width / 2;\r\n  let targetCamY = playerToFollow.y - (canvas.height * 2) / 4;\r\n\r\n  // Calculate the interpolation factor based on deltaTime and camSpeed\r\n  const interpolationFactorX = Math.min(deltaTime * camSpeedX, 1);\r\n  const interpolationFactorY = Math.min(deltaTime * camSpeedY, 1);\r\n\r\n  // Smoothly interpolate the camera's position\r\n  camX = camX + (targetCamX - camX) * interpolationFactorX;\r\n  camY = camY + (targetCamY - camY) * interpolationFactorY;\r\n\r\n  // Make sure the camera stays within the bounds of the world\r\n  camX = Math.max(Math.min(camX, worldDimensions.width - canvas.width), 0);\r\n  camY = Math.max(Math.min(camY, worldDimensions.height - canvas.height), 0);\r\n}\r\n\r\nfunction updateGame(deltaTime, playerActive, camX, camY) {\r\n  //scale deltaTime\r\n  deltaTime *= 100;\r\n\r\n  //todo work out what to do here, do we do this for every local or not?\r\n  if (true || playerActive || isPlayerMasterPeer(player)) {\r\n    //dealing with error state, not sure best approach yet\r\n    if (player.name == \"\" && player.pilot == \"\") {\r\n      setGameState(GameState.INTRO);\r\n      // return;\r\n    }\r\n    //todo might have to uncomment the condition\r\n    // if (isPlayerMasterPeer(player)) {\r\n    // This peer is the master, so it runs the game logic for shared objects\r\n    masterUpdateGame(player, globalPowerUps, otherPlayers, bots, mines, deltaTime, camX, camY);\r\n    // }\r\n  }\r\n\r\n  if (playerActive) {\r\n    updateCamera(player, deltaTime);\r\n    drawScene(player, otherPlayers, bots, mines, ctx, camX, camY, worldDimensions, canvas, globalPowerUps);\r\n  } else {\r\n    camFollowPlayer(deltaTime);\r\n    drawScene(null, otherPlayers, bots, mines, ctx, camX, camY, worldDimensions, canvas, globalPowerUps);\r\n  }\r\n  removeClosedConnections(otherPlayers);\r\n  if (player.isDead) {\r\n    setGameState(GameState.FINISHED);\r\n    player.resetState(true, true);\r\n    //set player.isPlayer = false here?\r\n  }\r\n\r\n  setTicksSinceLastFullSendRequestResponse(ticksSinceLastFullSendRequestResponse + 1);\r\n  setTicksSinceLastConnectionAttempt(ticksSinceLastConnectionAttempt + 1);\r\n  setTimeSinceAnyMessageRecieved(timeSinceAnyMessageRecieved + 1);\r\n  if (timeSinceAnyMessageRecieved > 100 && ticksSinceLastConnectionAttempt > 3000) {\r\n    // wrappedResolveConflicts(player, otherPlayers, globalPowerUps);\r\n    //todo do we need to attemptConnections here?\r\n  }\r\n  if (timeSinceMessageFromMaster > 60 * 15 && !isPlayerMasterPeer(player)) {\r\n    setTimeSinceMessageFromMaster(0);\r\n    //try removing the current master\r\n    //issue could be that peer doesn't think it is the master because it is connected to others.. need to sync connected lists I think.\r\n    // Remove player from otherPlayers array, connections array and connectedPeers (array of id's of the connected peers)\r\n    // otherPlayers = otherPlayers.filter((player) => player.id !== connectedPeers[0]);\r\n    // connections = connections.filter((connection) => connection.peer !== connectedPeers[0]);\r\n    // connectedPeers.splice(0, 1);\r\n    // setTimeout(() => attemptConnections(player, otherPlayers, globalPowerUps), 50);\r\n    // //what about \"connections\" how is connections and connectedPeers synced?\r\n    setMasterPeerId(chooseNewMasterPeer(player, otherPlayers));\r\n\r\n    // wrappedResolveConflicts(player, otherPlayers, globalPowerUps);\r\n  }\r\n}\r\n\r\nfunction camFollowPlayer(deltaTime) {\r\n  let allPlayers = null;\r\n  if (prioritizeHumanSpectate) {\r\n    allPlayers = [...bots, player];\r\n    shuffleArray(allPlayers);\r\n    //let shuffledOtherPlayers = shuffleArray([...otherPlayers]);\r\n    allPlayers = [...otherPlayers, ...bots, player];\r\n  } else {\r\n    allPlayers = [...bots, ...otherPlayers, player];\r\n    shuffleArray(allPlayers);\r\n  }\r\n  let inPlayersList = allPlayers.includes(playerToSpectate);\r\n  if (!inPlayersList && playerToSpectate != null) {\r\n    for (let candidate of allPlayers) {\r\n      if (candidate != null && candidate.id === playerToSpectate.id && candidate.name === playerToSpectate.name) {\r\n        playerToSpectate = candidate;\r\n        inPlayersList = true;\r\n        break; // Exit the loop once a matching player is found\r\n      }\r\n    }\r\n  }\r\n  let recentlyActive = false;\r\n  if (playerToSpectate != null) {\r\n    recentlyActive = playerToSpectate.howLongSinceActive() < 1000;\r\n  }\r\n  if (\r\n    playerToSpectate != null &&\r\n    inPlayersList &&\r\n    (recentlyActive || playerToSpectate.isBot) &&\r\n    !playerToSpectate.isDead &&\r\n    playerToSpectate.isPlaying\r\n  ) {\r\n    updateCamera(playerToSpectate, deltaTime);\r\n  } else {\r\n    for (let candidate of allPlayers) {\r\n      if (candidate != null && candidate.id != player.id && (candidate.howLongSinceActive() < 1000 || candidate.isBot)) {\r\n        if (!candidate.isDead && candidate.isPlaying) {\r\n          playerToSpectate = candidate;\r\n          updateCamera(playerToSpectate, deltaTime);\r\n          break; // Exit the loop once a valid playerToSpectate is found\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction setupPilots(canvas, ctx) {\r\n  addPilotEventListners(canvas, ctx);\r\n  //todo will need to update this if multiple pilots\r\n  let anySelected = false;\r\n  for (let pilot of pilots) {\r\n    if (pilot.selected) {\r\n      anySelected = true;\r\n    }\r\n  }\r\n  if (!anySelected) {\r\n    pilots[0].setSelected(true);\r\n  }\r\n}\r\n\r\nfunction updatePilot() {\r\n  for (let pilot of pilots) {\r\n    if (pilot.selected) {\r\n      pilot.pilotAnimationFrame++;\r\n    }\r\n  }\r\n  drawPreGameOverlay(canvas, ctx);\r\n}\r\n\r\nfunction updateName() {\r\n  const minimapCanvas = document.getElementById(\"minimapCanvas\");\r\n  const minimapCtx = minimapCanvas.getContext(\"2d\");\r\n  minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);\r\n  drawNameEntry(canvas, ctx, player.name, canvas.width / 2 - 100, 80);\r\n}\r\n\r\nfunction updateWinState() {\r\n  //drawScene(player, otherPlayers, bots, mines,ctx, camX, camY, worldDimensions, canvas, globalPowerUps);\r\n  drawGameOverMessage(ctx, canvas, endGameMessage);\r\n  drawDailyScores(ctx);\r\n  drawAchievements(ctx);\r\n}\r\n\r\nexport function setGlobalPowerUps(newPowerUps) {\r\n  if (newPowerUps !== globalPowerUps) {\r\n    //update original array while keeping the reference\r\n    globalPowerUps.length = 0;\r\n    globalPowerUps.push(...newPowerUps);\r\n  }\r\n}\r\n\r\nexport function setMines(newMines) {\r\n  if (newMines !== mines) {\r\n    //update original array while keeping the reference\r\n    mines.length = 0;\r\n    mines.push(...newMines);\r\n  }\r\n}\r\n\r\nexport function getGlobalPowerUps() {\r\n  return globalPowerUps;\r\n}\r\nexport function getGameState() {\r\n  return gameState;\r\n}\r\n\r\nexport function setGameState(newState) {\r\n  if (gameState === newState) {\r\n    return;\r\n  }\r\n  let prevGameState = gameState;\r\n  gameState = newState;\r\n  if (newState === GameState.PILOT_SELECT && prevGameState !== GameState.PILOT_SELECT) {\r\n    setupPilots(canvas, ctx);\r\n  }\r\n\r\n  if (newState !== GameState.PILOT_SELECT && prevGameState === GameState.PILOT_SELECT) {\r\n    removePilotsEventListeners(canvas);\r\n  }\r\n\r\n  if (newState === GameState.INTRO && prevGameState !== GameState.INTRO) {\r\n    player.isPlaying = false;\r\n    player.isDead = false;\r\n    updateTopScoresInfo();\r\n    setupPilots(canvas, ctx);\r\n    setupNameEventListeners(window);\r\n    updateName();\r\n    addLoginHandler(ctx);\r\n  }\r\n\r\n  if (newState !== GameState.INTRO && prevGameState === GameState.INTRO) {\r\n    removeNameEventListeners(window);\r\n    removeLoginHandler(ctx);\r\n  }\r\n\r\n  if (newState === GameState.FINISHED && prevGameState !== GameState.FINISHED) {\r\n    var date = new Date();\r\n    var dateString = date.getFullYear() + \"-\" + (date.getMonth() + 1) + \"-\" + date.getDate();\r\n    var score = Math.floor(Math.random() * 100) + 1;\r\n    addScoreToDB(\"daily-\" + dateString, player.name, player.powerUps * 100);\r\n\r\n    setupWinStateEventListeners(window, canvas);\r\n    removeLoginHandler(ctx);\r\n    if (isPlayerMasterPeer(player)) {\r\n      //do we need this special send?\r\n      sendPlayerStates(player, true, true, true);\r\n    }\r\n  }\r\n\r\n  if (newState !== GameState.FINISHED && prevGameState === GameState.FINISHED) {\r\n    //do we need resetPowerLevels anymore?\r\n    // resetPowerLevels(player, otherPlayers, globalPowerUps);\r\n    setGameWon(false);\r\n    removeWinStateEventListeners(window, canvas);\r\n  }\r\n\r\n  if (newState === GameState.GAME && prevGameState !== GameState.GAME) {\r\n    // fixedDeltaTime = 1 / 60;\r\n    // setupGameEventListeners(window);\r\n\r\n    //todo add back in if not to blame\r\n    player.resetState(true, true);\r\n    player.isPlaying = true;\r\n    player.setIsDead(false);\r\n    sendPlayerStates(player, isPlayerMasterPeer(player), true, true);\r\n\r\n    // setTimeout(() => connectToPeers(player, otherPlayers, globalPowerUps), 1000);\r\n    removePilotsEventListeners(canvas);\r\n    removeLoginHandler(ctx);\r\n  }\r\n\r\n  if (newState !== GameState.GAME && prevGameState === GameState.GAME) {\r\n    //for now moving to showing game underneath all the time\r\n    player.resetState(true, true);\r\n\r\n    player.isPlaying = false;\r\n    player.x = -600;\r\n    player.y = -600;\r\n    player.centerCameraOnPlayer(canvas.width, canvas.height);\r\n    setTimeout(() => updateTopScoresInfo(), 300);\r\n\r\n    //todo addback in if there was a good reason for this\r\n    // globalPowerUps = [];\r\n  }\r\n}\r\n\r\nfunction update() {\r\n  const startTime = performance.now();\r\n  let now = performance.now();\r\n  let deltaTime = (now - lastTime) / 1000; // Time since last frame in seconds\r\n  lastTime = now;\r\n  deltaTime = Math.min(deltaTime, 0.1);\r\n  //if master and we see here have been paused a long time perhaps we need to at least get game state from another before sending out updates?\r\n  accumulator += deltaTime;\r\n\r\n  while (accumulator >= fixedDeltaTime) {\r\n    if (gameState != GameState.GAME) {\r\n      //since we show the ongoing game at all times alway do this\r\n      updateGame(fixedDeltaTime, false, camX, camY);\r\n    }\r\n    if (gameState === GameState.INTRO) {\r\n      updateName();\r\n      drawTextCursorFromText(ctx, player.name);\r\n      updatePilot();\r\n      drawLoginForm(ctx);\r\n    } else if (gameState === GameState.PILOT_SELECT) {\r\n      updatePilot();\r\n    } else if (gameState === GameState.GAME) {\r\n      updateGame(fixedDeltaTime, true, camX, camY);\r\n    } else if (gameState === GameState.FINISHED) {\r\n      updateWinState();\r\n    }\r\n    accumulator -= fixedDeltaTime;\r\n  }\r\n\r\n  const endTime = performance.now();\r\n  executionTime = endTime - startTime;\r\n\r\n  requestAnimationFrame(update);\r\n}\r\n\r\nwindow.addEventListener(\"load\", function () {\r\n  /* START CONNECTION HANDLERS  */\r\n  createPeer(player, otherPlayers, globalPowerUps);\r\n\r\n  setupSpikeyBallPoints();\r\n\r\n  //for now just do this at game start and transition, in future do this periodically?\r\n  updateTopScoresInfo();\r\n  handleInputEvents(canvas, player);\r\n  centerPilots(canvas);\r\n  setupCarrots();\r\n  update();\r\n  setupGameEventListeners(window);\r\n  setGameState(GameState.INTRO);\r\n\r\n  setTimeout(() => autoSignInWithGoogle(getFirebase()), 500);\r\n});\r\n\r\nwindow.addEventListener(\"resize\", function (event) {\r\n  setupCanvas();\r\n});\r\n","import { rotateAndScalePoint, getComplementaryColor, nameToRGBFullFormat, applyGlowingEffect, drawExplosion } from \"./drawingUtils.js\";\r\nimport { MineType } from \"./entities.js\";\r\nimport { mineScale } from \"./collisionLogic.js\";\r\n\r\nfunction drawRegularMine(ctx, centerX, centerY, camX, camY, angle, mineScale, points, outerColor, coreColor, basicAnimationTimer) {\r\n  const glowWidth = 5;\r\n  const shadowBlur = 10;\r\n  let coreRadius = 15;\r\n  const pulseSpeed = 0.0095;\r\n  const blinkSpeed = 0.005;\r\n\r\n  //   coreRadius = basicAnimationTimer % maxCoreRadius;\r\n  coreRadius = coreRadius + Math.sin(basicAnimationTimer * pulseSpeed) * 15;\r\n  // Draw the outer spikey ball with glow and shadow\r\n  ctx.beginPath();\r\n  ctx.shadowBlur = shadowBlur;\r\n  ctx.shadowColor = outerColor;\r\n  ctx.strokeStyle = outerColor;\r\n\r\n  let rotatedPoint = rotateAndScalePoint(points[0].x, points[0].y, angle, mineScale);\r\n  ctx.moveTo(centerX - camX + rotatedPoint.x, centerY - camY + rotatedPoint.y);\r\n\r\n  for (let i = 1; i < points.length; i++) {\r\n    rotatedPoint = rotateAndScalePoint(points[i].x, points[i].y, angle, mineScale);\r\n    ctx.lineTo(centerX - camX + rotatedPoint.x, centerY - camY + rotatedPoint.y);\r\n  }\r\n\r\n  ctx.stroke();\r\n\r\n  // Add a glowing effect\r\n  ctx.strokeStyle = \"rgba(255, 0, 0, 0.5)\"; // Adjust the color and opacity for the glow\r\n  ctx.lineWidth = glowWidth;\r\n  ctx.stroke();\r\n\r\n  // Reset shadow and line width\r\n  ctx.shadowBlur = 0;\r\n  ctx.lineWidth = 1;\r\n\r\n  // Draw the pulsating core\r\n  const coreOpacity = 0.8 + Math.sin(Date.now() * blinkSpeed) * 0.2; // Pulsating opacity\r\n  ctx.fillStyle = coreColor;\r\n  ctx.globalAlpha = coreOpacity;\r\n  ctx.beginPath();\r\n  ctx.arc(centerX - camX, centerY - camY, coreRadius, 0, Math.PI * 2);\r\n  ctx.fill();\r\n  ctx.globalAlpha = 1; // Reset global alpha\r\n}\r\n\r\nfunction drawMineShape(ctx, camX, camY, points, color) {\r\n  if (points == null) {\r\n    console.log(\"no points passed to mine shape draw\");\r\n    return;\r\n  }\r\n  ctx.beginPath();\r\n\r\n  for (let i = 0; i < points.length; i++) {\r\n    const { x, y } = points[i];\r\n    const moveToX = x - camX;\r\n    const moveToY = y - camY;\r\n    ctx.lineTo(moveToX, moveToY);\r\n  }\r\n\r\n  ctx.closePath();\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n}\r\n\r\nfunction drawSpoke(ctx, centerXScreenCoord, centerYScreenCoord, angleRadians, spokeLength, spokeWidth) {\r\n  ctx.lineWidth = spokeWidth;\r\n\r\n  ctx.beginPath();\r\n  ctx.moveTo(centerXScreenCoord, centerYScreenCoord);\r\n\r\n  const spokeEndX = centerXScreenCoord + spokeLength * Math.cos(angleRadians);\r\n  const spokeEndY = centerYScreenCoord + spokeLength * Math.sin(angleRadians);\r\n\r\n  ctx.lineTo(spokeEndX, spokeEndY);\r\n\r\n  let circleRadius = ctx.lineWidth / 8;\r\n  const spokeEndArcDrawPointX = centerXScreenCoord + (spokeLength - circleRadius) * Math.cos(angleRadians);\r\n  const spokeEndArcDrawPointY = centerYScreenCoord + (spokeLength - circleRadius) * Math.sin(angleRadians);\r\n\r\n  // Calculate the coordinates of the point for the arc\r\n  const spokeEndArcDrawPointOnEdgeX = centerXScreenCoord + (circleRadius + spokeLength + spokeWidth) * Math.cos(angleRadians);\r\n  const spokeEndArcDrawPointOnEdgeY = centerYScreenCoord + (circleRadius + spokeLength + spokeWidth) * Math.sin(angleRadians);\r\n  ctx.lineCap = \"round\";\r\n\r\n  ctx.stroke();\r\n  ctx.lineWidth = 1;\r\n}\r\n\r\nfunction drawFreeMine(ctx, camX, camY, angle, mineScale, mine, color, centerX, centerY, animationFrame = 0, explosionEffect = false) {\r\n  let points = mine.points;\r\n  let spokeWidth = mine.spokeWidth;\r\n  let spokeLength = mine.spokeLength;\r\n  if (!explosionEffect) {\r\n    const centerXScreenCoord = centerX - camX;\r\n    const centerYScreenCoord = centerY - camY;\r\n    drawMineShape(ctx, camX, camY, points, color);\r\n\r\n    for (let angleDegrees = 0; angleDegrees < 360; angleDegrees += 45) {\r\n      const angleRadians = (angleDegrees + angle) * (Math.PI / 180);\r\n      drawSpoke(ctx, centerXScreenCoord, centerYScreenCoord, angleRadians, spokeLength, spokeWidth);\r\n    }\r\n  } else {\r\n    drawExplosion(ctx, camX, camY, explosionEffect);\r\n  }\r\n}\r\n\r\nexport function drawMine(ctx, camX, camY, mine, points) {\r\n  let centerX = mine.x;\r\n  let centerY = mine.y;\r\n  let color = mine.color;\r\n  let angle = 0;\r\n  ctx.strokeStyle = color;\r\n  ctx.fillStyle = color;\r\n  ctx.shadowBlur = 0;\r\n  ctx.shadowColor = \"transparent\";\r\n  ctx.globalAlpha = 1;\r\n  const currentTime = Date.now();\r\n  let elapsedTime = currentTime - mine.starTransitionStartTime;\r\n  const transitionDuration = 50;\r\n  if (isNaN(elapsedTime)) {\r\n    elapsedTime = Math.floor(Math.random() * transitionDuration);\r\n  }\r\n  if (!mine.starTransitionStartTime || elapsedTime >= transitionDuration) {\r\n    mine.starTransitionStartTime = currentTime - elapsedTime;\r\n    mine.starTransitionStartColor = color;\r\n  }\r\n  const animationFrame = elapsedTime % transitionDuration;\r\n\r\n  ctx.beginPath();\r\n  if (mine.mineType === MineType.REGULAR) {\r\n    if (mine.hitFrames < -1) {\r\n      applyGlowingEffect(ctx, \"white\", mine.color, \"white\", transitionDuration, animationFrame, 0.2);\r\n    }\r\n    drawRegularMine(ctx, centerX, centerY, camX, camY, angle, mineScale, points, color, \"red\", elapsedTime);\r\n  } else if (mine.mineType === MineType.FREE_MINE) {\r\n    if (!mine.starTransitionStartTime || elapsedTime >= transitionDuration) {\r\n      mine.starTransitionStartTime = currentTime;\r\n      mine.starTransitionStartColor = color;\r\n    }\r\n    applyGlowingEffect(ctx, \"orange\", mine.color, \"white\", transitionDuration, animationFrame, 0.4);\r\n    drawFreeMine(ctx, camX, camY, angle, 1, mine, color, centerX, centerY, animationFrame);\r\n  } else if (mine.mineType === MineType.TRAIL) {\r\n    ctx.fillStyle = color;\r\n    if (mine.duration < 10) {\r\n      ctx.fillStyle = getComplementaryColor(mine.color);\r\n    }\r\n    // Handle trail mines here\r\n    const trailLength = mine.length;\r\n    const trailWidth = mine.width;\r\n\r\n    const trailX = centerX - camX;\r\n    const trailY = centerY - camY;\r\n    angle = mine.angle;\r\n\r\n    // Apply the rotation transformation\r\n    ctx.translate(trailX, trailY);\r\n    ctx.rotate(angle);\r\n\r\n    // Calculate half of the trailLength\r\n    const halfTrailLength = trailLength / 2;\r\n    const halfTrailWidth = trailWidth / 2;\r\n\r\n    // Draw the left circle (start of the sausage)\r\n    ctx.arc(0, -halfTrailLength, halfTrailWidth, 0, Math.PI * 2);\r\n\r\n    // Draw the rectangle (sausage body)\r\n    ctx.rect(-halfTrailWidth, -trailLength / 2, trailWidth, trailLength);\r\n\r\n    // Draw the right circle (end of the sausage)\r\n    ctx.arc(0, -halfTrailLength + trailLength, halfTrailWidth, 0, Math.PI * 2);\r\n\r\n    // // Reset the rotation and translation\r\n    // ctx.rotate(-angle);\r\n    // ctx.translate(-trailX, -trailY);\r\n    ctx.fill();\r\n\r\n    // Save the current global composite operation\r\n    const prevGlobalCompositeOperation = ctx.globalCompositeOperation;\r\n    // Set the global composite operation to 'source-over' to blend the new content\r\n    ctx.globalCompositeOperation = \"source-over\";\r\n    // Create a radial gradient to simulate the vapor trail with your color\r\n    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, halfTrailWidth);\r\n    let rgbColor = nameToRGBFullFormat(color);\r\n    gradient.addColorStop(0, `rgba(${rgbColor.r}, ${rgbColor.g}, ${rgbColor.b}, 1)`); // Inner part of the trail\r\n    gradient.addColorStop(1, `rgba(${rgbColor.r}, ${rgbColor.g}, ${rgbColor.b}, 0.5)`); // Outer part of the trail\r\n\r\n    // ctx.fillStyle = gradient;\r\n    ctx.fillStyle = `rgba(${rgbColor.r}, ${rgbColor.g}, ${rgbColor.b}, 0.1)`;\r\n    // Draw the rectangle (sausage body)\r\n    ctx.rect(-halfTrailWidth - 20, -trailLength / 2 - 20, trailWidth + 40, trailLength + 40);\r\n    ctx.fill();\r\n    // Reset the rotation and translation\r\n    ctx.rotate(-angle);\r\n    ctx.translate(-trailX, -trailY);\r\n    // Restore the previous global composite operation\r\n    ctx.globalCompositeOperation = prevGlobalCompositeOperation;\r\n  }\r\n\r\n  ctx.closePath();\r\n  ctx.strokeStyle = color;\r\n  ctx.fillStyle = color;\r\n  ctx.lineWidth = 1;\r\n  ctx.shadowBlur = 0;\r\n  ctx.shadowColor = \"transparent\";\r\n  ctx.globalAlpha = 1;\r\n}\r\n","import { shouldSkipPlayer } from \"./drawingUtils.js\";\r\n\r\n// Export a drawMinimap function\r\nexport function drawMinimap(player, otherPlayers, bots, worldWidth, worldHeight) {\r\n  const minimapCanvas = document.getElementById(\"minimapCanvas\");\r\n  const minimapCtx = minimapCanvas.getContext(\"2d\");\r\n\r\n  const dotSize = 5; // Size of the dot\r\n  const scaleX = (minimapCanvas.width - dotSize) / worldWidth; // Adjust scale\r\n  const scaleY = (minimapCanvas.height - dotSize) / worldHeight; // Adjust scale\r\n\r\n  // Clear the minimap\r\n  minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);\r\n\r\n  // Draw a semi-transparent background with a border\r\n  minimapCtx.fillStyle = \"rgba(0, 128, 0, 0.2)\"; // Semi-transparent green\r\n  minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);\r\n  minimapCtx.strokeStyle = \"rgba(255, 255, 255, 0.8)\"; // White border\r\n  minimapCtx.lineWidth = 3; // Border width\r\n  minimapCtx.strokeRect(0, 0, minimapCanvas.width, minimapCanvas.height);\r\n\r\n  // Draw the player's ship on the minimap\r\n  if (!shouldSkipPlayer(player)) {\r\n    drawMiniMapEntity(player, minimapCtx, scaleX, scaleY, dotSize);\r\n  }\r\n\r\n  // Draw other players on the minimap\r\n  otherPlayers.forEach((otherPlayer) => {\r\n    if (!shouldSkipPlayer(otherPlayer)) {\r\n      drawMiniMapEntity(otherPlayer, minimapCtx, scaleX, scaleY, dotSize);\r\n    }\r\n  });\r\n\r\n  // Draw bots on the minimap\r\n  bots.forEach((bot) => {\r\n    drawMiniMapEntity(bot, minimapCtx, scaleX, scaleY, dotSize);\r\n  });\r\n}\r\n\r\nexport function drawMinimapPowerups(globalPowerUps, worldWidth, worldHeight) {\r\n  const minimapCanvas = document.getElementById(\"minimapCanvas\");\r\n  const minimapCtx = minimapCanvas.getContext(\"2d\");\r\n\r\n  const powerupSize = 3; // Smaller size for powerups on the minimap\r\n  const scaleX = (minimapCanvas.width - powerupSize) / worldWidth; // Adjust scale\r\n  const scaleY = (minimapCanvas.height - powerupSize) / worldHeight; // Adjust scale\r\n\r\n  // Draw each powerup on the minimap\r\n  globalPowerUps.forEach((powerup) => {\r\n    minimapCtx.fillStyle = powerup.color;\r\n    minimapCtx.fillRect(powerup.x * scaleX, powerup.y * scaleY, powerupSize, powerupSize);\r\n  });\r\n}\r\n\r\n// Function to draw a player or bot on the minimap\r\nexport function drawMiniMapEntity(entity, ctx, scaleX, scaleY, dotSize) {\r\n  if (entity != null && entity.isPlaying) {\r\n    ctx.fillStyle = entity.color;\r\n    ctx.fillRect(entity.x * scaleX, entity.y * scaleY, dotSize, dotSize);\r\n  }\r\n}\r\n","import {\r\n  bots,\r\n  otherPlayers,\r\n  player,\r\n  worldDimensions,\r\n  colors,\r\n  acceleration,\r\n  setCam,\r\n  setGameState,\r\n  GameState,\r\n  globalPowerUps,\r\n  canvas,\r\n  selectedColors,\r\n} from \"./main.js\";\r\nimport { isPlayerMasterPeer } from \"./connectionHandlers.js\";\r\nimport { HitByType } from \"./collisionLogic.js\";\r\nimport { incrementFirebaseGivenPropertyValue, getFirebase, DbPropertyKey, DbDocumentKey } from \"./db.js\";\r\nimport { forces, ForceArea, ForceType, Effect, effects, EffectType, MineType, Trail } from \"./entities.js\";\r\nimport { checkFirstLetterSpace } from \"./gameUtils.js\";\r\nimport {\r\n  setEndGameMessage,\r\n  maxInvincibilityTime,\r\n  spawnProtectionTime,\r\n  maxSpecialMeter,\r\n  PilotName,\r\n  initialInvincibleTime,\r\n  botRespawnDelay,\r\n  pilots,\r\n  basicAnimationTimer,\r\n} from \"./gameLogic.js\";\r\nimport { screenShake, getRandomUniqueColor } from \"./gameUtils.js\";\r\nimport { sendPlayerStates, sendRequestForStates, requestFullUpdate, sendEffectsUpdate } from \"./sendData.js\";\r\n\r\nconst bounceFactor = 1.5;\r\nconst offset = 1;\r\nconst minBounceSpeed = 5;\r\nconst maxBotsThatCanTargetAtOnce = 1;\r\nconst maxVel = 50;\r\nconst minVel = -50;\r\nconst resettingBackupTimeout = 200;\r\nlet lastSentBots = [];\r\n\r\nexport const BotState = {\r\n  FOLLOW_PLAYER: \"followPlayer\",\r\n  RANDOM: \"random\",\r\n  COLLECT: \"collect\",\r\n};\r\n\r\nexport const Special = {\r\n  BOOST: \"boost\",\r\n  FORCE_PULL: \"pull\",\r\n  FORCE_PULL_FOCUS: \"pullfocus\",\r\n  FORCE_PUSH: \"push\",\r\n};\r\n\r\nexport class Player {\r\n  #angle;\r\n  constructor(\r\n    id = null,\r\n    x = null,\r\n    y = null,\r\n    powerUps = 0,\r\n    color = null,\r\n    angle = 0,\r\n    pilot = \"\",\r\n    name = \"\",\r\n    isPlaying = true,\r\n    isUserControlledCharacter = false\r\n  ) {\r\n    this.id = id;\r\n    this.x = x !== null ? x : 1200 + Math.random() * (worldDimensions.width - 2400);\r\n    this.y = y !== null ? y : 600 + Math.random() * (worldDimensions.height - 1200);\r\n    this.powerUps = powerUps;\r\n    this.color = color !== null ? color : getRandomUniqueColor(colors, selectedColors);\r\n    this.#angle = angle;\r\n    this.pilot = pilot;\r\n    this.name = name;\r\n    this.isPlaying = isPlaying;\r\n    this.isUserControlledCharacter = isUserControlledCharacter;\r\n    this.lives = 1;\r\n    this.isMaster = false;\r\n    this.setIsDead(false);\r\n    this.invincibleTimer = 0;\r\n    this.forceCoolDown = 0;\r\n    this.setComboScaler(1);\r\n    this.kills = 0;\r\n    this.isBot = false;\r\n    this.playerAngleData = {};\r\n    this.mousePosX = 0;\r\n    this.mousePosY = 0;\r\n    this.absoluteMousePosX = 0;\r\n    this.absoluteMousePosY = 0;\r\n    this.currentSpeed = 0;\r\n    this.vel = { x: 0, y: 0 };\r\n    this.distanceFactor = 0;\r\n    this.space = false;\r\n    this.shift = false;\r\n    this.u = false;\r\n    this.ticksSincePowerUpCollection = -1;\r\n    this.targetedBy = [];\r\n    this.timeSinceSpawned = 0;\r\n    this.timeSinceSentMessageThatWasRecieved = 0;\r\n    this.special = Special.FORCE_PULL;\r\n    this.specialMeter = 100;\r\n    this.usingSpecial = 0;\r\n    this.hitBy = \"\";\r\n    this.recentScoreTicks = 0;\r\n    this.isLocal = false;\r\n    this.timeOfLastActive = \"\";\r\n    this.recentScoreText = \"\";\r\n    this.recentKillScoreText = \"\";\r\n    this.devMode = false;\r\n    this.killed = [];\r\n    this.killedBy = [];\r\n    this.resetting = false;\r\n  }\r\n  setAngle(angle) {\r\n    let previousAngleDifference = angle - this.#angle;\r\n    if (this.isBot == false && Math.abs(previousAngleDifference > 0.2)) {\r\n      // console.log(`Before: ${this.#angle}, After: ${angle}`);\r\n    }\r\n    this.#angle = angle;\r\n  }\r\n  getAngle() {\r\n    return this.#angle;\r\n  }\r\n  resetState(keepName, keepColor) {\r\n    this.x = 1200 + Math.random() * (worldDimensions.width - 2400);\r\n    this.y = 600 + Math.random() * (worldDimensions.height - 1200);\r\n    this.powerUps = 0;\r\n    if (!keepColor) {\r\n      this.color = getRandomUniqueColor(colors, selectedColors);\r\n    }\r\n    this.setAngle(0);\r\n    if (!keepName) {\r\n      this.name = \"\";\r\n    }\r\n    this.followingPlayerID = \"\";\r\n    this.timeOfLastMessage = \"\";\r\n    this.timeOfLastActive = \"\";\r\n    this.target = { x: 0, y: 0, id: \"\" };\r\n    this.targetedBy = [];\r\n    this.space = false;\r\n    this.shift = false;\r\n    //don't reset isDead, that can be done explicity when game is (re)started\r\n    // this.setIsDead(false);\r\n    this.invincibleTimer = 0;\r\n    this.setComboScaler(1);\r\n    this.kills = 0;\r\n    this.inRangeTicks = 0;\r\n    this.mousePosX = 0;\r\n    this.mousePosY = 0;\r\n    this.absoluteMousePosX = 0;\r\n    this.absoluteMousePosY = 0;\r\n    this.currentSpeed = 0;\r\n    this.vel = { x: 0, y: 0 };\r\n    this.timeSinceSpawned = 0;\r\n    this.hitBy = \"\";\r\n    this.recentScoreTicks = 0;\r\n    this.recentScoreText = \"\";\r\n    this.recentKillScoreText = \"\";\r\n    this.resetting = false;\r\n    this.inForce = 0;\r\n  }\r\n  isDead() {\r\n    return this.isDead;\r\n  }\r\n  setIsDead(newIsDead) {\r\n    this.isDead = newIsDead;\r\n  }\r\n\r\n  delayReset(framesToDelay, keepName, keepColor, inProgress = false) {\r\n    if (!inProgress && this.resetting == true) {\r\n      // If already have a scheduled reset, ignore future requests.//could do this timeout only if master?\r\n      if (!this.resettingTimeout) {\r\n        this.resettingTimeout = setTimeout(() => {\r\n          this.resetting = false;\r\n          this.resettingTimeout = null;\r\n          console.log(\"Resetting flag was forcefully reset.\");\r\n        }, resettingBackupTimeout);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Resetting is in progress, clear the timeout if it exists.\r\n    if (this.resettingTimeout) {\r\n      clearTimeout(this.resettingTimeout);\r\n      this.resettingTimeout = null;\r\n    }\r\n\r\n    this.resetting = true;\r\n    if (framesToDelay > 0) {\r\n      requestAnimationFrame(() => {\r\n        this.delayReset(framesToDelay - 1, keepName, keepColor, true);\r\n      });\r\n    } else {\r\n      // Execute the reset after the specified number of frames.\r\n      this.resetState(keepName, keepColor);\r\n    }\r\n  }\r\n\r\n  //gotHit and addScore are both doing an additional key function of sending the playerstates as master.\r\n  //Need to unpick this, maybe there should be events for gotHit and addscore and masterpeer responds to such events with sending player state for the given player\r\n  gotHit(hitBy, otherPlayerGotHitToo = false) {\r\n    this.setIsDead(true);\r\n    this.recentScoreTicks = 0;\r\n    this.setComboScaler(1);\r\n    this.hitBy = hitBy;\r\n\r\n    this.updateKilledAndKilledByLists(hitBy, this == player, otherPlayerGotHitToo);\r\n\r\n    if (!this.killedBy.includes(hitBy) && hitBy != HitByType.MINE) {\r\n      this.killedBy.push(hitBy);\r\n    }\r\n    let effectID = Math.floor(Math.random() * 10000);\r\n\r\n    let effect = new Effect(effectID, this.x, this.y, 100, 50, \"orange\", EffectType.EXPLOSION);\r\n    effects.push(effect);\r\n    // sendEffectsUpdate(true)\r\n    if (isPlayerMasterPeer(player)) {\r\n      sendPlayerStates(this, true, true);\r\n      sendEffectsUpdate(true);\r\n    }\r\n    if (this.isLocal) {\r\n      screenShake(canvas, 30, 1000);\r\n      let firebase = getFirebase();\r\n      if (firebase) {\r\n        const user = firebase.auth().currentUser;\r\n        if (user) {\r\n          incrementFirebaseGivenPropertyValue(firebase, DbPropertyKey.SCORE, this.powerUps);\r\n          incrementFirebaseGivenPropertyValue(firebase, DbPropertyKey.KILLS, this.kills);\r\n        }\r\n      }\r\n    }\r\n    if (this.isBot) {\r\n      this.delayReset(botRespawnDelay, true, true);\r\n    }\r\n  }\r\n\r\n  updateKilledAndKilledByLists(hitBy, isPlayer, otherPlayerGotHitToo) {\r\n    if (hitBy != null && hitBy != \"\") {\r\n      this.updateKilledAndKilledByListsValidHitBy(hitBy, isPlayer, otherPlayerGotHitToo);\r\n    } else if (isPlayer) {\r\n      setEndGameMessage(\"Score: \" + this.powerUps * 100);\r\n    }\r\n  }\r\n\r\n  updateKilledAndKilledByListsValidHitBy(hitBy, isPlayer, otherPlayerGotHitToo) {\r\n    if (!this.killed.includes(hitBy)) {\r\n      if (!this.killedBy.includes(hitBy)) {\r\n        if (isPlayer) {\r\n          if (hitBy == HitByType.MINE) {\r\n            setEndGameMessage(\"Watch out for mines! \\nScore: \" + this.powerUps * 100);\r\n          } else if (otherPlayerGotHitToo) {\r\n            setEndGameMessage(\"Crashed into: \" + hitBy + \"\\nScore: \" + this.powerUps * 100);\r\n          } else {\r\n            setEndGameMessage(\"Killed by: \" + hitBy + \"\\nScore: \" + this.powerUps * 100);\r\n          }\r\n        }\r\n      } else {\r\n        if (isPlayer) {\r\n          setEndGameMessage(hitBy + \" is dominating you\" + \"\\nScore: \" + this.powerUps * 100);\r\n        }\r\n      }\r\n    } else {\r\n      this.killed = this.killed.filter((item) => item !== hitBy);\r\n      if (isPlayer) {\r\n        setEndGameMessage(hitBy + \" took their revenge!\" + \"\\nScore: \" + this.powerUps * 100);\r\n      }\r\n    }\r\n  }\r\n\r\n  addScore(scoreToAdd) {\r\n    this.powerUps += scoreToAdd;\r\n    if (this.powerUps != Math.floor(this.powerUps)) {\r\n      //I'm trying out not whole number combo scaling so not unexpected now\r\n      // console.log(\"somehow not whole score added\");\r\n      this.powerUps = Math.floor(this.powerUps);\r\n    }\r\n    // if (isPlayerMasterPeer(player) && !isPlayerMasterPeer(this)) {\r\n    if (isPlayerMasterPeer(player)) {\r\n      sendPlayerStates(this, true, true);\r\n    }\r\n  }\r\n\r\n  gotPowerUp(isStar, scoreToAdd, powerUpIndex) {\r\n    this.ticksSincePowerUpCollection = 0;\r\n    if (isStar) {\r\n      let invcibilityTime = initialInvincibleTime;\r\n      for (let pilot of pilots) {\r\n        if (this.pilot == pilot.name) {\r\n          invcibilityTime = pilot.invincibilityTime;\r\n          break;\r\n        }\r\n      }\r\n      this.setInvincibleTimer(invcibilityTime);\r\n    }\r\n\r\n    scoreToAdd *= this.comboScaler;\r\n\r\n    this.recentScoreTicks = 150;\r\n    let textScore = scoreToAdd * 100;\r\n    this.setRecentScoreText(textScore);\r\n    if (this.comboScaler < 10) {\r\n      this.setComboScaler(this.comboScaler + 0.5);\r\n    }\r\n    globalPowerUps[powerUpIndex].hitFrames = 2;\r\n    // // globalPowerUps.splice(powerUpIndex, 1);\r\n\r\n    // if (isPlayerMasterPeer(player)) {\r\n    //   setGlobalPowerUps(globalPowerUps);\r\n    // }\r\n    this.addScore(scoreToAdd);\r\n    this.recentKillScoreText = \"\";\r\n    if (this.isLocal) {\r\n      // screenShake(canvas, 2, 200);\r\n    }\r\n  }\r\n\r\n  setComboScaler(newValue) {\r\n    if (newValue < 1) {\r\n      this.comboScaler = 1;\r\n    } else {\r\n      this.comboScaler = newValue;\r\n    }\r\n  }\r\n\r\n  setRecentScoreText(textScore) {\r\n    if (this.comboScaler >= 5.5) {\r\n      this.recentScoreText = this.getComboText(\"Monster!\", textScore);\r\n    } else if (this.comboScaler >= 5) {\r\n      this.recentScoreText = this.getComboText(\"Epic!\", textScore);\r\n    } else if (this.comboScaler >= 4.5) {\r\n      this.recentScoreText = this.getComboText(\"Awesome!\", textScore);\r\n    } else if (this.comboScaler >= 4) {\r\n      this.recentScoreText = this.getComboText(\"Insane!\", textScore);\r\n    } else if (this.comboScaler >= 3.5) {\r\n      this.recentScoreText = this.getComboText(\"Unreal!\", textScore);\r\n    } else if (this.comboScaler >= 3) {\r\n      this.recentScoreText = this.getComboText(\"Fierce!\", textScore);\r\n    } else if (this.comboScaler >= 2.5) {\r\n      this.recentScoreText = this.getComboText(\"Sick!\", textScore);\r\n    } else if (this.comboScaler >= 2.1) {\r\n      this.recentScoreText = this.getComboText(\"Wild!\", textScore);\r\n    } else if (this.comboScaler >= 1.8) {\r\n      this.recentScoreText = this.getComboText(\"Cool!\", textScore);\r\n    } else if (this.comboScaler >= 1.5) {\r\n      this.recentScoreText = this.getComboText(\"Combo!\", textScore);\r\n    } else {\r\n      this.recentScoreText = this.getComboText(\"\", textScore);\r\n    }\r\n  }\r\n\r\n  getComboText(comboName, textScore) {\r\n    return comboName + \" \" + textScore;\r\n  }\r\n\r\n  setRecentKillText(playerThatGotHitName, revenge = true) {\r\n    const killFlavorText = [\"KILL!\", \"GOTTEM!\", \"SMASH!\", \"OOOF!\"];\r\n\r\n    const revengeFlavorText = [\"Got Revenge on \", \" gets served with payback\", \" won't mess with you again\", \" found out\"];\r\n\r\n    const dominatingFlavorText = [\"Dominating poor \", \" dies again\", \" bites the dust again\", \" found out again\"];\r\n\r\n    // Generate random index, can split this out if want to have different number of options for each text\r\n    const textIndex = Math.floor(Math.random() * killFlavorText.length);\r\n    if (playerThatGotHitName != null && playerThatGotHitName != \"\") {\r\n      if (revenge) {\r\n        if (checkFirstLetterSpace(revengeFlavorText[textIndex])) {\r\n          this.recentKillScoreText = playerThatGotHitName + revengeFlavorText[textIndex];\r\n        } else {\r\n          this.recentKillScoreText = revengeFlavorText[textIndex] + playerThatGotHitName;\r\n        }\r\n      } else {\r\n        //if not revenge then dominating\r\n        if (checkFirstLetterSpace(dominatingFlavorText[textIndex])) {\r\n          this.recentKillScoreText = playerThatGotHitName + dominatingFlavorText[textIndex];\r\n        } else {\r\n          this.recentKillScoreText = dominatingFlavorText[textIndex] + playerThatGotHitName;\r\n        }\r\n      }\r\n    } else {\r\n      //if no name passed then set regular flavour text\r\n      this.recentKillScoreText = killFlavorText[textIndex];\r\n    }\r\n  }\r\n\r\n  hitOtherPlayer(playerThatGotHit) {\r\n    this.kills += 1;\r\n    if (this.killedBy.includes(playerThatGotHit.name)) {\r\n      this.killedBy = this.killedBy.filter((item) => item !== playerThatGotHit.name);\r\n      this.setRecentKillText(playerThatGotHit.name, true);\r\n    } else if (this.killed.includes(playerThatGotHit.name)) {\r\n      this.setRecentKillText(playerThatGotHit.name, false);\r\n    } else {\r\n      this.setRecentKillText(\"\");\r\n    }\r\n    if (!this.killed.includes(playerThatGotHit.name)) {\r\n      this.killed.push(playerThatGotHit.name);\r\n    }\r\n\r\n    let score = 2 * this.comboScaler;\r\n    score += Math.round(playerThatGotHit.powerUps / 3);\r\n    this.recentScoreTicks = 250;\r\n    let textScore = score * 100;\r\n\r\n    this.setRecentScoreText(textScore);\r\n    if (this.invincibleTimer > 165) {\r\n      this.setInvincibleTimer(this.invincibleTimer - 150);\r\n    } else {\r\n      this.setInvincibleTimer(15);\r\n    }\r\n    this.addScore(score);\r\n    if (this.comboScaler < 10) {\r\n      this.setComboScaler(this.comboScaler + 0.5);\r\n    }\r\n    if (this.isLocal) {\r\n      screenShake(canvas, 30, 500);\r\n      // let firebase = getFirebase();\r\n      // if (firebase) {\r\n      //   const user = firebase.auth().currentUser;\r\n      //   if (user) {\r\n      //     incrementFirebaseGivenPropertyValue(firebase, DbPropertyKey.KILLS, 1);\r\n      //   }\r\n      // }\r\n    }\r\n  }\r\n\r\n  isActive() {\r\n    return (this.isPlaying || this.isBot) && !this.isDead;\r\n  }\r\n\r\n  isInvincible() {\r\n    return this.invincibleTimer > 0;\r\n  }\r\n  isVulnerable() {\r\n    return !this.isInvincible() && !this.isInSpawnProtectionTime() && this.isActive();\r\n  }\r\n  isTangible() {\r\n    return !this.isInSpawnProtectionTime() || this.isInvincible();\r\n  }\r\n\r\n  isInSpawnProtectionTime() {\r\n    return this.timeSinceSpawned <= spawnProtectionTime;\r\n  }\r\n\r\n  setInvincibleTimer(newTime) {\r\n    let invcibilityTime = maxInvincibilityTime;\r\n    for (let pilot of pilots) {\r\n      if (this.pilot == pilot.name) {\r\n        invcibilityTime = pilot.invincibilityTime;\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.invincibleTimer = Math.min(newTime, invcibilityTime);\r\n    this.invincibleTimer = Math.max(this.invincibleTimer, 0);\r\n  }\r\n\r\n  setSpecialMeter(newTime) {\r\n    this.specialMeter = Math.min(newTime, maxSpecialMeter);\r\n    this.specialMeter = Math.max(this.specialMeter, 0);\r\n  }\r\n  setPilot(newPilot) {\r\n    this.pilot = newPilot;\r\n    if (this.pilot == PilotName.PILOT_1) {\r\n      this.special = Special.FORCE_PULL;\r\n    }\r\n    if (this.pilot == PilotName.PILOT_2) {\r\n      this.special = Special.FORCE_PUSH;\r\n    }\r\n    if (this.pilot == PilotName.PILOT_3) {\r\n      this.special = Special.BOOST;\r\n    }\r\n    if (this.pilot == PilotName.PILOT_4) {\r\n      this.special = Special.FORCE_PULL_FOCUS;\r\n    }\r\n  }\r\n\r\n  getPlayerName() {\r\n    return this.name;\r\n  }\r\n\r\n  setPlayerName(newName) {\r\n    this.name = newName;\r\n  }\r\n\r\n  setPlayerIsMaster(isMaster) {\r\n    if (this.isLocal && !isMaster && this.isMaster) {\r\n      //if switching away from being master send basic ship data\r\n      sendPlayerStates(this, false, true);\r\n    }\r\n    if (isMaster && !this.isMaster) {\r\n      //if switching any player to being master request basic ship data\r\n      sendRequestForStates();\r\n    }\r\n    if (isMaster && !this == player) {\r\n      //if switching another player to master ask master for a full update. Not sure if master will be ready as master immediately so schedule a few requests\r\n      setTimeout(() => requestFullUpdate(), 20);\r\n      setTimeout(() => requestFullUpdate(), 500);\r\n      setTimeout(() => requestFullUpdate(), 2000);\r\n    }\r\n    this.isMaster = isMaster;\r\n  }\r\n  bouncePlayer() {\r\n    if (this.x < 0 || this.x > worldDimensions.width) {\r\n      this.vel.x = -this.vel.x * bounceFactor;\r\n      this.x = this.x < 0 ? offset : worldDimensions.width - offset;\r\n      this.vel.x = (this.vel.x < 0 ? -1 : 1) * Math.max(Math.abs(this.vel.x), minBounceSpeed);\r\n    }\r\n\r\n    if (this.y < 0 || this.y > worldDimensions.height) {\r\n      this.vel.y = -this.vel.y * bounceFactor;\r\n      this.y = this.y < 0 ? offset : worldDimensions.height - offset;\r\n      this.vel.y = (this.vel.y < 0 ? -1 : 1) * Math.max(Math.abs(this.vel.y), minBounceSpeed);\r\n    }\r\n    this.boundVelocity();\r\n  }\r\n\r\n  updatePlayerAngle(camX, camY) {\r\n    if (!this.isBot) {\r\n      if (!this.isLocal) {\r\n        //if this is another player, don't update the angle since we get that directly\r\n        return;\r\n      }\r\n      this.mousePosX = this.absoluteMousePosX + camX;\r\n      this.mousePosY = this.absoluteMousePosY + camY;\r\n    }\r\n    let dx = this.x - this.mousePosX;\r\n    let dy = this.y - this.mousePosY;\r\n    let distance = Math.sqrt(dx * dx + dy * dy);\r\n    this.setAngle(Math.atan2(dy, dx) + Math.PI / 2);\r\n    if (isNaN(dx) || isNaN(dy) || isNaN(distance)) {\r\n      console.log(\"player angle NaN data\");\r\n    } else {\r\n      this.playerAngleData = { dx, dy, distance };\r\n    }\r\n  }\r\n\r\n  updatePlayerVelocity(deltaTime) {\r\n    let dx = this.playerAngleData.dx;\r\n    let dy = this.playerAngleData.dy;\r\n    let distance = this.playerAngleData.distance;\r\n    let squareFactor = this.currentSpeed * this.currentSpeed * 0.0001;\r\n    let minFrictionExponent = 0.8;\r\n    let frictionPowerScaler = 2;\r\n    let newFriction = Math.pow(Math.max(0.999 - squareFactor, minFrictionExponent), deltaTime / frictionPowerScaler);\r\n    newFriction = Math.min(newFriction, 0.99);\r\n    this.currentFrictionPercent = (1 - newFriction) * 100;\r\n\r\n    let pilotBoostFactor = 1;\r\n    if (this.pilot == PilotName.PILOT_1) {\r\n      pilotBoostFactor = 1.1;\r\n    } else if (this.pilot == PilotName.PILOT_2) {\r\n      pilotBoostFactor = 0.7;\r\n    } else if (this.pilot == PilotName.PILOT_3) {\r\n      pilotBoostFactor = 1.3;\r\n    } else if (this.pilot == PilotName.PILOT_4) {\r\n      pilotBoostFactor = 1.0;\r\n    }\r\n    if (this.currentSpeed < 2) {\r\n      pilotBoostFactor * 6;\r\n    } else if (this.currentSpeed < 4) {\r\n      pilotBoostFactor * 3;\r\n    } else if (this.currentSpeed < 7) {\r\n      pilotBoostFactor * 2;\r\n    }\r\n    let boosting = false;\r\n    if (this.shift && (this.specialMeter > 50 || (this.usingSpecial && this.specialMeter > 1))) {\r\n      if (this.usingSpecial < 1 && !this.devMode) {\r\n        //initial cost more than keeping it going\r\n        this.setSpecialMeter(this.specialMeter - 10);\r\n      }\r\n      this.usingSpecial = 3;\r\n      //todo specials other than boost shouldn't be triggered here\r\n      if (\r\n        this.special == Special.FORCE_PULL ||\r\n        this.special == Special.FORCE_PULL_FOCUS ||\r\n        this.special == Special.FORCE_PUSH ||\r\n        this.special == Special.BOOST\r\n      ) {\r\n        // if (this.forceCoolDown < 1) {\r\n        //try a gradual effect\r\n        //this.forceCoolDown = 200;\r\n        if (!this.devMode) {\r\n          this.setSpecialMeter(this.specialMeter - 3);\r\n        }\r\n        if (this.specialMeter == 0) {\r\n          this.usingSpecial = 0;\r\n        }\r\n\r\n        if (this.special == Special.FORCE_PULL || this.special == Special.FORCE_PULL_FOCUS || this.special == Special.FORCE_PUSH) {\r\n          let attractive = true;\r\n          if (this.special == Special.FORCE_PUSH) {\r\n            attractive = false;\r\n          }\r\n          // Calculate the cone's direction based on the ship's angle is needed since everything is offset by this\r\n          const coneDirection = this.getAngle() - Math.PI / 2;\r\n          // Specify the desired cone angle (in radians) for the force\r\n          let coneAngle = Math.PI * 2;\r\n          let forcePower = 1.5;\r\n          let radius = 200;\r\n\r\n          if (this.special == Special.FORCE_PULL_FOCUS) {\r\n            coneAngle = Math.PI / 4; // 45-degree cone\r\n            forcePower = 3.0;\r\n            radius = 500;\r\n          }\r\n          let forceType = ForceType.POINT;\r\n          // Create the ForceArea with the cone properties\r\n          this.createForce(this.x, this.y, forcePower, 5, radius, attractive, this.color, this, coneAngle, coneDirection, forceType);\r\n        } else if (this.special == Special.BOOST) {\r\n          //give a bit of meter back for the boost so it works out cheaper than force.\r\n          this.setSpecialMeter(this.specialMeter + 1);\r\n          boosting = true;\r\n          if (this.specialMeter > 0 && !this.devMode) {\r\n            this.setSpecialMeter(this.specialMeter - 5);\r\n          }\r\n          if (this.pilot == PilotName.PILOT_1) {\r\n            pilotBoostFactor = 3;\r\n          }\r\n          if (this.pilot == PilotName.PILOT_2) {\r\n            pilotBoostFactor = 5;\r\n          }\r\n          if (this.pilot == PilotName.PILOT_3) {\r\n            pilotBoostFactor = 7;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.vel.x *= newFriction;\r\n    this.vel.y *= newFriction;\r\n\r\n    if (this.space || boosting) {\r\n      let mouseToCenter = { x: dx / distance, y: dy / distance };\r\n      if (distance == 0 || isNaN(distance)) {\r\n        mouseToCenter = { x: 0, y: 0 };\r\n      }\r\n      let maxForceDistance = 250;\r\n      let minForceDistance = 100;\r\n\r\n      this.distanceFactor = 1;\r\n      if (distance < minForceDistance) {\r\n        this.distanceFactor = 0.1; // minimum force\r\n      } else if (distance < maxForceDistance) {\r\n        let normalizedDistance = (distance - minForceDistance) / (maxForceDistance - minForceDistance);\r\n        this.distanceFactor = 0.1 + normalizedDistance * 0.9; // gradually increase force\r\n      }\r\n      this.vel.x += acceleration * this.distanceFactor * mouseToCenter.x * pilotBoostFactor * deltaTime;\r\n      this.vel.y += acceleration * this.distanceFactor * mouseToCenter.y * pilotBoostFactor * deltaTime;\r\n      if (this.vel.x == null || isNaN(this.vel.x) || this.vel.y == null || isNaN(this.vel.y)) {\r\n        console.log(\"Invalid velocity values: x =\", this.vel.x, \"y =\", this.vel.y);\r\n      }\r\n    }\r\n    this.boundVelocity();\r\n    this.currentSpeed = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);\r\n  }\r\n  createForce(\r\n    x,\r\n    y,\r\n    force = 1,\r\n    duration = 10,\r\n    radius = 200,\r\n    isAttractive = true,\r\n    color = \"red\",\r\n    tracks = null,\r\n    coneAngle = 0,\r\n    direction = 0,\r\n    type = ForceType.POINT,\r\n    width = 100,\r\n    length = 200\r\n  ) {\r\n    //note this assumes a given player will always use the same force. If that ever changes we just need to remove the old force from forces. If the play can have multiple forces then we'll have to revist this.\r\n    // Check if there is already a force with the same id\r\n    const existingForce = forces.find((force) => force.id === \"player-\" + this.id);\r\n    // const existingForce = null;\r\n\r\n    if (!existingForce) {\r\n      // If no force with the same id exists, create a new one\r\n      let playerForce = new ForceArea(\r\n        \"player-\" + this.id,\r\n        x,\r\n        y,\r\n        force,\r\n        duration,\r\n        radius,\r\n        isAttractive,\r\n        color,\r\n        tracks,\r\n        coneAngle,\r\n        direction,\r\n        type,\r\n        width,\r\n        length,\r\n        true\r\n      );\r\n\r\n      //currently  doesn't keep a reference to it's force, is that fine?\r\n      forces.push(playerForce);\r\n    } else {\r\n      existingForce.duration = 10;\r\n      existingForce.x = x;\r\n      existingForce.y = y;\r\n      existingForce.force = force;\r\n      existingForce.radius = radius;\r\n      existingForce.isAttractive = isAttractive;\r\n      existingForce.color = color;\r\n      existingForce.tracks = tracks;\r\n      existingForce.coneAngle = coneAngle;\r\n      existingForce.direction = direction;\r\n      existingForce.type = type;\r\n      existingForce.width = width;\r\n      existingForce.length = length;\r\n    }\r\n  }\r\n\r\n  setDevMode(newMode) {\r\n    this.devMode = newMode;\r\n    sendPlayerStates(this, true, true);\r\n  }\r\n  boundVelocity() {\r\n    if (this.vel.x > maxVel) {\r\n      this.vel.x = maxVel;\r\n    } else if (this.vel.x < minVel) {\r\n      this.vel.x = minVel;\r\n    }\r\n    if (this.vel.y > maxVel) {\r\n      this.vel.y = maxVel;\r\n    } else if (this.vel.y < minVel) {\r\n      this.vel.y = minVel;\r\n    }\r\n  }\r\n  updatePlayerPosition(deltaTime) {\r\n    if (this.vel.x !== null && !isNaN(this.vel.x) && this.vel.y !== null && !isNaN(this.vel.y)) {\r\n      this.x += this.vel.x * deltaTime;\r\n      this.y += this.vel.y * deltaTime;\r\n      if (this.vel.x != 0 && this.vel.y != 0) {\r\n        this.timeOfLastActive = Date.now();\r\n      }\r\n    } else {\r\n      console.log(\"Invalid velocity values: x =\", this.vel.x, \"y =\", this.vel.y);\r\n      if (isNaN(this.vel.x)) {\r\n        this.vel.x = 0;\r\n      }\r\n      if (isNaN(this.vel.y)) {\r\n        this.vel.y = 0;\r\n      }\r\n      this.boundVelocity();\r\n    }\r\n  }\r\n\r\n  emitTrail(mines) {\r\n    let trailTime = 100;\r\n    for (let pilot of pilots) {\r\n      if (this.pilot == pilot.name) {\r\n        trailTime = pilot.trailTime;\r\n        break;\r\n      }\r\n    }\r\n    const velocityAngle = Math.atan2(this.vel.y, this.vel.x);\r\n    const velocitySize = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);\r\n\r\n    let length = 15;\r\n    if (velocitySize > 2) {\r\n      length *= Math.min(4, velocitySize / 2.5);\r\n    }\r\n    let width = 50;\r\n\r\n    // Calculate the offset based on velocityAngle and velocity\r\n    const offsetDistance = velocitySize * 3.5;\r\n    const xOffset = offsetDistance * Math.cos(velocityAngle);\r\n    const yOffset = offsetDistance * Math.sin(velocityAngle);\r\n\r\n    // Calculate the new x and y coordinates for the trail\r\n    const trailX = this.x - xOffset;\r\n    const trailY = this.y - yOffset;\r\n    // const trailX = this.x + xOffset;\r\n    // const trailY = this.y + yOffset;\r\n\r\n    let trail = new Trail(\r\n      \"trail-\" + Math.floor(Math.random() * 10000),\r\n      trailX,\r\n      trailY,\r\n      trailTime,\r\n      // 30,\r\n      70,\r\n      this.color,\r\n      0,\r\n      MineType.TRAIL,\r\n      -5,\r\n      this.id,\r\n      velocityAngle + Math.PI / 2,\r\n      length,\r\n      width\r\n    );\r\n    mines.push(trail);\r\n    if (isPlayerMasterPeer(this)) {\r\n      // trying without the send, trusting on sync a bit here... maybe every 10 frames send?\r\n      // sendMinesUpdate(true);\r\n    }\r\n  }\r\n\r\n  centerCameraOnPlayer(viewportWidth, viewportHeight) {\r\n    const targetCamX = this.x - viewportWidth / 2;\r\n    let targetCamY;\r\n    if (this.ySpeed < 0) {\r\n      // Moving up\r\n      targetCamY = this.y - (viewportHeight * 2) / 4;\r\n    } else {\r\n      // Moving down or not moving vertically\r\n      targetCamY = this.y - (viewportHeight * 2) / 4;\r\n    }\r\n    let newCamX = targetCamX;\r\n    let newCamY = targetCamY;\r\n\r\n    let camX = Math.max(Math.min(newCamX, worldDimensions.width - viewportWidth), 0);\r\n    let camY = Math.max(Math.min(newCamY, worldDimensions.height - viewportHeight), 0);\r\n    setCam(camX, camY);\r\n  }\r\n\r\n  updateTick(deltaTime, mines, camX, camY) {\r\n    if (this.id == player.id && player.isDead) {\r\n      setGameState(GameState.FINISHED);\r\n      return;\r\n    }\r\n    if (!this.isDead) {\r\n      this.timeSinceSpawned++;\r\n      this.updatePlayerAngle(camX, camY);\r\n      this.updatePlayerVelocity(deltaTime);\r\n      this.bouncePlayer();\r\n      this.updatePlayerPosition(deltaTime);\r\n      if (this.u && this.devMode) {\r\n        //this is a debug cheat\r\n        this.setInvincibleTimer(this.invincibleTimer + 100);\r\n        this.setSpecialMeter(this.specialMeter + 100);\r\n      }\r\n      if (this.invincibleTimer > 0 && !this.devMode) {\r\n        this.setInvincibleTimer(this.invincibleTimer - 1);\r\n        if (this.invincibleTimer == 0) {\r\n          //can react to ending this state here, maybe animation/effect\r\n        }\r\n      }\r\n      if (this.specialMeter < maxSpecialMeter) {\r\n        this.specialMeter++;\r\n      }\r\n      this.usingSpecial = Math.max(this.usingSpecial - 1, 0);\r\n\r\n      if (this.ticksSincePowerUpCollection > -1) {\r\n        this.ticksSincePowerUpCollection++;\r\n      }\r\n      if (this.ticksSincePowerUpCollection > 5) {\r\n        this.ticksSincePowerUpCollection = -1;\r\n      }\r\n      this.forceCoolDown = Math.max(this.forceCoolDown - 1, 0);\r\n      if (this.recentScoreTicks > 0) {\r\n        this.recentScoreTicks = Math.max(this.recentScoreTicks - 1, 0);\r\n        if (this.recentScoreTicks == 0) {\r\n          this.setComboScaler(1);\r\n          this.recentKillScoreText = \"\";\r\n        }\r\n      }\r\n      if (basicAnimationTimer % 2 == 0 && !this.isInSpawnProtectionTime() && this.currentSpeed > 0.2) {\r\n        this.emitTrail(mines);\r\n      }\r\n    }\r\n    otherPlayers.forEach((otherPlayer) => {\r\n      otherPlayer.timeSinceSentMessageThatWasRecieved += 1;\r\n    });\r\n    this.inForce = Math.max(this.inForce - 1, 0);\r\n  }\r\n\r\n  howLongSinceActive() {\r\n    if (this.timeOfLastActive) {\r\n      const currentTime = Date.now();\r\n      const timeDifference = currentTime - this.timeOfLastActive;\r\n      return timeDifference;\r\n    } else {\r\n      return 5000;\r\n    }\r\n  }\r\n}\r\n\r\nexport function createPlayerFromObject(obj, excludeCurrentPlayer = true) {\r\n  let newPlayer = new Player(\r\n    obj.id,\r\n    obj.x,\r\n    obj.y,\r\n    obj.powerUps,\r\n    obj.color,\r\n    obj.angle,\r\n    obj.pilot,\r\n    obj.name,\r\n    obj.isPlaying,\r\n    obj.isUserControlledCharacter\r\n  );\r\n  newPlayer.timeOfLastActive = obj.timeOfLastActive;\r\n  newPlayer.playerAngleData = obj.playerAngleData;\r\n  newPlayer.mousePosX = obj.mousePosX;\r\n  newPlayer.mousePosY = obj.mousePosY;\r\n  newPlayer.currentSpeed = obj.currentSpeed;\r\n  newPlayer.vel = obj.vel;\r\n  newPlayer.distanceFactor = obj.distanceFactor;\r\n  newPlayer.space = obj.space;\r\n  newPlayer.shift = obj.shift;\r\n  newPlayer.u = obj.u;\r\n  newPlayer.timeSinceSpawned = obj.timeSinceSpawned;\r\n  newPlayer.setIsDead(obj.isDead);\r\n  return newPlayer;\r\n}\r\n\r\nexport function createBotFromObject(obj) {\r\n  let bot = new Bot(obj.id, obj.x, obj.y, obj.powerUps, obj.color, obj.angle, obj.pilot, obj.name, obj.isPlaying, obj.isUserControlledCharacter);\r\n  bot.timeOfLastActive = obj.timeOfLastActive;\r\n  bot.playerAngleData = obj.playerAngleData;\r\n  bot.mousePosX = obj.mousePosX;\r\n  bot.mousePosY = obj.mousePosY;\r\n  bot.currentSpeed = obj.currentSpeed;\r\n  bot.vel = obj.vel;\r\n  bot.isPlaying = obj.isPlaying;\r\n  bot.special = obj.special;\r\n  bot.distanceFactor = obj.distanceFactor;\r\n  bot.lives = obj.lives;\r\n  bot.space = obj.space;\r\n  bot.shift = obj.shift;\r\n  bot.u = obj.u;\r\n  bot.forceCoolDown = obj.forceCoolDown;\r\n  bot.setComboScaler(obj.comboScaler);\r\n  bot.kills = obj.kills;\r\n  bot.ticksSincePowerUpCollection = obj.ticksSincePowerUpCollection;\r\n  bot.timeSinceSpawned = obj.timeSinceSpawned;\r\n  bot.setInvincibleTimer(obj.invincibleTimer);\r\n  bot.setIsDead(obj.isDead);\r\n  return bot;\r\n}\r\n\r\nexport class Bot extends Player {\r\n  constructor(\r\n    id = null,\r\n    x = null,\r\n    y = null,\r\n    powerUps = 0,\r\n    color = null,\r\n    angle = 0,\r\n    pilot = \"\",\r\n    name = \"\",\r\n    isPlaying = true,\r\n    isUserControlledCharacter = false\r\n  ) {\r\n    super(id, x, y, powerUps, color, angle, pilot, name, isPlaying, (isUserControlledCharacter = false));\r\n    this.previousAngleDifference = 0;\r\n    this.previousTurnDirection = 0;\r\n    this.botState = BotState.FOLLOW_PLAYER;\r\n    this.followingPlayerID = \"\";\r\n    this.timeOfLastMessage = \"\";\r\n    this.target = { x: 0, y: 0, id: \"\" };\r\n    this.inRangeTicks = 0;\r\n    this.isBot = true;\r\n  }\r\n\r\n  setAngle(angle) {\r\n    super.setAngle(angle);\r\n  }\r\n\r\n  getAngle() {\r\n    return super.getAngle();\r\n  }\r\n  resetState(keepName, keepColor) {\r\n    super.resetState(keepName, keepColor);\r\n    this.setIsDead(false);\r\n  }\r\n\r\n  updateTick(deltaTime, mines, camX, camY) {\r\n    if (this.isDead) {\r\n      //todo delay this?\r\n      //this.resetState(true, true);\r\n      // this.delayReset(botRespawnDelay, true, true);\r\n      return;\r\n    }\r\n\r\n    super.updateTick(deltaTime, mines, camX, camY);\r\n  }\r\n\r\n  updateBotInputs() {\r\n    //this.randomlyConsiderChangingState();\r\n    if (this.invincibleTimer > 30 && this.botState != BotState.FOLLOW_PLAYER) {\r\n      this.#setFollowingTarget();\r\n      if (this.followingPlayerID != \"\") {\r\n        this.setRandomTarget(0, 0, \"random point\");\r\n        this.setBotState(BotState.FOLLOW_PLAYER);\r\n      }\r\n    }\r\n    if (isNaN(this.inForce)) {\r\n      this.inForce = 0;\r\n    }\r\n    if (this.inForce > 50) {\r\n      //try to get bots out of a force they may be stuck in by aiming somewhere new\r\n      this.setRandomTargetInMainArea();\r\n      this.inForce = 0;\r\n    }\r\n\r\n    if (this.botState == BotState.FOLLOW_PLAYER) {\r\n      this.handleFollowPlayerState();\r\n    } else if (this.botState == BotState.RANDOM) {\r\n      this.handleRandomState();\r\n    } else if (this.botState == BotState.COLLECT) {\r\n      this.handleCollectState();\r\n    }\r\n  }\r\n\r\n  handleFollowPlayerState() {\r\n    this.#setFollowingTarget();\r\n    if (this.followingPlayerID == \"\") {\r\n      this.setBotState(BotState.RANDOM);\r\n      // return;\r\n      this.handleRandomState();\r\n    }\r\n\r\n    const allPlayers = [...otherPlayers, ...bots, player];\r\n    let followingPlayer = allPlayers.find((candidate) => this.followingPlayerID === candidate.id);\r\n    if (followingPlayer == null || followingPlayer.isDead || !followingPlayer.isPlaying) {\r\n      this.followingPlayerID = \"\";\r\n      return;\r\n    }\r\n    if (followingPlayer.isBot) {\r\n      this.randomlyConsiderChangingState(0.1);\r\n    }\r\n    if (followingPlayer.invincibleTimer > 10) {\r\n      this.randomlyConsiderChangingState(0.03);\r\n    }\r\n    if (followingPlayer.isDead) {\r\n      this.followingPlayerID = \"\";\r\n    }\r\n    this.handleTargeting(followingPlayer.x, followingPlayer.y, followingPlayer.vel.x, followingPlayer.vel.y, 0.4);\r\n  }\r\n\r\n  handleRandomState() {\r\n    if (this.target.x == 0 && this.target.y == 0) {\r\n      this.setRandomTargetInMainArea();\r\n    }\r\n    this.handleTargeting(this.target.x, this.target.y, 0, 0, 0.4);\r\n  }\r\n\r\n  handleCollectState() {\r\n    if (this.target.x == 0 && this.target.y == 0) {\r\n      // Calculate the soonPosition\r\n      const soonPosition = {\r\n        x: this.x + 3 * this.vel.x,\r\n        y: this.y + 3 * this.vel.y,\r\n      };\r\n\r\n      let closestPowerUp;\r\n      let closestDistance = Infinity;\r\n\r\n      // Iterate over globalPowerUps to find the closest one to soonPosition\r\n      for (const powerUp of globalPowerUps) {\r\n        const distance = Math.sqrt(Math.pow(soonPosition.x - powerUp.x, 2) + Math.pow(soonPosition.y - powerUp.y, 2));\r\n\r\n        if (distance < closestDistance) {\r\n          closestDistance = distance;\r\n          closestPowerUp = powerUp;\r\n        }\r\n      }\r\n\r\n      if (closestPowerUp) {\r\n        // Use the closest power-up as the target\r\n        this.setRandomTarget(closestPowerUp.x, closestPowerUp.y, closestPowerUp.id);\r\n      } else {\r\n        // If no power-ups are available, switch to RANDOM state\r\n        this.setBotState(BotState.RANDOM);\r\n      }\r\n    } else {\r\n      let powerUpStillExists = globalPowerUps.some((globalPowerUp) => globalPowerUp.x == this.target.x && globalPowerUp.y == this.target.y);\r\n      if (!powerUpStillExists) {\r\n        this.setBotState(BotState.RANDOM);\r\n      }\r\n    }\r\n    this.handleTargeting(this.target.x, this.target.y, 0, 0, 0.4);\r\n  }\r\n\r\n  setRandomTargetInMainArea() {\r\n    this.setRandomTarget(300 + Math.random() * (worldDimensions.width - 600), 300 + Math.random() * (worldDimensions.height - 600), \"random\");\r\n  }\r\n  setRandomTarget(x, y, id) {\r\n    this.target.x = x;\r\n    this.target.y = y;\r\n    this.target.id = id;\r\n  }\r\n\r\n  setBotState(state) {\r\n    if (state == this.botState) {\r\n      return;\r\n    }\r\n    if (state == BotState.RANDOM) {\r\n      this.setRandomTargetInMainArea();\r\n    }\r\n    this.botState = state;\r\n  }\r\n\r\n  handleTargeting(targetX, targetY, velX, velY, factor) {\r\n    this.#checkIfGotToTarget(targetX, targetY);\r\n    this.#aimAtTarget(targetX, targetY, velX, velY, factor);\r\n  }\r\n\r\n  #setFollowingTarget() {\r\n    if (this.followingPlayerID == \"\") {\r\n      //lets try including other bots in the follow candidates\r\n      let allPlayers = [player, ...otherPlayers, ...bots];\r\n      //for debuging bot following I won't shuffle this and let it target player if possible\r\n      //shuffleArray(allPlayers);\r\n      let playerToFollow = null;\r\n\r\n      for (const candidate of allPlayers) {\r\n        candidate.targetedBy = candidate.targetedBy.filter((id) => id !== this.id);\r\n\r\n        if (this.id === candidate.id) {\r\n          // Don't follow yourself\r\n          continue; // Skip to the next iteration\r\n        }\r\n\r\n        let candidateHowLongSinceActive = candidate.howLongSinceActive();\r\n        let distance = Math.sqrt((this.x - candidate.x) ** 2 + (this.y - candidate.y) ** 2);\r\n        if (\r\n          distance < 1000 &&\r\n          candidateHowLongSinceActive < 300 &&\r\n          candidate.targetedBy.length < maxBotsThatCanTargetAtOnce &&\r\n          candidate.isPlaying &&\r\n          candidate.timeSinceSpawned > 600 &&\r\n          candidate.invincibleTimer < 10 &&\r\n          !candidate.isDead\r\n        ) {\r\n          playerToFollow = candidate;\r\n          playerToFollow.targetedBy.push(this.id);\r\n          this.followingPlayerID = playerToFollow.id;\r\n          break;\r\n        } else {\r\n          //console.log(candidate.name + \" is inactive not targeting\");\r\n        }\r\n      }\r\n    }\r\n  }\r\n  //this is doing more than checking if got there refactor this\r\n  #checkIfGotToTarget(targetX, targetY) {\r\n    let currentX = this.x;\r\n    let currentY = this.y;\r\n    let distance = Math.sqrt((targetX - currentX) ** 2 + (targetY - currentY) ** 2);\r\n\r\n    if (this.botState == BotState.FOLLOW_PLAYER) {\r\n      if (distance < 100) {\r\n        //once we get there move on to a new target\r\n        this.inRangeTicks += 1;\r\n        if (this.inRangeTicks > 200) {\r\n          let followingPlayer = null;\r\n          let allPlayers = [player, ...otherPlayers, ...bots];\r\n\r\n          for (const candidate of allPlayers) {\r\n            if (this.followingPlayerID === candidate.id) {\r\n              followingPlayer = candidate;\r\n              break; // Exit the loop once the followingPlayer is found\r\n            }\r\n          }\r\n          if (followingPlayer && followingPlayer.targetedBy.length > 0) {\r\n            // this.followingPlayer.targetedBy -= 1;\r\n            followingPlayer.targetedBy = followingPlayer.targetedBy.filter((id) => id !== this.id);\r\n          } else {\r\n            this.followingPlayerID = \"\";\r\n            console.log(\"followingPlayer null \");\r\n          }\r\n          this.followingPlayerID = \"\";\r\n          this.chooseNewBotState();\r\n        } else if (distance < 50 && this.inRangeTicks > 80) {\r\n          this.chooseNewBotState();\r\n        }\r\n      } else {\r\n        if (this.inRangeTicks > 0) {\r\n          this.inRangeTicks -= 1;\r\n        }\r\n      }\r\n    } else if (distance < 300 && this.botState == BotState.RANDOM) {\r\n      this.target.x = 0;\r\n      this.target.y = 0;\r\n      this.chooseNewBotState();\r\n    } else if (distance < 20 && this.botState == BotState.COLLECT) {\r\n      this.target.x = 0;\r\n      this.target.y = 0;\r\n      this.chooseNewBotState();\r\n    }\r\n  }\r\n\r\n  #aimAtTarget(targetX, targetY, targetVelocityX, targetVelocityY, adjustmentFactor) {\r\n    let currentX = this.x;\r\n    let currentY = this.y;\r\n    let currentVelocityX = this.vel.x;\r\n    let currentVelocityY = this.vel.y;\r\n\r\n    // Calculate the relative velocity between the bot and the target\r\n    let relativeVelocityX = targetVelocityX - currentVelocityX;\r\n    let relativeVelocityY = targetVelocityY - currentVelocityY;\r\n\r\n    // Calculate the distance between the target and current points\r\n    let distance = Math.sqrt((targetX - currentX) ** 2 + (targetY - currentY) ** 2);\r\n\r\n    // Calculate the time it would take to reach the original target without considering target's velocity\r\n    let currentSpeed = Math.sqrt(currentVelocityX ** 2 + currentVelocityY ** 2);\r\n    let adjustedTargetX = targetX;\r\n    let adjustedTargetY = targetY;\r\n\r\n    if (currentSpeed != 0) {\r\n      let timeToReachTarget = distance / currentSpeed;\r\n\r\n      // Calculate the adjusted target by considering a weighted combination of position and velocity\r\n      adjustedTargetX = targetX + relativeVelocityX * adjustmentFactor * timeToReachTarget;\r\n      adjustedTargetY = targetY + relativeVelocityY * adjustmentFactor * timeToReachTarget;\r\n    }\r\n\r\n    // Calculate the adjusted mouse position\r\n    let mousePos = this.mousePosToPositionAwayFromTarget(adjustedTargetX, adjustedTargetY, 200, this.mousePosX, this.mousePosY);\r\n\r\n    if (!isNaN(mousePos.X) && !isNaN(mousePos.Y)) {\r\n      this.mousePosX = mousePos.X;\r\n      this.mousePosY = mousePos.Y;\r\n    } else {\r\n      console.log(\"mousePos NaN in aimAtTarget\");\r\n    }\r\n    this.space = true;\r\n  }\r\n\r\n  mousePosToPositionAwayFromTarget(targetX, targetY, distanceFromCurrent, currentMousePosX, currentMousePosY) {\r\n    let deltaX = targetX - this.x;\r\n    let deltaY = targetY - this.y;\r\n\r\n    // Calculate the distance between the target and current position\r\n    let distance = Math.sqrt(deltaX ** 2 + deltaY ** 2);\r\n\r\n    if (distance == 0) {\r\n      return { X: 0, Y: 0 };\r\n    }\r\n    // Calculate the normalized direction vector\r\n    let directionX = deltaX / distance;\r\n    let directionY = deltaY / distance;\r\n\r\n    // Calculate the new mouse position\r\n    let mousePosX = this.x - directionX * distanceFromCurrent;\r\n    let mousePosY = this.y - directionY * distanceFromCurrent;\r\n\r\n    let currentAngle = Math.atan2(currentMousePosY - this.y, currentMousePosX - this.x);\r\n    let desiredAngle = Math.atan2(mousePosY - this.y, mousePosX - this.x);\r\n\r\n    // Calculate the angle difference\r\n    let angleDifference = desiredAngle - currentAngle;\r\n\r\n    // Wrap the angle difference between - and \r\n    if (angleDifference > Math.PI) {\r\n      angleDifference -= 2 * Math.PI;\r\n    } else if (angleDifference < -Math.PI) {\r\n      angleDifference += 2 * Math.PI;\r\n    }\r\n\r\n    // Interpolate between the current angle and the desired angle\r\n    let interpolationFactor = 0.8; // Adjust this value to change the speed of the turn\r\n    let interpolatedAngle = currentAngle + angleDifference * interpolationFactor;\r\n\r\n    // Calculate the new mouse position based on the interpolated angle and the desired distance from the current position\r\n    mousePosX = this.x + Math.cos(interpolatedAngle) * distanceFromCurrent;\r\n    mousePosY = this.y + Math.sin(interpolatedAngle) * distanceFromCurrent;\r\n    if (!isNaN(mousePosX) && !isNaN(mousePosY)) {\r\n    } else {\r\n      console.log(\"mousePos NaN\");\r\n    }\r\n    return { X: mousePosX, Y: mousePosY };\r\n  }\r\n  randomlyConsiderChangingState(chance = 1) {\r\n    if (Math.random() > chance) {\r\n      this.followingPlayerID = \"\";\r\n      this.target.x = 0;\r\n      this.target.y = 0;\r\n      this.chooseNewBotState();\r\n    }\r\n  }\r\n  chooseNewBotState() {\r\n    //for now randomly choose new state\r\n    if (Math.random() > 0.8) {\r\n      this.botState = BotState.FOLLOW_PLAYER;\r\n    } else if (Math.random() > 0.4) {\r\n      this.botState = BotState.RANDOM;\r\n    } else {\r\n      this.botState = BotState.COLLECT;\r\n    }\r\n  }\r\n}\r\n\r\nexport function serializeBots(bots, onlyChangedData = false) {\r\n  if (onlyChangedData) {\r\n    // Serialize and return only the changed bots\r\n    const changedBotData = bots\r\n      .map((currentBot) => {\r\n        const lastSentBotData = lastSentBots.find((lastBotData) => lastBotData.id === currentBot.id);\r\n        const serializedBot = serializeBot(currentBot);\r\n\r\n        // Compare the serialized data of the current bot with the last sent data\r\n        if (!lastSentBotData || !areUpdateCriticalValuesSameBot(serializedBot, lastSentBotData)) {\r\n          // Update lastSentBots with the new serialized data if changed\r\n          lastSentBots = lastSentBots.map((bot) => (bot.id === currentBot.id ? serializedBot : bot));\r\n          return serializedBot;\r\n        }\r\n\r\n        // Return null for bots that haven't changed\r\n        return null;\r\n      })\r\n      .filter((changedData) => changedData !== null);\r\n\r\n    return changedBotData;\r\n  } else {\r\n    // If onlyChangedData is false, update lastSentBots with the current serialized data\r\n    lastSentBots = bots.map(serializeBot);\r\n\r\n    // Serialize and return all bots\r\n    return lastSentBots;\r\n  }\r\n}\r\n\r\n// Define a function to serialize a bot's data\r\nfunction serializeBot(bot) {\r\n  return {\r\n    id: bot.id,\r\n    x: bot.x,\r\n    y: bot.y,\r\n    vel: bot.vel,\r\n    isDead: bot.isDead,\r\n    angle: bot.getAngle(),\r\n    currentSpeed: bot.currentSpeed,\r\n    timeOfLastActive: bot.timeOfLastActive,\r\n    playerAngleData: bot.playerAngleData,\r\n    mousePosX: bot.mousePosX,\r\n    mousePosY: bot.mousePosY,\r\n    isPlaying: bot.isPlaying,\r\n    special: bot.special,\r\n    distanceFactor: bot.distanceFactor,\r\n    lives: bot.lives,\r\n    space: bot.space,\r\n    shift: bot.shift,\r\n    u: bot.u,\r\n    forceCoolDown: bot.forceCoolDown,\r\n    comboScaler: bot.comboScaler,\r\n    kills: bot.kills,\r\n    ticksSincePowerUpCollection: bot.ticksSincePowerUpCollection,\r\n    timeSinceSpawned: bot.timeSinceSpawned,\r\n    botState: bot.botState,\r\n    target: bot.target,\r\n    followingPlayerID: bot.followingPlayerID,\r\n    previousAngleDifference: bot.previousAngleDifference,\r\n    previousTurnDirection: bot.previousTurnDirection,\r\n    invincibleTimer: bot.invincibleTimer,\r\n    name: bot.name,\r\n    inForce: bot.inForce,\r\n  };\r\n}\r\n\r\n// Define a function to compare bot objects for equality\r\nfunction areUpdateCriticalValuesSameBot(bot1, bot2) {\r\n  let isSame =\r\n    bot1.isDead === bot2.isDead &&\r\n    bot1.angle === bot2.angle &&\r\n    bot1.isPlaying === bot2.isPlaying &&\r\n    bot1.distanceFactor === bot2.distanceFactor &&\r\n    bot1.lives === bot2.lives &&\r\n    bot1.space === bot2.space &&\r\n    bot1.shift === bot2.shift &&\r\n    bot1.u === bot2.u &&\r\n    bot1.comboScaler === bot2.comboScaler &&\r\n    bot1.kills === bot2.kills &&\r\n    bot1.botState === bot2.botState &&\r\n    bot1.target === bot2.target &&\r\n    bot1.followingPlayerID === bot2.followingPlayerID &&\r\n    bot1.name === bot2.name &&\r\n    bot1.inForce === bot2.inForce;\r\n  return isSame;\r\n}\r\n\r\nfunction isEqualBot(bot1, bot2) {\r\n  const tolerance = 1e-4;\r\n\r\n  let isSame =\r\n    Math.abs(bot1.x - bot2.x) < tolerance &&\r\n    Math.abs(bot1.y - bot2.y) < tolerance &&\r\n    bot1.x === bot2.x &&\r\n    bot1.y === bot2.y &&\r\n    bot1.vel === bot2.vel &&\r\n    bot1.isDead === bot2.isDead &&\r\n    bot1.getAngle() === bot2.getAngle() &&\r\n    bot1.currentSpeed === bot2.currentSpeed &&\r\n    bot1.timeOfLastActive === bot2.timeOfLastActive &&\r\n    bot1.playerAngleData === bot2.playerAngleData &&\r\n    bot1.mousePosX === bot2.mousePosX &&\r\n    bot1.mousePosY === bot2.mousePosY &&\r\n    bot1.isPlaying === bot2.isPlaying &&\r\n    bot1.special === bot2.special &&\r\n    bot1.distanceFactor === bot2.distanceFactor &&\r\n    bot1.lives === bot2.lives &&\r\n    bot1.space === bot2.space &&\r\n    bot1.shift === bot2.shift &&\r\n    bot1.u === bot2.u &&\r\n    bot1.forceCoolDown === bot2.forceCoolDown &&\r\n    bot1.comboScaler === bot2.comboScaler &&\r\n    bot1.kills === bot2.kills &&\r\n    bot1.ticksSincePowerUpCollection === bot2.ticksSincePowerUpCollection &&\r\n    bot1.timeSinceSpawned === bot2.timeSinceSpawned &&\r\n    bot1.botState === bot2.botState &&\r\n    bot1.target === bot2.target &&\r\n    bot1.followingPlayerID === bot2.followingPlayerID &&\r\n    bot1.previousAngleDifference === bot2.previousAngleDifference &&\r\n    bot1.previousTurnDirection === bot2.previousTurnDirection &&\r\n    bot1.invincibleTimer === bot2.invincibleTimer &&\r\n    bot1.name === bot2.name &&\r\n    bot1.inForce === bot2.inForce;\r\n  return isSame;\r\n}\r\n","import { player, bots, mines, globalPowerUps } from \"./main.js\";\r\nimport { connections, isPlayerMasterPeer, compression } from \"./connectionHandlers.js\";\r\nimport { forces, effects } from \"./entities.js\";\r\nimport { serializeForces, serializeMines, serializeGlobalPowerUps, serializeEffects } from \"./entitySerialisation.js\";\r\nimport { serializeBots } from \"./player.js\";\r\n\r\nlet sendCounter = 0;\r\nlet lastSentPlayerData = [];\r\n\r\nexport function sendRequestForStates() {\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    requestForFullStates: true,\r\n  };\r\n  sendData(data);\r\n}\r\n// Send player state to other connected players\r\nexport function sendPlayerStates(playerToSend, masterSending, sendFullerData = false, playerReseting = false) {\r\n  if (Math.random() > 0.99) {\r\n    //every so often we will send the full data just to be sure master is in sync with important properties which don't often change\r\n    sendFullerData = true;\r\n  }\r\n  let priority = 3;\r\n  if (sendFullerData) {\r\n    priority = 2;\r\n  }\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: priority,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    id: playerToSend.id,\r\n    // invincibleTimer: playerToSend.invincibleTimer,\r\n  };\r\n\r\n  let newDataToSend = false;\r\n  newDataToSend = addProperty(playerToSend, data, \"x\", \"x\") || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"y\", \"y\") || newDataToSend;\r\n  // newDataToSend = addProperty(playerToSend, data, \"powerUps\", \"powerUps\") || newDataToSend;\r\n  //   newDataToSend = addProperty(playerToSend, data, \"invincibleTimer\", \"invincibleTimer\") || newDataToSend;\r\n\r\n  newDataToSend = addProperty(playerToSend, data, \"color\", \"color\", sendFullerData) || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"pilot\", \"pilot\", sendFullerData) || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"name\", \"name\", sendFullerData) || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"isMaster\", \"isMaster\", sendFullerData) || newDataToSend;\r\n  // newDataToSend = addProperty(playerToSend, data, \"ticksSincePowerUpCollection\", \"ticksSincePowerUpCollection\", sendFullerData) || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"targetedBy\", \"targetedBy\", sendFullerData) || newDataToSend;\r\n\r\n  //todo check this is ok to remove\r\n  // newDataToSend = addProperty(playerToSend, data, \"timeOfLastActive\", \"timeOfLastActive\", sendFullerData) || newDataToSend;\r\n\r\n  // newDataToSend = addProperty(playerToSend, data, \"recentScoreTicks\", \"recentScoreTicks\", sendFullerData) || newDataToSend;\r\n  // newDataToSend = addProperty(playerToSend, data, \"recentScoreText\", \"recentScoreText\", sendFullerData) || newDataToSend;\r\n  // newDataToSend = addProperty(playerToSend, data, \"kills\", \"kills\", sendFullerData) || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"angle\", \"angle\", sendFullerData) || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"isBot\", \"isBot\", sendFullerData) || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"special\", \"special\", sendFullerData) || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"devMode\", \"devMode\", sendFullerData) || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"space\", \"space\", sendFullerData) || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"shift\", \"shift\", sendFullerData) || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"resetting\", \"resetting\", sendFullerData) || newDataToSend;\r\n\r\n  // newDataToSend = addProperty(playerToSend, data, \"invincibleTimer\", \"invincibleTimer\") || newDataToSend;\r\n\r\n  newDataToSend = addProperty(playerToSend, data, \"forceCoolDown\", \"forceCoolDown\") || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"playerAngleData\", \"playerAngleData\") || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"mousePosX\", \"mousePosX\") || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"mousePosY\", \"mousePosY\") || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"currentSpeed\", \"currentSpeed\") || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"vel\", \"vel\") || newDataToSend;\r\n  newDataToSend = addProperty(playerToSend, data, \"distanceFactor\", \"distanceFactor\") || newDataToSend;\r\n\r\n  if (masterSending || sendFullerData) {\r\n    //only master sends is dead message since it is the abibter of collisions, apart from sendFullerData\r\n    if (lastSentPlayerData.isDead != playerToSend.isDead || sendFullerData) {\r\n      newDataToSend = true;\r\n      data.isDead = playerToSend.isDead;\r\n      lastSentPlayerData.isDead = playerToSend.isDead;\r\n    }\r\n    if (!playerToSend.isPlaying) {\r\n      newDataToSend = addProperty(playerToSend, data, \"isPlaying\", \"isPlaying\", sendFullerData) || newDataToSend;\r\n    }\r\n    if (masterSending || playerReseting) {\r\n      newDataToSend = addProperty(playerToSend, data, \"invincibleTimer\", \"invincibleTimer\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"powerUps\", \"powerUps\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"ticksSincePowerUpCollection\", \"ticksSincePowerUpCollection\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"recentScoreTicks\", \"recentScoreTicks\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"recentScoreText\", \"recentScoreText\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"recentKillScoreText\", \"recentKillScoreText\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"kills\", \"kills\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"comboScaler\", \"comboScaler\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"killed\", \"killed\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"killedBy\", \"killedBy\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"hitBy\", \"hitBy\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"lives\", \"lives\", sendFullerData) || newDataToSend;\r\n      newDataToSend = addProperty(playerToSend, data, \"isPlaying\", \"isPlaying\", sendFullerData) || newDataToSend;\r\n    }\r\n  }\r\n  if (!masterSending) {\r\n    //only player sends timeSinceSpawned because it knows when it has reset\r\n    if (newDataToSend) {\r\n      data.timeSinceSpawned = playerToSend.timeSinceSpawned;\r\n    }\r\n  }\r\n  if (newDataToSend) {\r\n    sendData(data);\r\n  }\r\n}\r\n\r\n// Define a function to add properties to the data object if they have changed\r\nfunction addProperty(playerToSend, data, propertyKey, playerKey, sendAnyway = false) {\r\n  if (lastSentPlayerData[propertyKey] !== playerToSend[playerKey] || sendAnyway) {\r\n    if ((playerToSend[playerKey] == null && playerKey != \"angle\") || (playerToSend.getAngle() == null && playerKey == \"angle\")) {\r\n      console.log(\"null property in send player state: \" + playerKey);\r\n      return false;\r\n    }\r\n    if (playerKey != \"angle\") {\r\n      data[propertyKey] = playerToSend[playerKey];\r\n      lastSentPlayerData[propertyKey] = playerToSend[playerKey];\r\n    } else {\r\n      data[propertyKey] = playerToSend.getAngle();\r\n      lastSentPlayerData[propertyKey] = playerToSend.getAngle();\r\n    }\r\n    return true; // property was changed\r\n  }\r\n  return false; // property was not changed\r\n}\r\n\r\n//this is the full send that will only be sent on request / occasionally\r\nexport function sendEntitiesState(specificPeerId = \"\") {\r\n  if (!anyConnections()) {\r\n    return;\r\n  }\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    gameState: true,\r\n    fullSend: true,\r\n    globalPowerUps: serializeGlobalPowerUps(globalPowerUps),\r\n    effects: serializeEffects(effects),\r\n    bots: serializeBots(bots),\r\n    mines: serializeMines(mines),\r\n    effects: serializeEffects(effects),\r\n    // otherPlayers: otherPlayers,\r\n    forces: serializeForces(forces),\r\n    // connectedPeers: connectedPeers,\r\n    //enemies and stuff here\r\n  };\r\n  if (specificPeerId && specificPeerId != \"\") {\r\n    sendData(data, specificPeerId);\r\n  } else {\r\n    sendData(data);\r\n  }\r\n}\r\n\r\n//this is the partial send that will be sent regually\r\nexport function sendEntitiesUpdate() {\r\n  if (!anyConnections()) {\r\n    return;\r\n  }\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    gameState: true,\r\n    globalPowerUps: serializeGlobalPowerUps(globalPowerUps, true),\r\n    effects: serializeEffects(effects, true),\r\n    bots: serializeBots(bots, true),\r\n    mines: serializeMines(mines, true),\r\n    forces: serializeForces(forces, true),\r\n    // connectedPeers: connectedPeers,\r\n  };\r\n  sendData(data);\r\n}\r\n\r\n//this is the bot send that will be sent most frequently\r\nexport function sendBotEntitiesUpdate() {\r\n  if (!anyConnections()) {\r\n    return;\r\n  }\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    gameState: true,\r\n    bots: serializeBots(bots, true),\r\n  };\r\n  sendData(data);\r\n}\r\n\r\n//this is the powerup update that will only be sent on request / occasionally\r\nexport function sendPowerUpsUpdate(onlyChangedData = true) {\r\n  if (!anyConnections()) {\r\n    return;\r\n  }\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    gameState: true,\r\n    globalPowerUps: serializeGlobalPowerUps(globalPowerUps, onlyChangedData),\r\n  };\r\n  sendData(data);\r\n}\r\n\r\n//this is the mines only update  will only be sent on request / occasionally\r\nexport function sendMinesUpdate(onlyChangedData = true, onlyRegularMines = true) {\r\n  if (!anyConnections()) {\r\n    return;\r\n  }\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    gameState: true,\r\n    mines: serializeMines(mines, onlyChangedData, onlyRegularMines),\r\n  };\r\n\r\n  sendData(data);\r\n}\r\n\r\n//this is the effects only update that will only be sent on request / occasionally\r\nexport function sendEffectsUpdate(onlyChangedData = true) {\r\n  if (!anyConnections()) {\r\n    return;\r\n  }\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    gameState: true,\r\n    effects: serializeEffects(effects, onlyChangedData),\r\n  };\r\n\r\n  sendData(data);\r\n}\r\n\r\nexport function sendForcesUpdate(onlyChangedData = true) {\r\n  if (!anyConnections()) {\r\n    return;\r\n  }\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    gameState: true,\r\n    forces: serializeForces(forces, onlyChangedData),\r\n  };\r\n\r\n  sendData(data);\r\n}\r\n\r\nexport function sendBotsUpdate(onlyChangedData = true) {\r\n  if (!anyConnections()) {\r\n    return;\r\n  }\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    gameState: true,\r\n    bots: serializeBots(bots, onlyChangedData),\r\n  };\r\n\r\n  sendData(data);\r\n}\r\n\r\nexport function sendRemoveEntityUpdate(propertyName, entitiesToRemove) {\r\n  // Send game state to other player\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    gameState: true,\r\n  };\r\n\r\n  // Add the specified property name and its value to the data object\r\n  data[propertyName] = entitiesToRemove;\r\n\r\n  sendData(data);\r\n}\r\n\r\nexport function sendConnectedPeers() {\r\n  // Send game state to other player\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    gameState: true,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    //todo this could be the issue\r\n    //connectedPeers: connectedPeers,\r\n    //enemies and stuff here\r\n  };\r\n\r\n  //console.log(\"Sending data:\", data); // Log any data sent\r\n  connections.forEach((conn) => {\r\n    if (conn && conn.open) {\r\n      conn.send(data);\r\n      sendCounter++;\r\n      // Log the data every 1000 calls\r\n      if (sendCounter === 5000) {\r\n        //console.log(\"sending bots state data:\", data);\r\n        sendCounter = 0; // reset the counter\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n//this is the full send that will only be sent on request / occasionally\r\nexport function requestFullUpdate() {\r\n  // Send game state to other player\r\n  let data = {\r\n    timestamp: Date.now(),\r\n    priority: 2,\r\n    fromMaster: isPlayerMasterPeer(player),\r\n    requestFullUpdate: true,\r\n  };\r\n\r\n  sendData(data);\r\n}\r\n\r\nfunction sendData(data, specificPeerId) {\r\n  if (data) {\r\n    if (compression) {\r\n      const jsonString = JSON.stringify(data);\r\n\r\n      // Encode the JSON string as Uint8Array\r\n      const encoder = new TextEncoder();\r\n      const dataArray = encoder.encode(jsonString);\r\n\r\n      // Compress the data using Pako\r\n      data = pako.deflate(dataArray);\r\n    }\r\n    connections.forEach((conn) => {\r\n      if (conn && conn.open) {\r\n        if (specificPeerId && specificPeerId != \"\" && specificPeerId != conn.peer) {\r\n          return;\r\n        }\r\n        try {\r\n          conn.send(data);\r\n        } catch (error) {\r\n          console.error(\"Error sending data:\", error);\r\n        }\r\n      }\r\n    });\r\n  } else {\r\n    console.log(\"nothing to send in sendData\");\r\n  }\r\n}\r\n\r\nfunction anyConnections() {\r\n  if (connections && connections.length > 0) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n","import { player, setMines, bots, mines, globalPowerUps, colors } from \"./main.js\";\r\nimport { isPlayerMasterPeer } from \"./connectionHandlers.js\";\r\nimport { isSpokeCollision } from \"./collisionLogic.js\";\r\nimport { sendMinesUpdate, sendPowerUpsUpdate } from \"./sendData.js\";\r\nimport { PowerUp, effects, Effect, EffectType, MineType, FreeMine } from \"./entities.js\";\r\nimport { getRandomUniqueColor, findCompleteShape, isPointInsideShape } from \"./gameUtils.js\";\r\n\r\nexport function ProcessTrailShapesAllPlayers(player, otherPlayers) {\r\n  let allPlayers = [...bots, ...otherPlayers, player];\r\n  for (let candidatePlayer of allPlayers) {\r\n    ProcessTrailShapes(candidatePlayer, allPlayers);\r\n  }\r\n}\r\n\r\nfunction ProcessTrailShapes(candidatePlayer, allPlayers) {\r\n  const shape = findCompleteShape(candidatePlayer.id, mines, 30000);\r\n\r\n  if (shape && shape.shapePath) {\r\n    let freeMine = createFreeMine(candidatePlayer, shape);\r\n    handleFreeMineSpawn(candidatePlayer.id, mines, freeMine, shape, allPlayers);\r\n    // createEffects(shape.shapePath, effects);\r\n    if (isPlayerMasterPeer(player)) {\r\n      sendMinesUpdate();\r\n    }\r\n  }\r\n}\r\n\r\n// Function to create a FreeMine\r\nfunction createFreeMine(player, shape) {\r\n  let freeMine = new FreeMine(\r\n    \"trail-\" + Math.floor(Math.random() * 10000),\r\n    shape.center.x,\r\n    shape.center.y,\r\n    40,\r\n    70,\r\n    player.color,\r\n    0,\r\n    MineType.FREE_MINE,\r\n    -1,\r\n    player.id,\r\n    0,\r\n    shape.shapePath\r\n  );\r\n  freeMine.spokeWidth = shape.spokeWidth;\r\n  freeMine.spokeLength = shape.spokeLength;\r\n  return freeMine;\r\n}\r\n\r\nfunction createEffects(shapePath, effects) {\r\n  for (let point of shapePath) {\r\n    let effect = new Effect(\"effect-\" + Math.floor(Math.random() * 10000), point.x, point.y, 40, 30, \"OrangeRed\", EffectType.EXPLOSION);\r\n    effects.push(effect);\r\n  }\r\n}\r\n\r\nfunction handleFreeMineSpawn(playerId, mines, freeMine, shape, allPlayers) {\r\n  removePlayerTrailMines(playerId, mines);\r\n  mines.push(freeMine);\r\n  //   createExplosionEffects(shape.shapePath);\r\n\r\n  destroyOverlappingMines(mines, shape, freeMine, playerId);\r\n  hitPlayersCaught(allPlayers, playerId, shape, freeMine);\r\n}\r\n\r\nfunction removePlayerTrailMines(playerId, mines) {\r\n  mines = mines.filter((mine) => mine.playerId != playerId);\r\n  setMines(mines);\r\n}\r\n\r\nfunction createExplosionEffects(shapePath) {\r\n  for (let point of shapePath) {\r\n    let effect = new Effect(\"effect-\" + Math.floor(Math.random() * 10000), point.x, point.y, 40, 30, \"OrangeRed\", EffectType.EXPLOSION);\r\n    effects.push(effect);\r\n  }\r\n}\r\n\r\nfunction destroyOverlappingMines(mines, shape, freeMine, playerId) {\r\n  for (let mine of mines) {\r\n    if (mine.mineType !== MineType.FREE_MINE && mine.playerId != playerId) {\r\n      if (isMineOverlapping(shape, mine, freeMine)) {\r\n        destroyMine(mine);\r\n        addPowerUpOnMineDestroy(mine);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction isMineOverlapping(shape, mine, freeMine) {\r\n  return (\r\n    isPointInsideShape(shape.shapePath, { x: mine.x, y: mine.y }) ||\r\n    isSpokeCollision(mine, mine.radius + 10, freeMine.x, freeMine.y, 0, shape.spokeLength, shape.spokeWidth + 5)\r\n  );\r\n}\r\n\r\nfunction destroyMine(mine) {\r\n  mine.hitFrames = 5;\r\n}\r\n\r\nfunction addPowerUpOnMineDestroy(mine) {\r\n  let addPowerup = shouldAddPowerupOnMineDestroy(mine);\r\n  if (addPowerup) {\r\n    createPowerUpFromMine(mine);\r\n  }\r\n}\r\n\r\nfunction shouldAddPowerupOnMineDestroy(mine) {\r\n  if (mine.mineType === MineType.TRAIL && Math.random() > 0.5) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction createPowerUpFromMine(mine) {\r\n  let isStar = false;\r\n  let radius = 35;\r\n  let value = 3;\r\n  let hasGravity = 0;\r\n\r\n  if (Math.random() > 0.7) {\r\n    if (Math.random() > 0.2) {\r\n      hasGravity = -1;\r\n      value = 5;\r\n      radius = 30;\r\n    } else {\r\n      hasGravity = 1;\r\n    }\r\n  }\r\n\r\n  let powerUp = new PowerUp(\r\n    \"mineConvert-\" + Math.floor(Math.random() * 10000),\r\n    mine.x,\r\n    mine.y,\r\n    getRandomUniqueColor(colors, null),\r\n    isStar,\r\n    radius,\r\n    value,\r\n    hasGravity\r\n  );\r\n\r\n  globalPowerUps.push(powerUp);\r\n  if (isPlayerMasterPeer(player)) {\r\n    sendPowerUpsUpdate(true);\r\n  }\r\n}\r\n\r\nfunction hitPlayersCaught(allPlayers, playerId, shape, freeMine) {\r\n  for (let candidatePlayer of allPlayers) {\r\n    if (candidatePlayer.id === playerId) {\r\n      continue; // Don't hit the player who created this\r\n    }\r\n\r\n    if (isPlayerCaughtInExplosion(shape, candidatePlayer, freeMine)) {\r\n      handlePlayerHitByExplosion(playerId, candidatePlayer, allPlayers);\r\n    }\r\n  }\r\n}\r\n\r\nfunction isPlayerCaughtInExplosion(shape, candidatePlayer, freeMine) {\r\n  return (\r\n    isPointInsideShape(shape.shapePath, { x: candidatePlayer.x, y: candidatePlayer.y }) ||\r\n    isSpokeCollision(candidatePlayer, 10, freeMine.x, freeMine.y, 0, shape.spokeLength, shape.spokeWidth + 5)\r\n  );\r\n}\r\n\r\nfunction handlePlayerHitByExplosion(playerId, candidatePlayer, allPlayers) {\r\n  let owner = allPlayers.find((player) => player.id === playerId);\r\n  let name = owner && owner.name ? owner.name : \"\";\r\n\r\n  if (candidatePlayer.isVulnerable()) {\r\n    candidatePlayer.gotHit(name);\r\n    if (owner) {\r\n      owner.hitOtherPlayer(candidatePlayer);\r\n    }\r\n  }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./main.js\");\n",""],"names":[],"sourceRoot":""}