const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = 1200;
canvas.height = 600;

const worldWidth = 3600;
const worldHeight = 2400;

let powerups = [];
// Random initial position, at least 100 units away from each edge
centerX = 100 + Math.random() * (worldWidth - 200);
centerY = 100 + Math.random() * (worldHeight - 200);

// Initial camera position at start of game
camX = centerX - canvas.width / 2;
camY = centerY - canvas.height / 2;
const radius = 50;
const maxDistance = Math.sqrt((canvas.width / 2) ** 2 + (canvas.height / 2) ** 2);
const shipPoints = [
  { x: 0, y: -20 },
  { x: -10, y: 20 },
  { x: 0, y: 10 },
  { x: 10, y: 20 },
];
let mousePos = { x: 0, y: 0 };
let angle = 0;
const acceleration = 0.1;
const friction = 0.95;
let vel = { x: 0, y: 0 };

// Define the max distance (2 ship lengths in this case)
let maxForceDistance = 2 * 20;

let distanceFactor;
let keys = {
  up: false,
  down: false,
  left: false,
  right: false,
};

const colors = ["red", "blue", "green", "yellow", "purple", "orange", "pink", "violet", "maroon", "crimson", "white"];
let color = colors[Math.floor(Math.random() * colors.length)];
let everConnected = false;
let conn;
let connections = [];
let peerIds = [
  "a7ef962d-14a8-40e4-8a1e-226a438a345d",
  "b7ef962d-14a8-40e4-8a1e-226a438a345d",
  "c7ef962d-14a8-40e4-8a1e-226a438a345d",
  "d7ef962d-14a8-40e4-8a1e-226a438a345d",
  "e7ef962d-14a8-40e4-8a1e-226a438a345d",
  "a6ef962d-14a8-40e4-8a1e-226a438a345d",
  "b6ef962d-14a8-40e4-8a1e-226a438a345d",
];

shuffleArray(peerIds);
let myId = null;
let index = 0;
let peer; // Declare the peer variable here
let otherPlayers = [];
let handleCounter = 0;
let sendCounter = 0;

/* START CONNECTION HANDLERS  */

function tryNextId() {
  if (index >= peerIds.length) {
    console.log("All IDs are in use");
    return;
  }

  let id = peerIds[index];
  peer = new Peer(id); // Assign the new Peer to the peer variable

  peer.on("open", function () {
    // If the ID is already in use, this will not be called
    myId = id;
    console.log("My peer ID is: " + id);
  });

  peer.on("error", function (err) {
    // If the ID is already in use, an error will be thrown
    if (err.type === "unavailable-id") {
      console.log("ID is in use:", id);
      index++;

      tryNextId();
    } else {
      // console.log("Other error:", err);
      //console.log("Other error:");
    }
  });
}

tryNextId();
// Wait for a short delay to allow time for the connections to be attempted
setTimeout(function () {
  if (myId === null) {
    console.log("All IDs are in use");
    return;
  }

  peer.on("connection", function (conn) {
    console.log("Connection made with peer:", conn.peer);
    addConnectionHandlers(conn);
  });

  peer.on("error", function (err) {
    //console.log("PeerJS error:");
  });

  peer.on("disconnected", function () {
    console.log("Disconnected from server");
  });

  connectToPeers();
}, 3000);

function addConnectionHandlers(conn) {
  everConnected = true;
  console.log("adding connection handlers");
  conn.on("open", function () {
    console.log("Connection opened with peer:", conn.peer);
    connections.push(conn);
    let existingOtherPlayer = otherPlayers.some((player) => player.id === conn.peer);
    if (!existingOtherPlayer) {
      let otherPlayerData = {
        id: conn.peer,
        x: -200,
        y: -200,
        angle: 0,
        color: "blue",
      };
      otherPlayers.push(otherPlayerData);
    }

    // Send the current powerups to the new peer
    sendPowerups();
  });

  conn.on("error", function (err) {
    console.log("Connection error with peer:", conn.peer, ", error:", err);
  });

  conn.on("close", function () {
    console.log("Connection closed with peer:", conn.peer);
    // Remove player from otherPlayers array
    otherPlayers = otherPlayers.filter((player) => player.id !== conn.peer);
  });

  conn.on("data", function (data) {
    //console.log("Received data:", data);
    if ((data && data.id) || (data && data.powerups)) {
      handleData(data);
    } else {
      console.log("Received unexpected data:", data);
    }
  });
}

function handleData(data) {
  //console.log("handling data:");
  // Find the player in the array
  let player = otherPlayers.find((player) => player.id === data.id);

  // If the player is found, update their data
  if (player) {
    player.x = data.x;
    player.y = data.y;
    player.angle = data.angle;
    player.color = data.color;
  }
  // If the player is not found, add them to the array
  else {
    otherPlayers.push(data);
  }
  // Only update the powerups if the received data contains powerups
  if (data.powerups) {
    powerups = data.powerups;
  }
  handleCounter++;
  // Log the data every 1000 calls
  if (handleCounter === 1000) {
    console.log("handling data:", data);
    handleCounter = 0; // reset the counter
  }
}

setInterval(connectToPeers, 6000);
setInterval(generatePowerups, 3000);
setInterval(sendPowerups, 3000);

function connectToPeers() {
  // Connect to the other peers
  peerIds.forEach((id) => {
    if (id !== myId) {
      // Check if a connection with this id already exists
      let existingConnection = connections.find((conn) => conn.peer === id);
      if (!existingConnection) {
        let conn = peer.connect(id);
        if (conn != null && conn != undefined) {
          //connections.push(conn); // Add the connection to the array
          addConnectionHandlers(conn);
        }
      } else {
        console.log("existing connection with: " + id);
      }
    }
  });
}

/* END CONNECTION HANDLERS  */

/* START INPUT EVENT HANDLERS  */

window.addEventListener("keydown", function (e) {
  if (e.code === "Space") {
    keys.space = true;
  }
});

window.addEventListener("keyup", function (e) {
  if (e.code === "Space") {
    keys.space = false;
  }
});

canvas.addEventListener(
  "mousemove",
  function (evt) {
    let coords = getMousePos(canvas, evt);
    mousePos.x = coords.x + camX;
    mousePos.y = coords.y + camY;
    angle = calculateAngle(mousePos);
  },
  false
);

canvas.addEventListener("mousedown", function (e) {
  keys.space = true;
});

canvas.addEventListener("mouseup", function (e) {
  keys.space = false;
});

canvas.addEventListener("touchstart", function (e) {
  keys.space = true;

  // Update mouse position on touch start
  if (e.touches) {
    mousePos.x = e.touches[0].clientX + camX;
    mousePos.y = e.touches[0].clientY + camY;
    angle = calculateAngle(mousePos);
  }
});

canvas.addEventListener("touchend", function (e) {
  keys.space = false;
});

canvas.addEventListener(
  "touchmove",
  function (e) {
    // Prevent scrolling when touching the canvas
    e.preventDefault();

    if (e.touches) {
      let coords = getMousePos(canvas, e.touches[0]);
      mousePos.x = coords.x + camX;
      mousePos.y = coords.y + camY;
      angle = calculateAngle(mousePos);
    }
  },
  { passive: false }
); // Set passive to false to prevent scrolling

/* END INPUT EVENT HANDLERS  */

function shipHitsBorder(x, y) {
  return x < 0 || y < 0 || x > worldWidth || y > worldHeight;
}

function calculateAngle(mousePos) {
  return Math.atan2(mousePos.y - centerY, mousePos.x - centerX);
}

function getMousePos(canvas, evt) {
  var rect = canvas.getBoundingClientRect();
  return {
    x: evt.clientX - rect.left,
    y: evt.clientY - rect.top,
  };
}

function update() {
  const bounceFactor = 1.5; // Adjust this to control bounce behavior
  const offset = 1; // Adjust this to make sure ship doesn't get "stuck" in the wall
  const camSpeed = 0.025; // Adjust this to control camera "lag"
  const minBounceSpeed = 5;

  // camera gradually moves towards the ship
  const targetCamX = centerX - canvas.width / 2;
  const targetCamY = centerY - canvas.height / 2;
  camX += (targetCamX - camX) * camSpeed;
  camY += (targetCamY - camY) * camSpeed;

  // prevent camera from going outside of world
  camX = Math.min(camX, worldWidth - canvas.width);
  camX = Math.max(camX, 0);
  camY = Math.min(camY, worldHeight - canvas.height);
  camY = Math.max(camY, 0);

  // compute a unit vector pointing from the mouse to the center
  let dx = centerX - mousePos.x;
  let dy = centerY - mousePos.y;
  let distance = Math.sqrt(dx * dx + dy * dy);
  let shipAngle = Math.atan2(dy, dx) + Math.PI / 2;

  let speed = Math.sqrt(vel.x * vel.x + vel.y * vel.y);
  let squareFactor = speed * speed;
  let newFriction = 0.99 - squareFactor * 0.001;
  newFriction = Math.max(newFriction, 0.7);

  vel.x *= newFriction;
  vel.y *= newFriction;

  if (keys.space) {
    let mouseToCenter = { x: dx / distance, y: dy / distance };
    let maxForceDistance = 2 * 20;

    if (distance > maxForceDistance) {
      distanceFactor = 1;
    } else {
      distanceFactor = Math.min(1, distance / (canvas.width / 2));
    }

    vel.x += acceleration * distanceFactor * mouseToCenter.x;
    vel.y += acceleration * distanceFactor * mouseToCenter.y;
  }
  // If the ship hits the edge of the world, bounce
  if (centerX < 0) {
    vel.x = -vel.x * bounceFactor;
    centerX = offset;
    if (Math.abs(vel.x) < minBounceSpeed) {
      vel.x = (vel.x < 0 ? -1 : 1) * minBounceSpeed;
    }
  } else if (centerX > worldWidth) {
    vel.x = -vel.x * bounceFactor;
    centerX = worldWidth - offset;
    if (Math.abs(vel.x) < minBounceSpeed) {
      vel.x = (vel.x < 0 ? -1 : 1) * minBounceSpeed;
    }
  }

  if (centerY < 0) {
    vel.y = -vel.y * bounceFactor;
    centerY = offset;
    if (Math.abs(vel.y) < minBounceSpeed) {
      vel.y = (vel.y < 0 ? -1 : 1) * minBounceSpeed;
    }
  } else if (centerY > worldHeight) {
    vel.y = -vel.y * bounceFactor;
    centerY = worldHeight - offset;
    if (Math.abs(vel.y) < minBounceSpeed) {
      vel.y = (vel.y < 0 ? -1 : 1) * minBounceSpeed;
    }
  }

  // The position needs to be restricted to within the world
  centerX += vel.x;
  centerY += vel.y;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawBackground();
  drawWorldBounds();

  ctx.lineWidth = 2;

  // Draw other players
  otherPlayers.forEach((player) => {
    drawRotatedShip(player.x, player.y, player.angle, shipPoints, player.color);
  });
 
  drawPowerups();
  drawMinimap();
  drawMinimapPowerups();
  drawRotatedShip(centerX, centerY, shipAngle, shipPoints, color);

  if (everConnected) {
    // Check if connection is open before sending data
    // Send game state to other player
    let data = {
      id: myId,
      x: centerX,
      y: centerY,
      angle: shipAngle,
      color: color,
    };
    //console.log("Sending data:", data); // Log any data sent
    connections.forEach((conn) => {
      if (conn && conn.open) {
        conn.send(data);
        sendCounter++;
        // Log the data every 1000 calls
        if (sendCounter === 1000) {
          console.log("sending data:", data);
          sendCounter = 0; // reset the counter
        }
      }
    });
  } else {
    connections.forEach((conn) => {
      if (conn && conn.closed) {
        console.log("Connection closed with peer:", conn.peer);
        // Remove player from otherPlayers array
        otherPlayers = otherPlayers.filter((player) => player.id !== conn.peer);
      } else if (!conn) {
        console.log("Connection null, removing from otherplayers list and from connections", conn.peer);
        // Remove player from otherPlayers array
        otherPlayers = otherPlayers.filter((player) => player.id !== conn.peer);
        //is it ok to do this in the foreach iterating over connections?
        connections = connections.filter((player) => player.id !== conn.peer);
      }
    });
  }

  requestAnimationFrame(update);
}

function drawRotatedShip(centerX, centerY, angle, points, color) {
  ctx.beginPath();

  // Move to the first point after rotating
  let rotatedPoint = rotatePoint(points[0].x, points[0].y, angle);
  ctx.moveTo(centerX - camX + rotatedPoint.x, centerY - camY + rotatedPoint.y);

  // Create a line for each point
  for (let i = 1; i < points.length; i++) {
    rotatedPoint = rotatePoint(points[i].x, points[i].y, angle);
    ctx.lineTo(centerX - camX + rotatedPoint.x, centerY - camY + rotatedPoint.y);
  }

  ctx.strokeStyle = color;
  ctx.stroke();
  ctx.closePath();
  ctx.strokeStyle = color;
  ctx.stroke();
}

// Rotate a point (x, y) by a certain angle
function rotatePoint(x, y, angle) {
  return {
    x: x * Math.cos(angle) - y * Math.sin(angle),
    y: x * Math.sin(angle) + y * Math.cos(angle),
  };
}

function drawBackground() {
  ctx.fillStyle = "#999";
  ctx.fillRect(camX, camY, canvas.width, canvas.height);

  const gridSize = 100; // change as needed
  ctx.strokeStyle = "#555";
  ctx.lineWidth = 0.5;

  // horizontal lines
  for (let i = camY - (camY % gridSize); i < camY + canvas.height; i += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, i - camY);
    ctx.lineTo(canvas.width, i - camY);
    ctx.stroke();
  }

  // vertical lines
  for (let i = camX - (camX % gridSize); i < camX + canvas.width; i += gridSize) {
    ctx.beginPath();
    ctx.moveTo(i - camX, 0);
    ctx.lineTo(i - camX, canvas.height);
    ctx.stroke();
  }
}

function drawWorldBounds() {
  ctx.lineWidth = 10; // Line width increased
  ctx.strokeStyle = "blue";
  ctx.strokeRect(-camX, -camY, worldWidth, worldHeight);
}

function drawMinimap() {
  const minimapCanvas = document.getElementById("minimapCanvas");
  const minimapCtx = minimapCanvas.getContext("2d");

  const dotSize = 5; // Size of the dot
  const scaleX = (minimapCanvas.width - dotSize) / worldWidth; // Adjust scale
  const scaleY = (minimapCanvas.height - dotSize) / worldHeight; // Adjust scale

  // Clear the minimap
  minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

  // Draw the player's ship on the minimap
  minimapCtx.fillStyle = color;
  minimapCtx.fillRect(centerX * scaleX, centerY * scaleY, dotSize, dotSize);

  // Draw other players on the minimap
  otherPlayers.forEach((player) => {
    minimapCtx.fillStyle = player.color;
    minimapCtx.fillRect(player.x * scaleX, player.y * scaleY, dotSize, dotSize);
  });
}

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function generatePowerups() {
  // Check if there are less than 2 powerups
  if (powerups.length < 2) {
    // Generate a new dot with random x and y within the world
    let powerup = {
      x: Math.random() * worldWidth,
      y: Math.random() * worldHeight,
      color: colors[Math.floor(Math.random() * colors.length)],
    };
    powerups.push(powerup);

    // Send the powerups every time you generate one
    sendPowerups();
  }
}
function sendPowerups() {
  let powerUpData = {
    powerups: powerups,
  };

  connections.forEach((conn) => {
    if (conn && conn.open) {
      conn.send(powerUpData);
    }
  });
}
function drawPowerups() {
  // Draw each dot
  powerups.forEach((powerup) => {
    ctx.beginPath();
    ctx.arc(powerup.x - camX, powerup.y - camY, 10, 0, Math.PI * 2);
    ctx.fillStyle = powerup.color;
    ctx.fill();
  });
}

function drawMinimapPowerups() {
  const minimapCanvas = document.getElementById("minimapCanvas");
  const minimapCtx = minimapCanvas.getContext("2d");

  const powerupSize = 2; // Smaller size for powerups on the minimap
  const scaleX = (minimapCanvas.width - powerupSize) / worldWidth; // Adjust scale
  const scaleY = (minimapCanvas.height - powerupSize) / worldHeight; // Adjust scale

  // Draw each powerup on the minimap
  powerups.forEach((powerup) => {
    minimapCtx.fillStyle = powerup.color;
    minimapCtx.fillRect(powerup.x * scaleX, powerup.y * scaleY, powerupSize, powerupSize);
  });
}
update();


paralax
shooting stars effect
gravity black hole - reappear warp
powerups and black holes disappear after time, blinking out at the end.
select ship - different stats
enter name
music
sound effects
min speed should be further away


I want the ships to check for collision with the powerup and if they collide with it the power up should disappear and a property on the ship be incremented. THe powerup should be removed. This info should be sent to the other connected peers

When a ship collides with one of these the ship should get slightly bigger. 
We'll need to keep track of all ships size
When ships collide with each other the biggest should "win" and the smaller should be removed from the game for 3 seconds before respawning at a random location 